<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDW🥝</title>
  
  <subtitle>一个入行Java程序员</subtitle>
  <link href="https://eizo01.github.io/atom.xml" rel="self"/>
  
  <link href="https://eizo01.github.io/"/>
  <updated>2023-04-04T08:57:38.237Z</updated>
  <id>https://eizo01.github.io/</id>
  
  <author>
    <name>曾德威🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:28.303Z</published>
    <updated>2023-04-04T08:57:38.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-Bean定义配置化"><a href="#Spring源码手写篇-Bean定义配置化" class="headerlink" title="Spring源码手写篇-Bean定义配置化"></a>Spring源码手写篇-Bean定义配置化</h1><h1 id="一、Bean定义配置分析"><a href="#一、Bean定义配置分析" class="headerlink" title="一、Bean定义配置分析"></a>一、Bean定义配置分析</h1><p>&emsp;&emsp;我们前面实现了手写IoC和AOP的功能，但是我们在使用的时候发现我们的调用代码还是非常的繁琐，会给应用者很不好的体验。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/a3813fe22e7848cb9e46a82c8bb6ac8e.png" alt="image.png"></p><p>&emsp;&emsp;上面的代码很直观的看到重复代码很多，要用户设置的内容也很多，低效而且容易出错，这时我们可以看看在Spring中是怎么处理的呢？</p><p>一种是通过XML的配置文件方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;abean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.samples.ABean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abean01&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;cbean&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cbean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.samples.CBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cbean01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一种是通过注解的方式来处理</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Acc</span> ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-XML方式实现"><a href="#1-XML方式实现" class="headerlink" title="1. XML方式实现"></a>1. XML方式实现</h2><p>基于XML方式实现我们需要做什么操作呢?</p><ul><li>定义XML规范</li><li>要写代码来解析XML，完成Bean定义的注册</li></ul><h2 id="2-注解方式实现"><a href="#2-注解方式实现" class="headerlink" title="2.注解方式实现"></a>2.注解方式实现</h2><p>基于XML方式实现我们需要做什么操作呢?</p><ul><li>定义一套注解</li><li>要写代码来扫描、解析注解、完成Bean定义注册。</li></ul><h1 id="二、Bean定义配置实现"><a href="#二、Bean定义配置实现" class="headerlink" title="二、Bean定义配置实现"></a>二、Bean定义配置实现</h1><h2 id="1-XML方法设计"><a href="#1-XML方法设计" class="headerlink" title="1. XML方法设计"></a>1. XML方法设计</h2><p>&emsp;&emsp;xml方式的流程如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/b65b1279f9d34bb1835cff193182b5a4.png" alt="image.png"></p><p>我们可以自己写一个解析器，专门来解析对应的xml文件</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/ffd0f363cfaf451d951cd402bd294089.png" alt="image.png"></p><h2 id="2-注解方式设计"><a href="#2-注解方式设计" class="headerlink" title="2. 注解方式设计"></a>2. 注解方式设计</h2><h3 id="2-1-定义相关的注解"><a href="#2-1-定义相关的注解" class="headerlink" title="2.1 定义相关的注解"></a>2.1 定义相关的注解</h3><p>&emsp;&emsp;然后我们来看看需要定义的注解有哪些。</p><ul><li>类要不要配置为Bean       @Component</li><li>BeanName Scope和Primary   @Scope  @Primary</li><li>工厂方法  工厂Bean  @Bean</li><li>初始化方法、销毁方法 @PostConstruct @PreDestory</li><li>构造参数依赖 @Autowired @Value</li><li>属性依赖  @Qualifier</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/c0a718c8b2014741b6632f3fa015c43f.png" alt="image.png"></p><h3 id="2-2-扫描解析注册操作"><a href="#2-2-扫描解析注册操作" class="headerlink" title="2.2 扫描解析注册操作"></a>2.2 扫描解析注册操作</h3><p>&emsp;&emsp;我们定义了相关注解后，谁来实现扫描注解、解析注解并完成Bean定义注册呢</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/be1c3a58d5984cd69ff5cbfa057d63f8.png" alt="image.png"></p><p>先来看如何实现扫描操作</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/20b7d507fe0542eb84008560fdd7ee5d.png" alt="image.png"></p><p>实现的逻辑应该是递归找出包目录下的所有的.class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span> (basePackages != <span class="literal">null</span> &amp;&amp; basePackages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String p : basePackages) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1 递归扫描包目录下的.class文件</span></span><br><span class="line"><span class="comment"> 2 组合包路径+class文件名 得到全限定类名</span></span><br><span class="line"><span class="comment"> 3 ClassLoad.load(&quot;类名&quot;) 得到 Class 对象</span></span><br><span class="line"><span class="comment"> 4 解析Class上的注解，获得Bean定义信息，注册Bean定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1 递归扫描包目录下的.class文件</span></span><br><span class="line">            Set&lt;File&gt; classFiles = <span class="built_in">this</span>.doScan(p);</span><br><span class="line">            <span class="comment">//2 得到Class对象，并解析注解、注册Bean定义</span></span><br><span class="line">            <span class="built_in">this</span>.readAndRegisterBeanDefintion(classFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看如何来解析类注解</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/adaf37e07d60482988735a68183c405d.png" alt="image.png"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void read<span class="constructor">AndRegisterBeanDefintion(Set&lt;File&gt; <span class="params">classFiles</span>)</span> throws BeanDefinitionRegistException &#123;</span><br><span class="line">    <span class="keyword">for</span> (File classFile : classFiles) &#123;</span><br><span class="line">        String className = get<span class="constructor">ClassNameFromFile(<span class="params">classFile</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = this.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>.load<span class="constructor">Class(<span class="params">className</span>)</span>;</span><br><span class="line">            Component component = clazz.get<span class="constructor">Annotation(Component.<span class="params">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (component != null) &#123;<span class="comment">// 标注了@Component注解</span></span><br><span class="line">                String beanName = component.value<span class="literal">()</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">beanName</span>)</span>) &#123;</span><br><span class="line">                    beanName = this.generate<span class="constructor">BeanName(<span class="params">clazz</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                GenericBeanDefinition bd = <span class="keyword">new</span> <span class="constructor">GenericBeanDefinition()</span>;</span><br><span class="line">                bd.set<span class="constructor">BeanClass(<span class="params">clazz</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理Scope</span></span><br><span class="line">                Scope scope = clazz.get<span class="constructor">Annotation(Scope.<span class="params">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (scope != null) &#123;</span><br><span class="line">                    bd.set<span class="constructor">Scope(<span class="params">scope</span>.<span class="params">value</span>()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理primary</span></span><br><span class="line">                Primary primary = clazz.get<span class="constructor">Annotation(Primary.<span class="params">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (primary != null) &#123;</span><br><span class="line">                    bd.set<span class="constructor">Primary(<span class="params">true</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理构造方法，在构造方法上找@Autowired注解，如有，将这个构造方法set到bd;</span></span><br><span class="line">                this.handle<span class="constructor">Constructor(<span class="params">clazz</span>, <span class="params">bd</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理方法上的注解（找出初始化、销毁、工厂方法）</span></span><br><span class="line">                this.handle<span class="constructor">Method(<span class="params">clazz</span>, <span class="params">bd</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理属性依赖</span></span><br><span class="line">                this.handle<span class="constructor">PropertyDi(<span class="params">clazz</span>, <span class="params">bd</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册bean定义</span></span><br><span class="line">                this.registry.register<span class="constructor">BeanDefinition(<span class="params">beanName</span>, <span class="params">bd</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ApplicationContext"><a href="#3-ApplicationContext" class="headerlink" title="3.ApplicationContext"></a>3.ApplicationContext</h2><p>&emsp;&emsp;通过上面的设计，我们可以实现注解的方式来定义，但是给用户的整体体验还是不是很好，这时我们可以通过外观模式，为框架定义一个更简单的统一使用界面</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/f0aaa5abc9e5488c9b0f785e402ebb98.png" alt="image.png"></p><p>组合为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/8cdf22609c5e4af19b6399a46cb1dcbc.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-Bean定义配置化&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-Bean定义配置化&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-Bean定义配置化&quot;&gt;&lt;/a&gt;Spring源码手写篇-Bean定义配置化&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:21.702Z</published>
    <updated>2023-04-04T08:57:38.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-手写AOP"><a href="#Spring源码手写篇-手写AOP" class="headerlink" title="Spring源码手写篇-手写AOP"></a>Spring源码手写篇-手写AOP</h1><p>&emsp;&emsp;手写IoC和DI后已经实现的类图结构。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/f53bd24c0faa4eca911f742a9b94b9ce.png" alt="image.png"></p><h1 id="一、AOP分析"><a href="#一、AOP分析" class="headerlink" title="一、AOP分析"></a>一、AOP分析</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/8ca3b768d2f44ad19bc44eac019f362d.png" alt="image.png"></p><h2 id="1-AOP是什么"><a href="#1-AOP是什么" class="headerlink" title="1.AOP是什么?"></a>1.AOP是什么?</h2><p>&emsp;&emsp; AOP[Aspect Oriented Programming] 面向切面编程，在不改变类的代码的情况下，对类方法进行功能的增强。</p><h2 id="2-我们要做什么？"><a href="#2-我们要做什么？" class="headerlink" title="2.我们要做什么？"></a>2.我们要做什么？</h2><p>&emsp;&emsp;我们需要在前面手写IoC，手写DI的基础上给用户提供AOP功能，让他们可以通过AOP技术实现对类方法功能增强。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/674507e0830c43369642b767accba678.png" alt="image.png"></p><h2 id="3-我们的需求是什么？"><a href="#3-我们的需求是什么？" class="headerlink" title="3.我们的需求是什么？"></a>3.我们的需求是什么？</h2><p>&emsp;&emsp;提供AOP功能!,然后呢？… 没有了。关键还是得从上面的定义来理解。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/bc3ca3f0071c40a597a297e27d202289.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b0ebb450ee024684a2d619582763566b.png" alt="image.png"></p><h1 id="二、AOP概念讲解"><a href="#二、AOP概念讲解" class="headerlink" title="二、AOP概念讲解"></a>二、AOP概念讲解</h1><p>&emsp;&emsp;上面在分析AOP需求的时候，我们介绍到了相关的概念，Advice、Pointcuts和weaving等，首先我们来看看在AOP中我们会接触到的相关的概念都有哪些。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/13c2cf4ff1dd4482a0fcdfa6e3f91bfc.png" alt="image.png"></p><p>更加形象的描述</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/00653b5d08c34e6ea9f438eb2db17f87.png" alt="image.png"></p><p>然后对于上面的相关概念，我们就要考虑哪些是用户需要提供的，哪些是框架要写好的？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/43d865cfdc6c40048f321c5a741d7eaf.png" alt="image.png"></p><p>思考：Advice，Pointcuts和Weaving各自的特点</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/f40b002f19e2485cb875c52c948e7f0e.png" alt="image.png"></p><h1 id="三、切面实现"><a href="#三、切面实现" class="headerlink" title="三、切面实现"></a>三、切面实现</h1><p>&emsp;&emsp;通过上面的分析，我们要设计实现AOP功能，其实就是要设计实现上面分析的相关概念对应的组件。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/126439203e92420a9d755603a9701881.png" alt="image.png"></p><h2 id="1-Advice"><a href="#1-Advice" class="headerlink" title="1.Advice"></a>1.Advice</h2><h3 id="1-1-面向接口编程"><a href="#1-1-面向接口编程" class="headerlink" title="1.1 面向接口编程"></a>1.1 面向接口编程</h3><p>&emsp;&emsp;Advice:通知，是由用户提供的，我们来使用，主要是用户提供就突出了 <code>多变性</code>。针对这块我们应该怎么设计?这里有两个问题:</p><ol><li>我们如何能够识别用户提供的东西呢?用户在我们写好框架后使用我们的框架</li><li>如何让我们的代码隔绝用户提供的多变性呢?</li></ol><p>针对这种情况我们定义一套标准的接口，用户通过实现接口类提供他们不同的逻辑。是否可行?<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/904bde3bf689418c984ffe125aa165a9.png" alt="image.png"></p><p>这里有个重要的设计原则大家要注意: 如何应对变化，通过面向接口编程来搞定!!!</p><p>我们先定义一个空的接口,可以先思考下我们为什么定义一个空的接口呢?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/7da55a1150cb487d8d1cfdec90624813.png" alt="image.png"></p><h3 id="1-2-Advice的特点分析"><a href="#1-2-Advice的特点分析" class="headerlink" title="1.2 Advice的特点分析"></a>1.2 Advice的特点分析</h3><p>&emsp;&emsp;Advice的特点：可选时机，可选择在方法执行前、后、异常时进行功能的增强</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6ba22d8fd7424bf79d69fae54dd8a9de.png" alt="image.png"></p><p>结合上面的情况我们可以分析出Advice通知的几种情况</p><ul><li>前置增强-Before</li><li>后置增强-AfterReturn</li><li>环绕增强-Around</li><li>最终通知-After</li><li>异常通知-Throwing</li></ul><p>有这么多的情况我们应该要怎么来实现呢?我们可以定义标准的接口方法，让用户来实现它，提供各种具体的增强内容。那么这四种增强相关的方法定义是怎样的呢？我们一一来分析下。</p><h3 id="1-3-各种通知分析"><a href="#1-3-各种通知分析" class="headerlink" title="1.3 各种通知分析"></a>1.3 各种通知分析</h3><h4 id="1-3-1-前置增强"><a href="#1-3-1-前置增强" class="headerlink" title="1.3.1 前置增强"></a>1.3.1 前置增强</h4><p><strong>前置增强</strong>：在方法执行前进行增强。</p><p>问题1：它可能需要的参数?</p><p>&emsp;&emsp;目的是对方法进行增强，应该需要的是方法相关的信息，我们使用它的时候能给如它的就是当前要执行方法的相关信息了</p><p>问题2:运行时方法有哪些信息?</p><ol><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li></ol><p>问题3:前置增强的返回值是什么?</p><p>&emsp;&emsp;在方法执行前进行增强，不需要返回值!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法进行前置增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            被增强的目标对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-最终通知"><a href="#1-3-2-最终通知" class="headerlink" title="1.3.2 最终通知"></a>1.3.2 最终通知</h4><p>&emsp;&emsp;最终通知：在方法执行后进行增强</p><p>问题1:它可能需要的参数?</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li><li>方法的返回值 Object 可能没有</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法，提供后置增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue</span></span><br><span class="line"><span class="comment"> *            返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法的所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-后置通知"><a href="#1-3-3-后置通知" class="headerlink" title="1.3.3 后置通知"></a>1.3.3 后置通知</h4><p>&emsp;&emsp;后置增强：在方法执行后进行增强</p><p>问题1:他可能需要的参数</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li><li>方法的返回值 Object</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法，提供AfterRetun增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue</span></span><br><span class="line"><span class="comment"> *            返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法的所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-环绕通知"><a href="#1-3-4-环绕通知" class="headerlink" title="1.3.4 环绕通知"></a>1.3.4 环绕通知</h4><p>Around环绕增强：包裹方法进行增强</p><p>问题1:他可能需要的参数</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li></ul><p>问题2:它的返回值是面试?</p><p>&emsp;&emsp;方法被它包裹，即方法将由它来执行，它需要返回方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对方法进行环绕（前置、后置）增强、异常处理增强，方法实现中需调用目标方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Object 返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-异常通知"><a href="#1-3-5-异常通知" class="headerlink" title="1.3.5 异常通知"></a>1.3.5 异常通知</h4><p>异常通知增强：对方法执行时的异常，进行增强处理</p><p>问题1：它可能需要什么参数?</p><ul><li>一定需要Exception</li><li>可能需要方法本身 Method</li><li>可能需要方法所属的对象 Object</li><li>可能需要方法的参数 Object[]</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Exception ex)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Advice设计"><a href="#1-4-Advice设计" class="headerlink" title="1.4 Advice设计"></a>1.4 Advice设计</h3><p>&emsp;&emsp;结合上面的分析，我们就可以得出Advice的体系图了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/79db7010cc1f48a9a7d7c962bfc2a59f.png" alt="image.png"></p><h2 id="2-Pointcut"><a href="#2-Pointcut" class="headerlink" title="2.Pointcut"></a>2.Pointcut</h2><h3 id="2-1-Pointcut的特点有："><a href="#2-1-Pointcut的特点有：" class="headerlink" title="2.1 Pointcut的特点有："></a>2.1 Pointcut的特点有：</h3><ul><li>用户性：由用户指定</li><li>变化性：用户可灵活指定</li><li>多点性：用户可以选择在多个点上进行增强</li></ul><h3 id="2-2-Pointcut分析"><a href="#2-2-Pointcut分析" class="headerlink" title="2.2 Pointcut分析"></a>2.2 Pointcut分析</h3><p>&emsp;&emsp;为用户提供一个东西，让他们可以灵活地指定多个方法点，而且我们还能看懂!</p><p>思考：切入点是由用户来指定在哪些方法点上进行增强，那么这个哪些方法点如何来表示能满足上面的需求呢?</p><p>分析：</p><ol><li>指定哪些方法，是不是一个描述信息?</li><li>如何来指定一个方法?</li><li>如果有重载的情况怎么办?</li><li>123要求的其实就是一个完整的方法签名</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.boge.spring.aop.Girl.dbj(Boy,Time)</span><br><span class="line"></span><br><span class="line">com.boge.spring.aop.Girl.dbj(Boy,Girl,Time)</span><br></pre></td></tr></table></figure><p>我们还得进一步分析：如何做到多点性和灵活性，在一个描述中指定一类类的某些方法?</p><ul><li>某个包下的某个类的某个方法</li><li>某个包下的所有类中的所有方法</li><li>某个包下的所有类中的do开头的方法</li><li>某个包下的以service结尾的类中的do开头的方法</li><li>…..</li></ul><p>也就是我们需要有这样一个表达式能够灵活的描述上面的这些信息。</p><p>这个表达式表达的内容有：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d7283c3a93034785b0654137d01f782f.png" alt="image.png"></p><p>而且每个部分的要求是怎么样的呢？</p><ul><li>包名：有父子特点，要能模糊匹配</li><li>类名：要能模糊匹配</li><li>方法名:要能模糊匹配</li><li>参数类型：参数可以有多个</li></ul><p>那么我们设计的这个表达式将被我们用来决定是否需要对某个类的某个方法进行增强，这个决定过程应该是怎么样的？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/c916c51a3ca84a11b5de3f723ad30e35.png" alt="image.png"></p><p>针对需求我们的选择是：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/1b737a0982684f45b6ceb1345ed06a09.png" alt="image.png"></p><p>AspectJ官网：<a href="http://www.eclipse.org/aspectj">http://www.eclipse.org/aspectj</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6ee3a6aceb064424859144f423b2c058.png" alt="image.png"></p><p>切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名。注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/78122d7454a3467595da80fa0e0a9901.png" alt="image.png"></p><p>举例：</p><blockquote><p>execution(public <em> </em>(. .))<br>指定切入点为：任意公共方法。<br>execution(<em> set </em>(. .))<br>指定切入点为：任何一个以“set”开始的方法。<br>execution(<em> com.xyz.service.</em>.<em>(. .))<br>指定切入点为：定义在service包里的任意类的任意方法。<br>execution(</em> com.xyz.service. .<em>.</em>(. .))<br>指定切入点为：定义在service包或者子包里的任意类的任意方法。“..”出现在类名中时，<br>后面必须跟“<em>”，表示包、子包下的所有类。<br>execution(</em> <em>.service.</em>.<em>(. .))<br>指定只有一级包下的serivce子包下所有类(接口)中的所有方法为切入点<br>execution(</em> <em>. .service.</em>.*(. .))<br>指定所有包下的serivce子包下所有类(接口)中的所有方法为切入点</p></blockquote><h3 id="2-3-Pointcut设计"><a href="#2-3-Pointcut设计" class="headerlink" title="2.3 Pointcut设计"></a>2.3 Pointcut设计</h3><p>&emsp;&emsp;通过分析完成我们就该对Pointcut类设计了，接口，类。</p><p>思考1：首先考虑切入点应该具有的属性—-&gt;切入点表达式</p><p>思考2：切入点应对外提供什么行为</p><p>思考3：切入点被我们设计用来做什么？</p><p>&emsp;&emsp;对类和方法进行匹配，切入点应该提供匹配类，匹配方法的行为</p><p>思考4：如果在我们设计的框架中要能灵活的扩展切点，我们应该如何设计?</p><p>&emsp;&emsp;这又是一个要支持可多变的问题，像通知一样，我们定义一套标准接口，定义好基本行为，面向接口编程，屏蔽掉具体的实现。不管哪些方案，都实现匹配类，匹配方法的接口。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d6d11358de0143d1858561c4982b2c76.png" alt="image.png"></p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matchsClass</span><span class="params">(Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matchsMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来看看AspectJ的实现</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/55d3515a737640948fff96dc0e7cf136.png" alt="image.png"></p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">PointcutParser</span> <span class="variable">pp</span> <span class="operator">=</span> PointcutParser</span><br><span class="line">.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String expression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PointcutExpression pe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AspectJExpressionPointcut</span><span class="params">(String expression)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.expression = expression;</span><br><span class="line">pe = pp.parsePointcutExpression(expression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchsClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pe.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchsMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"><span class="type">ShadowMatch</span> <span class="variable">sm</span> <span class="operator">=</span> pe.matchesMethodExecution(method);</span><br><span class="line"><span class="keyword">return</span> sm.alwaysMatches();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getExpression</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-切面Aspect"><a href="#3-切面Aspect" class="headerlink" title="3.切面Aspect"></a>3.切面Aspect</h2><p>搞定了两个难点后，我们来看看用户该如何使用我们提供的东西</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b752948842cc48f8b3239aedd773eaca.png" alt="image.png"></p><p>为此我们需要创建对应的接口来管理。</p><h2 id="4-Advisor"><a href="#4-Advisor" class="headerlink" title="4. Advisor"></a>4. Advisor</h2><p>为用户提供更简单的外观，Advisor(通知者)组合Advice和Pointcut。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d0e7073bbf364748b4c8e55aab2e05b8.png" alt="image.png"></p><p>当然扩展的形式比较多：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/5e93b8fa9b4447f1b6f50a206b3b71e2.png" alt="image.png"></p><p>或者：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/671e360c737c4c8fb99c1dfe1fca7adb.png" alt="image.png"></p><h1 id="四、织入实现"><a href="#四、织入实现" class="headerlink" title="四、织入实现"></a>四、织入实现</h1><h2 id="1-织入的分析"><a href="#1-织入的分析" class="headerlink" title="1. 织入的分析"></a>1. 织入的分析</h2><p>&emsp;&emsp;织入要完成的是什么？织入其实就是要把用户提供的增强功能加到指定的方法上。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/952c32f23a444853896716f09d16c52e.png" alt="image.png"></p><p>思考1：在什么时候织入?</p><p>&emsp;&emsp;创建Bean实例的时候，在Bean初始化后，再对其进行增强。</p><p>思考2：如何确定bean要增强?</p><p>&emsp;&emsp;对bean类及方法挨个匹配用户配置的切面，如果有切面匹配就是要增强</p><p>思考3：如何实现织入？</p><p>&emsp;&emsp;代理方式</p><h2 id="2-织入的设计"><a href="#2-织入的设计" class="headerlink" title="2.织入的设计"></a>2.织入的设计</h2><p>&emsp;&emsp;为了更好的去设计织入的实现，先整理下AOP的使用流程。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/dac91a0adea34886956c1424d300a3a1.png" alt="image.png"></p><p>这里我们要考虑匹配、织入逻辑写到哪里？是写在BeanFactory中吗?</p><p>这时我们要考虑如果我们直接在BeanFactory中来处理，后续如果还有其他的需求是不是也要在BeanFactory中处理呢？这样操作有什么不好的地方呢？</p><ul><li>BeanFactory代码爆炸，不专情</li><li>不易扩展</li></ul><p>那我们应该要怎么来设计呢？</p><p>我们先来回顾下Bean的生产的过程</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6903c3b4a15e4b0dbd98444ce8402bf6.png" alt="image.png"></p><p>在这个过程中， 将来会有更多处理逻辑加入到Bean生产过程的不同阶段。我们现在最好是设计出能让我们后面不用再改BeanFactory的代码就能灵活的扩展。</p><p>这时我们可以考虑用观察者模式，通过在各个节点加入扩展点，加入注册机制。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/182e76a403594d458fdbcfa7116f7793.png" alt="image.png"></p><p>那么在这块我们就应用观察者模式来加入一个Bean的后置处理器 BeanPostProcessor</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/813c7b7bc10e4cdba9eec41196f8d34d.png" alt="image.png"></p><p>具体的我们在代码中来看看。</p><h2 id="3-织入的实现"><a href="#3-织入的实现" class="headerlink" title="3.织入的实现"></a>3.织入的实现</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h3><p>&emsp;&emsp;我们先定义了 BeanPostProcessor 接口，在这个接口中我们定义了相关的行为，也就是初始化之前和初始化之后要执行的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/20be9e28bbae4297b51f1005d669052b.png" alt="image.png"></p><p>&emsp;&emsp;那么在此处我们需要在BeanFactory对创建的Bean对象做初始化前后要校验是否需要做相关的增强操作。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/cfc12fead081451c91c21289be333683.png" alt="image.png"></p><p>&emsp;&emsp;在BeanFactory中我们提供了BeanPostProcessor的注册方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d896894ce3d440879c6d0bcc1d521464.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/63797779f9bd4708910530fea1ad8909.png" alt="image.png"></p><p>那么结合BeanFactory要实现相关的Bean增强操作，我们要做的行为就是两方面</p><ol><li>创建相关的BeanPostProcessor，并注册到BeanFactory中</li><li>BeanFactory在初始化Bean前后判断是否有相关BeanPostProcessor，如果有做相关的增强处理</li></ol><p>&emsp;&emsp;有了上面的分析，那么我们要实现具体的织入就需要来看看在对应前置和后置方法中我们要实现的功能</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/9cfb5bbbd27b46fea5ae9e29d8ddd3b0.png" alt="image.png"></p><h3 id="3-2-判断是否需要增强"><a href="#3-2-判断是否需要增强" class="headerlink" title="3.2 判断是否需要增强"></a>3.2 判断是否需要增强</h3><p>&emsp;&emsp;我们如何判断Bean对象是否需要增强呢？其实就是需要判断该Bean是否满足用户定义的切入点表达式。也就是我们需要简单Bean所属的类和所有方法。然后遍历Advisor。取出advisor中的Pointcut来匹配类和方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/1e014b3ad0da491ab945fb96eca99f42.png" alt="image.png"></p><p>代码层面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*逻辑</span></span><br><span class="line"><span class="comment">1 判断Bean是否需要增强</span></span><br><span class="line"><span class="comment">2 创建代理来实现增强</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1 判断Bean是否需要增强</span></span><br><span class="line">      List&lt;Advisor&gt; matchAdvisors = getMatchedAdvisors(bean, beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2如有切面切中，创建代理来实现增强</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(matchAdvisors)) &#123;</span><br><span class="line">bean = <span class="built_in">this</span>.createProxy(bean, beanName, matchAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6588199bad1b4b5abd0223873a3893e0.png" alt="image.png"></p><h3 id="3-3-代理对象"><a href="#3-3-代理对象" class="headerlink" title="3.3 代理对象"></a>3.3 代理对象</h3><p>&emsp;&emsp;通过上面的分析如果Bean需要被增强，那么我们就需要创建Bean对应的代理对象了。代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在调用者和目标对象之间起到中介的作用；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3dc8e273c627417994e2827d558b6cf4.png" alt="image.png"></p><p>&emsp;&emsp;动态代理的实现方法有哪些?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/85ef8dd3afd943348c9962fa9268e1f4.png" alt="image.png"></p><p>JDK动态代理：</p><p>在运行时，对接口创建代理对象</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b853feeac2564e0eb56986c3fa71878a.png" alt="image.png"></p><p>cglib动态代理：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6022f31f8e0a4970811a62905d89d915.png" alt="image.png"></p><h3 id="3-4-代理实现层设计"><a href="#3-4-代理实现层设计" class="headerlink" title="3.4 代理实现层设计"></a>3.4 代理实现层设计</h3><p>&emsp;&emsp;动态代理的实现方式有很多种，如何能够做到灵活的扩展呢？在这里我们同样可以通过 <code>抽象</code>和 <code>面向接口编程</code>来设计一套支持不同代理实现的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b78eebb9e57a454e99dcb19191a3c786.png" alt="image.png"></p><p>&emsp;&emsp;有了上面的设计，然后就是需要考虑代理对象的创建了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/9aaf36179e6b42c4983c3f19cee46e0d.png" alt="image.png"></p><h3 id="3-5-增强逻辑实现"><a href="#3-5-增强逻辑实现" class="headerlink" title="3.5 增强逻辑实现"></a>3.5 增强逻辑实现</h3><p>&emsp;&emsp;代理对象搞定后我们需要考虑核心的问题就是怎么来实现我们要增强的逻辑呢？首先不管你用哪种方式来生成代理对象最终增强的逻辑代码是一样的。所以我们可以把这部分内容提炼出来。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3db0692f12a04b769c29616860be66a5.png" alt="image.png"></p><p>&emsp;&emsp;然后具体的应用Advice增强实现的逻辑为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/4055fce775164b0497385de84ca2cd05.png" alt="image.png"></p><p>注意此处用到了责任链模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">applyAdvices</span><span class="params">(Object target, Method method, Object[] args, List&lt;Advisor&gt; matchAdvisors,</span></span><br><span class="line"><span class="params">Object proxy, BeanFactory beanFactory)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 这里要做什么？   需要获取相关案例代码的+V：boge3306 备注:手写Spring</span></span><br><span class="line"><span class="comment">// 1、获取要对当前方法进行增强的advice</span></span><br><span class="line">List&lt;Object&gt; advices = AopProxyUtils.getShouldApplyAdvices(target.getClass(), method, matchAdvisors,</span><br><span class="line">beanFactory);</span><br><span class="line"><span class="comment">// 2、如有增强的advice，责任链式增强执行</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(advices)) &#123;</span><br><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 责任链式执行增强</span></span><br><span class="line"><span class="type">AopAdviceChainInvocation</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AopAdviceChainInvocation</span>(proxy, target, method, args, advices);</span><br><span class="line"><span class="keyword">return</span> chain.invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们前面的Creator要怎么使用AopProxy呢？这块我们可以通过工厂模式来处理</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3d68ad51c8834af6afa97f28cf482ac1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">AopProxy <span class="title function_">createAopProxy</span><span class="params">(Object bean, String beanName, List&lt;Advisor&gt; matchAdvisors, BeanFactory beanFactory)</span></span><br><span class="line"><span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得默认的AopProxyFactory实例</span></span><br><span class="line"><span class="comment"> *    需要获取相关案例代码的+V：boge3306 备注:手写Spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> AopProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> AopProxyFactory <span class="title function_">getDefaultAopProxyFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAopProxyFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这儿，完整的增强逻辑就梳理通了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-手写AOP&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-手写AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-手写AOP&quot;&gt;&lt;/a&gt;Spring源码手写篇-手写AOP&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;ems</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:18.977Z</published>
    <updated>2023-04-04T08:57:38.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-手写DI"><a href="#Spring源码手写篇-手写DI" class="headerlink" title="Spring源码手写篇-手写DI"></a>Spring源码手写篇-手写DI</h1><p>&emsp;&emsp;简单回顾前面的手写IoC的内容。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/2ff7d10e3c694d35a5a5643826198a44.png" alt="image.png"></p><h1 id="一、DI介绍"><a href="#一、DI介绍" class="headerlink" title="一、DI介绍"></a>一、DI介绍</h1><p>&emsp;&emsp;DI(Dependency injection)依赖注入。对象之间的依赖由容器在运行期决定，即容器动态的将某个依赖注入到对象之中。说的直白点就是给Bean对象的成员变量赋值。</p><p>&emsp;&emsp;在这里我们就需要明白几个问题。</p><h2 id="1-哪些地方会有依赖"><a href="#1-哪些地方会有依赖" class="headerlink" title="1. 哪些地方会有依赖"></a>1. 哪些地方会有依赖</h2><ul><li>构造参数依赖</li><li>属性依赖</li></ul><h2 id="2-依赖注入的本质是什么？"><a href="#2-依赖注入的本质是什么？" class="headerlink" title="2. 依赖注入的本质是什么？"></a>2. 依赖注入的本质是什么？</h2><p>&emsp;&emsp;依赖注入的本质是 <code>赋值</code>。赋值有两种情况</p><ol><li>给有参构造方法赋值</li><li>给属性赋值</li></ol><h2 id="3-参数值、属性值有哪些？"><a href="#3-参数值、属性值有哪些？" class="headerlink" title="3. 参数值、属性值有哪些？"></a>3. 参数值、属性值有哪些？</h2><p>&emsp;&emsp;具体赋值有两种情况：直接值和Bean依赖。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> clsss Girl&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">char</span> cup,Boy boyfriend)</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-直接赋值有哪些？"><a href="#4-直接赋值有哪些？" class="headerlink" title="4.  直接赋值有哪些？"></a>4.  直接赋值有哪些？</h2><ul><li>基本数据类型：String、int 等</li><li>数组，集合</li><li>map</li></ul><h1 id="二、构造注入"><a href="#二、构造注入" class="headerlink" title="二、构造注入"></a>二、构造注入</h1><p>&emsp;&emsp;我们先来看看构造参数注入的情况应该要如何解决。</p><h2 id="1-构造注入分析"><a href="#1-构造注入分析" class="headerlink" title="1.构造注入分析"></a>1.构造注入分析</h2><p>&emsp;&emsp;我们应该如何定义构造参数的依赖？也就是我们需要通过构造方法来创建实例，然后对应的构造方法我们需要传入对应的参数。如果不是通过IoC来处理，我们可以直接通过如下的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;小丽&quot;</span>,<span class="number">20</span>,<span class="string">&#x27;C&#x27;</span>,boy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过直接赋值的方式就可以了。但是在IoC中我们需要通过反射的方式来处理。那么我们在通过反射操作的时候就需要能获取到对应的构造参数的依赖了，这时我们得分析怎么来存储我们的构造参数的依赖了。构造参数的依赖有两个特点：</p><ul><li>数量</li><li>顺序</li></ul><p>&emsp;&emsp;上面的例子中的参数</p><ol><li>小丽</li><li>20</li><li>‘C’</li><li>boy,是一个依赖Bean</li></ol><p>&emsp;&emsp;参数可以有多个，我们完全可以通过List集合来存储，而且通过添加数据的顺序来决定构造参数的顺序了。但是这里有一个问题，如何表示Bean依赖呢？直接值我们直接添加到集合中就可以了，但是Bean依赖，我们还没有创建对应的对象，这时我们可以维护一个自定义对象，来绑定相关的关系。</p><h2 id="2-BeanReference"><a href="#2-BeanReference" class="headerlink" title="2. BeanReference"></a>2. BeanReference</h2><p>&emsp;&emsp;BeanReference就是用来说明bean依赖的：也就是这个属性依赖哪个类型的Bean</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/446cfe8bf3d8430aa0453b7bac9ce761.png" alt="image.png"></p><p>&emsp;&emsp;可以根据name来依赖，也可以按照Type来依赖。当然我们的程序中还有一点需要考虑，就是如何来区分是直接值还是Bean依赖呢？有了上面的设计其实就很容易判断了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( obj instance BeanReference)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然还有一种比较复杂的情况如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/0f3a742092ff4d3ab8dad9c93971befc.png" alt="image.png"></p><p>&emsp;&emsp;直接值是数组或者集合等，同时容器中的元素是Bean依赖，针对这种情况元素值还是需要用BeanReference来处理的。Bean工厂在处理时需要遍历替换。</p><h2 id="3-BeanDefinition实现"><a href="#3-BeanDefinition实现" class="headerlink" title="3. BeanDefinition实现"></a>3. BeanDefinition实现</h2><p>&emsp;&emsp;接下来我们看看如何具体的来实现DI基于构造参数依赖的相关操作。首先是定义的相关处理了。我们需要在 <code>BeanDefinition</code>中增加构造参数的获取的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/35d2d357b2834371a1e61ec65a30de64.png" alt="image.png"></p><p>&emsp;&emsp;然后我们需要在默认的实现GenericBeanDefinition中增加对应的方法来处理。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/9ae87b696cd247178bb994c416022445.png" alt="image.png"></p><p>&emsp;&emsp;定义后我们可以测试下对应的应用，定义个ABean，依赖了CBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABean</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CBean cb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(String name, CBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了含有CBean参数的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(String name, CCBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了含有CCBean参数的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(CBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomthing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Abean.doSomthing(): &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; cb.name=&quot;</span> + <span class="built_in">this</span>.cb.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ABean.init() 执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ABean.destroy() 执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在实例化时我们需要做相关的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">bd.setBeanClass(ABean.class);</span><br><span class="line"><span class="comment">// 定义的构造参数的依赖</span></span><br><span class="line">List&lt;Object&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">args.add(<span class="string">&quot;abean01&quot;</span>);</span><br><span class="line"><span class="comment">// Bean依赖 通过BeanReference 来处理</span></span><br><span class="line">args.add(<span class="keyword">new</span> <span class="title class_">BeanReference</span>(<span class="string">&quot;cbean&quot;</span>));</span><br><span class="line">bd.setConstructorArgumentValues(args);</span><br><span class="line">bf.registerBeanDefinition(<span class="string">&quot;abean&quot;</span>, bd);</span><br></pre></td></tr></table></figure><p>构造参数传递后，接下来其实我们就需要要在 <code>BeanFactory</code>中来实现构造参数的注入了</p><h2 id="4-BeanFactory实现"><a href="#4-BeanFactory实现" class="headerlink" title="4.BeanFactory实现"></a>4.BeanFactory实现</h2><p>&emsp;&emsp;前面我们在BeanFactory中实现Bean对象的创建有几种方式</p><ul><li>构造方法创建</li><li>工厂静态方法</li><li>工厂成员方法</li></ul><p>&emsp;&emsp;我们在通过构造方法创建其实是通过无参构造方法来处理的，这时我们需要改变这块的逻辑，通过有参构造方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByConstructor</span><span class="params">(BeanDefinition bd)</span></span><br><span class="line"><span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bd.getBeanClass().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e1) &#123;</span><br><span class="line">log.error(<span class="string">&quot;创建bean的实例异常,beanDefinition：&quot;</span> + bd, e1);</span><br><span class="line"><span class="keyword">throw</span> e1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们就需要对上面的方法做出改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByConstructor</span><span class="params">(BeanDefinition bd)</span></span><br><span class="line"><span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">       <span class="comment">// 1. 得到真正的参数值</span></span><br><span class="line">List&lt;?&gt; constructorArgumentValues = bd.getConstructorArgumentValues(); </span><br><span class="line">       <span class="comment">// 2.根据对应的构造参数依赖获取到对应的 Constructor </span></span><br><span class="line">       <span class="type">Constructor</span>  <span class="variable">constructor</span> <span class="operator">=</span> 得到对应的构造方法</span><br><span class="line">       <span class="comment">// 3.用实际参数值调用构造方法创建对应的对象</span></span><br><span class="line">       <span class="keyword">return</span> constructor.newInstance(Object ... 实参值); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的分析我们需要获取对应的构造器。这块我们需要通过反射来获取了。下面是具体的实现逻辑</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/7a6313aa1834481b9335c5759677363b.png" alt="image.png"></p><p>&emsp;&emsp;根据上面的分析，我们实现的逻辑分为两步</p><ol><li>先根据参数的类型进行精确匹配查找，如果没有找到，继续执行第二步操作</li><li>获得所有的构造方法，遍历构造方法，通过参数数量过滤，再比对形参与实参的类型</li></ol><p>&emsp;&emsp;因为这里有个情况，实参是Boy，构造方法的形参是Person，第一种精确匹配就没有办法关联了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/4a045636aa6147a6a72f42bedcf2c312.png" alt="image.png"></p><p>具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; determineConstructor(BeanDefinition bd, Object[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*判定构造方法的逻辑应是怎样的？</span></span><br><span class="line"><span class="comment">    1 先根据参数的类型进行精确匹配查找，如未找到，则进行第2步查找；</span></span><br><span class="line"><span class="comment">    2获得所有的构造方法，遍历，通过参数数量过滤，再比对形参类型与实参类型。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; ct = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有参数，则用无参构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bd.getBeanClass().getConstructor(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 先根据参数的类型进行精确匹配查找</span></span><br><span class="line">    Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[args.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object p : args) &#123;</span><br><span class="line">        paramTypes[j++] = p.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ct = bd.getBeanClass().getConstructor(paramTypes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 这个异常不需要处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2 没有精确参数类型匹配的，获得所有的构造方法，遍历，通过参数数量过滤，再比对形参类型与实参类型。</span></span><br><span class="line">        <span class="comment">// 判断逻辑：先判断参数数量，再依次比对形参类型与实参类型</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; ct0 : bd.getBeanClass().getConstructors()) &#123;</span><br><span class="line">            Class&lt;?&gt;[] paramterTypes = ct0.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (paramterTypes.length == args.length) &#123;   <span class="comment">//通过参数数量过滤</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramterTypes.length; i++) &#123; <span class="comment">//再依次比对形参类型与实参类型是否匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (!paramterTypes[i].isAssignableFrom(args[i].getClass())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span> outer; <span class="comment">//参数类型不可赋值（不匹配），跳到外层循环，继续下一个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ct = ct0;  <span class="comment">//匹配上了</span></span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ct;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;不存在对应的构造方法！&quot;</span> + bd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们考虑的是BeanFactory通过构造器来获取对象的逻辑，那如果我们是通过静态工厂方法或者成员工厂方法的方式来处理的，那么构造参数依赖的处理是否和前面的是一样的呢？其实是差不多的，我们需要根据对应的构造参数来推断对应的工厂方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态工厂方法</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByStaticFactoryMethod</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    Object[] realArgs = <span class="built_in">this</span>.getConstructorArgumentValues(bd);</span><br><span class="line">    Class&lt;?&gt; type = bd.getBeanClass();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.determineFactoryMethod(bd, realArgs, type);</span><br><span class="line">    <span class="keyword">return</span> m.invoke(type, realArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂bean方式来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByFactoryBean</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    Object[] realArgs = <span class="built_in">this</span>.getConstructorArgumentValues(bd);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.determineFactoryMethod(bd, realArgs, <span class="built_in">this</span>.getType(bd.getFactoryBeanName()));</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="built_in">this</span>.doGetBean(bd.getFactoryBeanName());</span><br><span class="line">    <span class="keyword">return</span> m.invoke(factoryBean, realArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-缓存功能"><a href="#5-缓存功能" class="headerlink" title="5.缓存功能"></a>5.缓存功能</h2><p>&emsp;&emsp;对于上面的处理过程相信大家应该清楚了，我们通过推断也得到了对应的构造方法或者对应的工厂方法，那么我们可以不可以在下次需要再次获取的时候省略掉推导的过程呢？显然我们可以在BeanDefinition中增加缓存方法可以实现这个需求。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/f57d7f7cf8dc47cfb7a95e09bc26afb0.png" alt="image.png"></p><h2 id="6-循环依赖问题"><a href="#6-循环依赖问题" class="headerlink" title="6. 循环依赖问题"></a>6. 循环依赖问题</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/8a8ff504fe7a43b3a7d0e16d06917211.png" alt="image.png"></p><p>&emsp;&emsp;上图是循环依赖的三种情况，虽然方式有点不一样，但是循环依赖的本质是一样的，就你的完整创建要依赖与我，我的完整创建也依赖于你。相互依赖从而没法完整创建造成失败。</p><p>&emsp;&emsp;我们通过构造参数依赖是完全可能出现上面的情况的，那么这种情况我们能解决吗？构造依赖的情况我们是解决不了的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestService1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestService1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TestService2</span> <span class="variable">testService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestService2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestService2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">TestService1</span> <span class="variable">testService1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestService1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然解决不了，那么我们在程序中如果出现了，应该要怎么来解决呢？其实我们可以在创建一个Bean的时候记录下这个Bean，当这个Bean创建完成后我们在移除这个Bean，然后我们在getBean的时候判断记录中是否有该Bean，如果有就判断为循环依赖，并抛出异常。数据结构我们可以通过Set集合来处理。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/a3b95f3dfbca49ee8ff576908a30e2dd.png" alt="image.png"></p><p>到此构造注入的实现我们就搞定了。</p><h1 id="三、属性注入"><a href="#三、属性注入" class="headerlink" title="三、属性注入"></a>三、属性注入</h1><p>&emsp;&emsp;上面搞定了构造注入的方式。接下来我们再看看属性注入的方式有什么需要注意的地方。</p><h2 id="1-属性依赖分析"><a href="#1-属性依赖分析" class="headerlink" title="1. 属性依赖分析"></a>1. 属性依赖分析</h2><p>&emsp;&emsp;属性依赖就是某个属性依赖某个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cup;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Boy&gt; boyFriends;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在获取实例对象后如何根据相关的配置来给对应的属性来赋值呢？这时我们可以定义一个实体类 <code>PropertyValue</code>来记录相关的属性和值。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/9bd0d13f60344e41b20e45cec45dcb24.png" alt="image.png"></p><h2 id="2-BeanDefinition实现"><a href="#2-BeanDefinition实现" class="headerlink" title="2.BeanDefinition实现"></a>2.BeanDefinition实现</h2><p>&emsp;&emsp;这时我们就需要在BeanDefinition中关联相关属性信息了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/6f9341b7eb264f0399e8d6add384d081.png" alt="image.png"></p><h2 id="3-BeanFactory实现"><a href="#3-BeanFactory实现" class="headerlink" title="3.BeanFactory实现"></a>3.BeanFactory实现</h2><p>&emsp;&emsp;然后我们在BeanFactory的默认实现DefaultBeanFactory中实现属性值的依赖注入。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建好实例对象</span></span><br><span class="line"><span class="comment">// 给属性依赖赋值</span></span><br><span class="line">this.set<span class="constructor">PropertyDIValues(<span class="params">bd</span>,<span class="params">instance</span>)</span>;</span><br><span class="line"><span class="comment">// 执行初始化相关方法</span></span><br><span class="line">this.<span class="keyword">do</span><span class="constructor">Init(<span class="params">bd</span>,<span class="params">instance</span>)</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给入属性依赖</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPropertyDIValues</span><span class="params">(BeanDefinition bd, Object instance)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(bd.getPropertyValues())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : bd.getPropertyValues()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(pv.getName())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = instance.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">p</span> <span class="operator">=</span> clazz.getDeclaredField(pv.getName());</span><br><span class="line">        <span class="comment">//暴力访问  private</span></span><br><span class="line">        p.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        p.set(instance, <span class="built_in">this</span>.getOneArgumentRealValue(pv.getValue()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-循环依赖问题"><a href="#4-循环依赖问题" class="headerlink" title="4.循环依赖问题"></a>4.循环依赖问题</h2><p>&emsp;&emsp;在构造参数依赖中我们发现没有办法解决，在属性依赖中同样会存在循环依赖的问题，这时我们能解决吗？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/f33309e8d2784205b86197b344f02512.png" alt="image.png"></p><p>&emsp;&emsp;其实这种情况我们不在IoC场景下非常好解决。如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boy b = <span class="keyword">new</span> <span class="constructor">Boy()</span>;</span><br><span class="line">Girl g = <span class="keyword">new</span> <span class="constructor">Girl()</span>;</span><br><span class="line">b.set<span class="constructor">Girl(<span class="params">g</span>)</span>;</span><br><span class="line">g.set<span class="constructor">Boy(<span class="params">b</span>)</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是在IoC好像不是太好解决：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/7dbe9a7686d34038b76f9a64e4e1b765.png" alt="image.png"></p><p>&emsp;&emsp;针对这种情况我们需要通过 <code>提前暴露</code>来解决这个问题，具体看代码!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doEarlyExposeBuildingBeans</span><span class="params">(String beanName, Object instance)</span> &#123;</span><br><span class="line">    Map&lt;String,Object&gt; earlyExposeBuildingBeansMap = earlyExposeBuildingBeans.get();</span><br><span class="line">    <span class="keyword">if</span>(earlyExposeBuildingBeansMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        earlyExposeBuildingBeansMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        earlyExposeBuildingBeans.set(earlyExposeBuildingBeansMap);</span><br><span class="line">    &#125;</span><br><span class="line">    earlyExposeBuildingBeansMap.put(beanName,instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后现阶段已经实现的类图结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/6122a088f15f455993b9dff1113bd255.png" alt="image.png"></p><p>扩展作业：加入Bean配置的条件依赖生效的支持</p><p>在Bean定义配置中可以指定它条件依赖某些Bean或类，当这些Bean或类存在时，这个bean的配置才能生效!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-手写DI&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-手写DI&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-手写DI&quot;&gt;&lt;/a&gt;Spring源码手写篇-手写DI&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;简单</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:17.698Z</published>
    <updated>2023-04-04T08:57:38.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手写篇-手写IoC"><a href="#手写篇-手写IoC" class="headerlink" title="手写篇-手写IoC"></a>手写篇-手写IoC</h1><h1 id="一、IoC分析"><a href="#一、IoC分析" class="headerlink" title="一、IoC分析"></a>一、IoC分析</h1><h2 id="1-Spring的核心"><a href="#1-Spring的核心" class="headerlink" title="1.Spring的核心"></a>1.Spring的核心</h2><p>&emsp;&emsp;在Spring中非常核心的内容是 <code>IOC</code>和 <code>AOP</code>.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/cd57c59d998e49eb87a2272f0f4da099.png" alt="image.png"></p><h2 id="2-IoC的几个疑问"><a href="#2-IoC的几个疑问" class="headerlink" title="2.IoC的几个疑问?"></a>2.IoC的几个疑问?</h2><h3 id="2-1-IoC是什么？"><a href="#2-1-IoC是什么？" class="headerlink" title="2.1 IoC是什么？"></a>2.1 IoC是什么？</h3><p>&emsp;&emsp;IoC:Inversion of Control 控制反转，简单理解就是：依赖对象的获得被反转了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/80310b140f9342a8b6001e1f456eb8a3.png" alt="image.png"></p><h3 id="2-2-IoC有什么好处"><a href="#2-2-IoC有什么好处" class="headerlink" title="2.2 IoC有什么好处?"></a>2.2 IoC有什么好处?</h3><p>IoC带来的好处：</p><ol><li>代码更加简洁，不需要去new 要使用的对象了</li><li>面向接口编程，使用者与具体类，解耦，易扩展、替换实现者</li><li>可以方便进行AOP编程</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/7ad2ade8947b4113a4dac3f3395e715f.png" alt="image.png"></p><h3 id="2-3-IoC容器做了什么工作"><a href="#2-3-IoC容器做了什么工作" class="headerlink" title="2.3 IoC容器做了什么工作?"></a>2.3 IoC容器做了什么工作?</h3><p>&emsp;&emsp;IoC容器的工作：负责创建，管理类实例，向使用者提供实例。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/7cc654e667b34e2bb05003b4c320b6e5.png" alt="image.png"></p><h3 id="2-4-IoC容器是否是工厂模式的实例"><a href="#2-4-IoC容器是否是工厂模式的实例" class="headerlink" title="2.4 IoC容器是否是工厂模式的实例?"></a>2.4 IoC容器是否是工厂模式的实例?</h3><p>&emsp;&emsp;是的，IoC容器负责来创建类实例对象，需要从IoC容器中get获取。IoC容器我们也称为Bean工厂。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/480d5fa007b44e648d49d34c77aeb4cd.png" alt="image.png"></p><p>&emsp;&emsp;那么我们一直说的Bean是什么呢？bean：组件，也就是类的对象!!!</p><h1 id="二、IoC实现"><a href="#二、IoC实现" class="headerlink" title="二、IoC实现"></a>二、IoC实现</h1><p>&emsp;&emsp;通过上面的介绍我们也清楚了IoC的核心就是Bean工厂，那么这个Bean工厂我们应该要如何来设计实现它呢？我们来继续分析。</p><h2 id="1-Bean工厂的作用"><a href="#1-Bean工厂的作用" class="headerlink" title="1.Bean工厂的作用"></a>1.Bean工厂的作用</h2><p>&emsp;&emsp;首先Bean工厂的作用我们上面也分析了就是创建，管理Bean，并且需要对外提供Bean的实例。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/521438fa1977428c8765207d9c0130e5.png" alt="image.png"></p><h2 id="2-Bean工厂的初步设计"><a href="#2-Bean工厂的初步设计" class="headerlink" title="2.Bean工厂的初步设计"></a>2.Bean工厂的初步设计</h2><p>&emsp;&emsp;基于Bean工厂的基本作用，我们可以来分析Bean工厂应该具备的相关行为。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/1378defbcd8147c1ae53601cef61349e.png" alt="image.png"></p><p>&emsp;&emsp;首先Bean工厂应该要对外提供获取bean实例的方法，所以需要定义一个getBean()方法。同时工厂需要知道生产的bean的类型，所以getBean()方法需要接受对应的参数，同时返回类型这块也可能有多个类型，我们就用Object来表示。这样Bean工厂的定义就出来了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/e9e8f44a98fd46779a75543398b806ad.png" alt="image.png"></p><p>&emsp;&emsp;上面定义了Bean工厂对外提供bean实例的方法，但是Bean工厂如何知道要创建上面对象，怎么创建该对象呢？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/d076f40b527e433982299f233a9dc404.png" alt="image.png"></p><p>&emsp;&emsp;所以在这里我们得把Bean的定义信息告诉BeanFactory工厂，然后BeanFactory工厂根据Bean的定义信息来生成对应的bean实例对象。所以在这儿我们要考虑两个问题</p><ol><li>我们需要定义一个模型来表示该如何创建Bean实例的信息，也就是Bean定义。</li><li>Bean工厂需要提供行为来接收这些Bean的定义信息。</li></ol><h2 id="3-Bean的定义"><a href="#3-Bean的定义" class="headerlink" title="3.Bean的定义"></a>3.Bean的定义</h2><p>&emsp;&emsp;根据上面的接收我们就清楚了Bean定义的意义了。那么我们来定义Bean定义的模型要考虑几个问题。</p><h3 id="3-1-Bean定义的作用是什么"><a href="#3-1-Bean定义的作用是什么" class="headerlink" title="3.1 Bean定义的作用是什么?"></a>3.1 Bean定义的作用是什么?</h3><p>&emsp;&emsp;作用肯定是告诉Bean工厂应该如何来创建某类的Bean实例</p><h3 id="3-2-获取实例的方式有哪些"><a href="#3-2-获取实例的方式有哪些" class="headerlink" title="3.2 获取实例的方式有哪些?"></a>3.2 获取实例的方式有哪些?</h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/364e061785e5406eae76cdba339a2248.png" alt="image.png"></p><h3 id="3-3-我们需要在BeanDefinition中给Bean工厂提供哪些信息"><a href="#3-3-我们需要在BeanDefinition中给Bean工厂提供哪些信息" class="headerlink" title="3.3 我们需要在BeanDefinition中给Bean工厂提供哪些信息?"></a>3.3 我们需要在BeanDefinition中给Bean工厂提供哪些信息?</h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2276051d92ac46eda9e758efea531bf3.png" alt="image.png"></p><p>在BeanDefinition顶级接口里，我们需要提供第一种传入bean类型通过反射得到bean，第二种通过工厂方法返回一个bean，第三种通过得到一个工厂对象，然后通过工厂对象去得到一个bean。</p><p>这样一来我们就清楚了BeanDefinition应该要具有的基本功能了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/d40a838ed1094dca8de7be1d74b49d58.png" alt="image.png"></p><h3 id="3-4-增强功能要求"><a href="#3-4-增强功能要求" class="headerlink" title="3.4 增强功能要求"></a>3.4 增强功能要求</h3><p>&emsp;&emsp;当然我们可以在现有的基础上增强要求，比如Bean工厂创建的是单例对象，具有特定的初始化方法和销毁逻辑的方法。</p><p> <img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2e5875faa8204904b132ce9fe29d57c9.png" alt="image.png"></p><p>&emsp;&emsp;同时创建BeanDefinition的一个通用实现类：GenericBeanDefinition。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2bbd7cd1aa7f479cad6d99d793d1ded8.png" alt="image.png"></p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_SINGLETION</span> <span class="operator">=</span> <span class="string">&quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> <span class="string">&quot;prototype&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; getBeanClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Scope</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否原型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂bean名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getInitMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getDestroyMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验bean定义的合法性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 没定义class,工厂bean或工厂方法没指定，则不合法。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getBeanClass() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(getFactoryBeanName()) || StringUtils.isBlank(getFactoryMethodName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了类，又定义工厂bean，不合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getBeanClass() != <span class="literal">null</span> &amp;&amp; StringUtils.isNotBlank(getFactoryBeanName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Bean的注册-BeanDefinitionRegistry"><a href="#4-Bean的注册-BeanDefinitionRegistry" class="headerlink" title="4.Bean的注册-BeanDefinitionRegistry"></a>4.Bean的注册-BeanDefinitionRegistry</h2><p>&emsp;&emsp;Bean的定义清楚后，我们要考虑的就是如何实现BeanDefinition和BeanFactory的关联了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/ba1ed12a2ce845d090f600a84a9eaca9.png" alt="image.png"></p><p>&emsp;&emsp;在这儿我们可以专门定义一个 <code>BeanDefinitionRegistry</code>来实现Bean定义的注册功能。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/8a4e48e221b245998c1d4197185bf466.png" alt="image.png"></p><p>&emsp;&emsp;那么我们需要考虑 BeanDefinitionRegistry 应该具备的功能，其实也简单就两个：</p><ol><li>注册BeanDefinition - 注册</li><li>获取BeanDefinition - 发现</li></ol><p>&emsp;&emsp;同时为了保证能够区分每个BeanDefinition的定义信息，我们得给每一个Bean定义一个唯一的名称。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/6132d08636ae4161899f801b90af16eb.png" alt="image.png"></p><p>具体实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionRegistException;</span><br><span class="line"><span class="comment">//根据名称去获取</span></span><br><span class="line">BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line"><span class="comment">// 判断当前这个注册器有没有这个bean定义</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-BeanFactory实现-DefaultBeanFactory"><a href="#5-BeanFactory实现-DefaultBeanFactory" class="headerlink" title="5.BeanFactory实现 - DefaultBeanFactory"></a>5.BeanFactory实现 - DefaultBeanFactory</h2><p>&emsp;&emsp;到现在为止我们来看看已经实现的相关设计功能：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/fe3fdeaf5ee54ab3831bedec83c22c68.png" alt="image.png"></p><p>&emsp;&emsp;通过上面的分析我们接下来就要考虑BeanFactory的功能实现了。我们先来实现一个最基础的默认的Bean工厂：DefaultBeanFactory。需要DefaultBeanFactory实现如下的5个功能</p><ol><li>实现Bean定义信息的注册</li><li>实现Bean工厂定义的getBean方法</li><li>实现初始化方法的执行</li><li>实现单例的要求</li><li>实现容器关闭是执行单例的销毁操作</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/4541d5156de04e888f34458ab920f8f1.png" alt="image.png"></p><p>具体看代码的案例代码，代码太多就不贴出来了。</p><p>思考：对于单例bean，我们可否提前实例化?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/96597cfe7982448f96c3e68b8f6e6800.png" alt="image.png"></p><h1 id="三、IoC增强"><a href="#三、IoC增强" class="headerlink" title="三、IoC增强"></a>三、IoC增强</h1><p>&emsp;&emsp;上面第一版本的IoC容器我们已经实现了，我们可以在这个基础上来基础迭代增强IoC的功能</p><h2 id="1-Bean别名的增强"><a href="#1-Bean别名的增强" class="headerlink" title="1.Bean别名的增强"></a>1.Bean别名的增强</h2><p>&emsp;&emsp;Bean除了标识唯一的名称外，还可以有任意个别名，别名也是唯一的。别名的特点</p><ol><li>可以有多个别名</li><li>也可以是别名的别名</li><li>别名也是唯一的</li></ol><p>&emsp;&emsp;&emsp;实现的时候我们需要考虑的问题</p><ol><li>数据结构</li><li>功能点</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/a6221d511b6847a9ba05b30421b3e757.png" alt="image.png"></p><p>具体代码交给大家课后尝试实现。</p><h2 id="2-Type类型的增强"><a href="#2-Type类型的增强" class="headerlink" title="2. Type类型的增强"></a>2. Type类型的增强</h2><p>&emsp;&emsp;上面实现的是根据 bean的 <code>name</code>来获取Bean实例，我们还希望能扩展通过 <code>Type</code>来获取实例对象。这时对应的接口为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/8434bdc7e07b43c18721eb9a7deb65ec.png" alt="image.png"></p><p>&emsp;&emsp;也就是需要实现根据Type找到Bean对象的功能。正常的实例逻辑为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/1297dc776e044ca387c942d3a2b0468b.png" alt="image.png"></p><p>&emsp;&emsp;但是上面的实现方案有点吃性能，我们可以尝试优化下，我们可以提前把Type和Bean的对应关系找出来，然后用Map缓存起来处理。对应的存储方式通过Map来处理</p><p>我们需要考虑几个问题：</p><ol><li>Map中存储的数据用什么合适？</li><li>type和bean是一对一的关系吗？</li><li>何时建立该关系呢？</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/ac42f182995f48f09be17df34fd3f1f1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; typeMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具体的实现我们可以在DefaultBeanFactory中添加一个buildTypeMap()方法来处理这个事情</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/da4b3e769f9a413d88db94a377ab501e.png" alt="image.png"></p><p>&emsp;&emsp;buildTypeMap()方法处理的逻辑如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/373378375858412e928714a1c49dc5d4.png" alt="image.png"></p><p>&emsp;&emsp;然后我们在BeanFactory中添加一个getType方法，封装获取Bean的Type的逻辑，方便buildTypeMap()方法的使用。最后就是getBean(Class<T>) 方法的实现了。因为Class对应的类型可能有多个，这时需要通过Primary来处理了。</T></p><p>IoC容器-核心部分类图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/f48e4223891a4d63ad6357b959a94388.png" alt="image.png"></p><p>总结：应用设计的原则：</p><ol><li>抽象，行为抽象分类处理(接口)</li><li>继承，扩展功能</li><li>面向接口编程</li><li>单一职责原则</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手写篇-手写IoC&quot;&gt;&lt;a href=&quot;#手写篇-手写IoC&quot; class=&quot;headerlink&quot; title=&quot;手写篇-手写IoC&quot;&gt;&lt;/a&gt;手写篇-手写IoC&lt;/h1&gt;&lt;h1 id=&quot;一、IoC分析&quot;&gt;&lt;a href=&quot;#一、IoC分析&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T09:53:47.431Z</published>
    <updated>2023-04-04T08:57:38.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-spring整合"><a href="#mybatis-spring整合" class="headerlink" title="mybatis-spring整合"></a>mybatis-spring整合</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis-spring整合&quot;&gt;&lt;a href=&quot;#mybatis-spring整合&quot; class=&quot;headerlink&quot; title=&quot;mybatis-spring整合&quot;&gt;&lt;/a&gt;mybatis-spring整合&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-01-13T12:00:00.000Z</published>
    <updated>2023-03-18T14:10:02.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ 都提供了事务相关功能） 、Saga 等等。</p><p>2PC、3PC 属于业务代码无侵入方案，都是基于 XA 规范衍生出来的实现，XA 规范是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。TCC、Saga 属于业务侵入方案，MQ 事务依赖于使用消息队列的场景，本地消息表不支持回滚。</p><p>开始介绍 2PC 和 3PC 之前，我们先来介绍一下 2PC 和 3PC 涉及到的一些角色（XA 规范的角色组成）：<br><img src="HTTP://zdwtop.cn/blog/image-20230314214742411.png" alt="分布式"><br>  ● AP（Application Program）：应用程序本身。<br>  ● RM（Resource Manager） ：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库（后文会以关系型数据库为例），一个分布式事务往往涉及到多个 RM。<strong>DB</strong><br>● TM（Transaction Manager） ：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</p><h2 id="2PC（两阶段提交协议）"><a href="#2PC（两阶段提交协议）" class="headerlink" title="2PC（两阶段提交协议）"></a>2PC（两阶段提交协议）</h2><p><img src="HTTPs://zdwtop.cn/blog/1666839398805-8d026011-316f-497a-9c11-e5a2e4a4b669.png" alt="2pc"></p><p>2PC（Two-Phase Commit）这三个字母的含义:</p><p>● 2 -&gt; 指代事务提交的 2 个阶段<br>● P-&gt; Prepare (准备阶段)<br>● C -&gt;Commit（提交阶段）</p><p>2PC 将事务的提交过程分为 2 个阶段：<strong>准备阶段</strong> 和 <strong>提交阶段</strong> 。</p><h4 id="准备阶段-Prepare"><a href="#准备阶段-Prepare" class="headerlink" title="准备阶段(Prepare)"></a><strong>准备阶段(Prepare)</strong></h4><p>准备阶段的核心是“询问”事务参与者执行本地数据库事务操作是否成功。</p><p>准备阶段的工作流程：</p><p>1、 <strong>事务协调者/管理者（后文简称 TM）</strong>： 向所有涉及到的 <strong>事务参与者（后文简称 RM）</strong> 发送消息询问：“你是否可以执行事务操作呢？”，并等待其答复。<br>2 、<strong>RM</strong> 接收到消息之后，开始执行本地数据库事务预操作比如写 redo log/undo log 日志，<strong>此时并不会提交事务 。</strong><br>3 、RM 如果执行本地数据库事务操作成功，那就回复“Yesdb”表示我已就绪，否则就回复“No”表示我未就绪。</p><h4 id="提交阶段-Commit"><a href="#提交阶段-Commit" class="headerlink" title="提交阶段(Commit)"></a><strong>提交阶段(Commit)</strong></h4><p>提交阶段的核心是“询问”事务参与者提交本地事务是否成功。</p><p>当所有事务参与者都是“就绪”状态的话：</p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以提交事务啦！”（Commit 消息）<br>2、<strong>RM</strong> 接收到 <strong>Commit 消息</strong> 后执行 <strong>提交本地数据库事务</strong> 操作，执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经提交” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>事务参与者</strong> 的 ACK 消息 之后，整个分布式事务过程正式结束。</p><p><strong>当任一事务参与者是“未就绪”状态的话：</strong></p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以执行回滚操作了！”<strong>（Rollback 消息）。</strong><br>2、<strong>RM</strong> 接收到 Rollback 消息 后执行 <strong>本地数据库事务回滚</strong> 执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经回滚” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>RM 的 ACK 消息</strong> 之后，中断事务。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下 2PC 两阶段中比较重要的一些点：</p><p>1、<strong>准备阶段</strong> 的主要目的是<strong>测试 RM</strong> 能否执行 <strong>本地数据库事务</strong> 操作（!!!注意：<strong>这一步并不会提交事务</strong>）。<br>2、<strong>提交阶段</strong> 中 <strong>TM</strong> 会根据 <strong>准备阶段 中 RM 的消息</strong>来决定是执行<strong>事务提交</strong>还是<strong>回滚操作</strong>。<br>3、提交阶段 之后一定会结束当前的分布式事务</p><h5 id="2PC-的优点："><a href="#2PC-的优点：" class="headerlink" title="2PC 的优点："></a><strong>2PC 的优点：</strong></h5><p>● 实现起来非常简单，各大主流数据库比如 MySQL、Oracle 都有自己实现。<br>● 针对的是数据强一致性。不过，仍然可能存在数据不一致的情况。</p><h5 id="2PC-存在的问题："><a href="#2PC-存在的问题：" class="headerlink" title="2PC 存在的问题："></a><strong>2PC 存在的问题：</strong></h5><p>● <strong>同步阻塞</strong> ：事务参与者会在正式提交事务之前会一直占用相关的资源。比如用户小明转账给小红，那其他事务也要操作用户小明或小红的话，就会阻塞。<br>● <strong>数据不一致</strong> ：由于网络问题或者TM宕机都有可能会造成数据不一致的情况。比如在第2阶段（提交阶段），部分网络出现问题导致部分参与者收不到 Commit/Rollback 消息的话，就会导致数据不一致。<br>● <strong>单点问题</strong> ： TM在其中也是一个很重要的角色，如果TM在准备(Prepare)阶段完成之后挂掉的话，事务参与者就会一直卡在提交(Commit)阶段。</p><h2 id="3PC（三阶段提交协议）"><a href="#3PC（三阶段提交协议）" class="headerlink" title="3PC（三阶段提交协议）"></a>3PC（三阶段提交协议）</h2><p>3PC 是人们在 2PC 的基础上做了一些优化得到的。3PC 把 2PC 中的 准备阶段(Prepare) 做了进一步细化，分为 2 个阶段：</p><p>● 准备阶段(CanCommit)<br>● 预提交阶段(PreCommit)</p><h4 id="准备阶段-CanCommit"><a href="#准备阶段-CanCommit" class="headerlink" title="准备阶段(CanCommit)"></a>准备阶段(CanCommit)</h4><p>这一步不会执行事务操作，只是向 <strong>RM 发送 准备请求</strong> ，顺便询问一些信息比如事务参与者能否执行本地数据库事务操作。RM 回复“Yes”、“No”或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有参与者发送“Abort”消息），否则进入 <strong>预提交阶段(PreCommit) 。</strong></p><h4 id="预提交阶段-PreCommit"><a href="#预提交阶段-PreCommit" class="headerlink" title="预提交阶段(PreCommit)"></a>预提交阶段(PreCommit)</h4><p><strong>TM</strong> 向所有涉及到的 RM 发送 <strong>预提交请求</strong> ，RM 回复“Yes”、“No”（最后的反悔机会）或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有事务参与者发送“abort”消息），否则进入 <strong>执行事务提交阶段</strong>（DoCommit） 。</p><p>当所有 RM 都返回“Yes”之后， RM 才会执行本地数据库事务预操作比如写 <strong>redo log/undo log</strong> 日志。</p><h4 id="执行事务提交阶段（DoCommit）"><a href="#执行事务提交阶段（DoCommit）" class="headerlink" title="执行事务提交阶段（DoCommit）"></a>执行事务提交阶段（DoCommit）</h4><p>执行事务提交（DoCommit） 阶段就开始进行真正的事务提交。</p><p>TM 向所有涉及到的 RM 发送 <strong>执行事务提交请求</strong> ，<strong>RM 收到消息后开始正式提交事务</strong>，并在完成事务提交后释放占用的资源。</p><p>如果 TM 收到所有 RM 正确提交事务的消息的话，表示事务正常完成。如果任一 RM 没有正确提交事务或者超时的话，就中断事务，TM 向所有 RM 发送“Abort”消息。RM 接收到 Abort 请求后，执行本地数据库事务回滚，后面的步骤就和 2PC 中的类似了。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>3PC 除了将2PC 中的准备阶段(Prepare) 做了进一步细化之外，还做了哪些改进？</strong></p><p>3PC 还同时在事务管理者和事务参与者中引入了 <strong>超时机制</strong> ，如果在一定时间内没有收到事务参与者的消息就默认失败，进而避免事务参与者一直阻塞占用资源。2PC 中只有事务管理者才拥有超时机制，当事务参与者长时间无法与事务协调者通讯的情况下（比如协调者挂掉了），就会导致无法释放资源阻塞的问题。</p><p>不过，3PC 并没有完美解决 2PC 的阻塞问题，引入了一些新问题比如性能糟糕，而且，依然存在数据不一致性问题。因此，3PC 的实际应用并不是很广泛，<strong>多数应用会选择通过复制状态机解决 2PC 的阻塞问题。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;p&gt;分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ </summary>
      
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论</title>
    <link href="https://eizo01.github.io/posts/41166861.html"/>
    <id>https://eizo01.github.io/posts/41166861.html</id>
    <published>2023-01-09T12:00:00.000Z</published>
    <updated>2023-03-11T14:00:04.564Z</updated>
    
    <content type="html"><![CDATA[<h1>1、CAP 理论</h1><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" alt="cap"><br>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性</strong>（Consistency） : 所有节点访问同一份最新的数据副本</li><li><strong>可用性</strong>（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性</strong>（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>插入一个小知识：网络分区<br>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p><blockquote><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。<br>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性C。<br>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</p></blockquote><p>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。<br>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。<br>这些特性将会在注册中心体现：常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos…。</p><ol><li><strong>ZooKeeper 保证的是 CP</strong>。任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li><li><strong>Eureka 保证的则是 AP</strong>。 Eureka 在设计的时候就是<strong>优先保证 A （可用性）</strong>。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。所以它不能保证数据到来就能同步所有节点，是弱一致性。</li><li><strong>Nacos 不仅支持 CP 也支持 AP</strong>。还可以作为配置中心，这是nacos提供的新特性。</li></ol><h1>2、BASE 理论</h1><p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h2 id="BASE-理论的核心思想">BASE 理论的核心思想</h2><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。<br>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。<br>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p><h2 id="基本可用">基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。<br><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h2 id="软状态">软状态</h2><p>软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h2 id="最终一致性">最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。<br><strong>分布式一致性的 3 种级别</strong>：<br><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。<br><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。<br><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。<br>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。<br>那实现最终一致性的具体方式是什么呢? 《分布式协议与算法实战》open in new window 中是这样介绍：<br><strong>读时修复</strong> :  在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。<br><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。<br><strong>异步修复 :</strong> 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</p>]]></content>
    
    
    <summary type="html">🥧详细介绍分布式领域中的理论，为分布式系统打下基础</summary>
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式理论" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis整合Spring的原理分析</title>
    <link href="https://eizo01.github.io/posts/4287b857.html"/>
    <id>https://eizo01.github.io/posts/4287b857.html</id>
    <published>2022-12-10T12:00:00.000Z</published>
    <updated>2023-04-04T08:57:38.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis整合Spring的原理分析"><a href="#MyBatis整合Spring的原理分析" class="headerlink" title="MyBatis整合Spring的原理分析"></a>MyBatis整合Spring的原理分析</h1><p><a href="http://mybatis.org/spring/zh/index.html">http://mybatis.org/spring/zh/index.html</a></p><h2 id="1-MyBatis整合Spring实现"><a href="#1-MyBatis整合Spring实现" class="headerlink" title="1. MyBatis整合Spring实现"></a>1. MyBatis整合Spring实现</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们先来实现MyBatis和Spring的整合操作。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/3c836661773f488f88610095398a5432.png" alt="image.png"></p><h3 id="1-1-添加相关的依赖"><a href="#1-1-添加相关的依赖" class="headerlink" title="1.1 添加相关的依赖"></a>1.1 添加相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h3><p>我们将MyBatis整合到Spring中，那么原来在MyBatis的很多配置我们都可以在Spring的配置文件中设置，我们可以给MyBatis的配置文件设置为空</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加Spring的配置文件，并在该文件中实现和Spring的整合操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关联数据属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zdw&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 整合mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联mybatis的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config-spring.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加别名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zdw.domain&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置扫描的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zdw.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><p>然后我们就可以通过测试来操作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RunWith(value = SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisSpringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">bean</span> <span class="operator">=</span> ac.getBean(IUserService.class);</span><br><span class="line">    List&lt;User&gt; list = bean.query();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单元测试的代码我们可以发现，将MyBatis整合到Spring中后，原来操作的核心对象(SqlSessionFactory,SqlSession,getMapper)都不见了，使我们的开发更加的简洁。</p><h2 id="2-MyBatis整合Spring的原理"><a href="#2-MyBatis整合Spring的原理" class="headerlink" title="2.MyBatis整合Spring的原理"></a>2.MyBatis整合Spring的原理</h2><p>把MyBatis集成到Spring里面，是为了进一步简化MyBatis的使用，所以只是对MyBatis做了一些封装，并没有替换MyBatis的核心对象。也就是说：MyBatis jar包中的SqlSessionFactory、SqlSession、MapperProxy这些类都会用到。mybatis-spring.jar里面的类只是做了一些包装或者桥梁的工作。</p><p>只要我们弄明白了这三个对象是怎么创建的，也就理解了Spring继承MyBatis的原理。我们把它分成三步：</p><ol><li>SqlSessionFactory在哪创建的。</li><li>SqlSession在哪创建的。</li><li>代理类在哪创建的。</li></ol><h3 id="2-1-SqlSessionFactory"><a href="#2-1-SqlSessionFactory" class="headerlink" title="2.1 SqlSessionFactory"></a>2.1 SqlSessionFactory</h3><p>首先我们来看下在MyBatis整合Spring中SqlSessionFactory的创建过程，查看这步的入口在Spring的配置文件中配置整合的标签中</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/d52e211fccaa4776a5a117fd70fa16a4.png" alt="image.png"></p><p>我们进入SqlSessionFactoryBean中查看源码发现，其实现了InitializingBean 、FactoryBean、ApplicationListener 三个接口</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/620e151e278643b69382f88a97edee70.png" alt="image.png"></p><p>对于这三个接口，学过Spring生命周期的小伙伴应该清楚他们各自的作用</p><div class="table-container"><table><thead><tr><th><strong>接口</strong></th><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>FactoryBean</td><td>getObject()</td><td>返回由FactoryBean创建的Bean实例</td></tr><tr><td>InitializingBean</td><td>afterPropertiesSet()</td><td>bean属性初始化完成后添加操作</td></tr><tr><td>ApplicationListener</td><td>onApplicationEvent()</td><td>对应用的时间进行监听</td></tr></tbody></table></div><h4 id="2-1-1-afterPropertiesSet"><a href="#2-1-1-afterPropertiesSet" class="headerlink" title="2.1.1 afterPropertiesSet"></a>2.1.1 afterPropertiesSet</h4><p>我们首先来看下 afterPropertiesSet 方法中的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.configuration == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.configLocation == <span class="literal">null</span> || <span class="built_in">this</span>.configuration == <span class="literal">null</span> || <span class="built_in">this</span>.configLocation == <span class="literal">null</span>, <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = <span class="built_in">this</span>.buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在afterPropertiesSet中直接调用了buildSqlSessionFactory方法来实现 sqlSessionFactory 对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 解析全局配置文件的 XMLConfigBuilder 对象</span></span><br><span class="line">      <span class="type">XMLConfigBuilder</span> <span class="variable">xmlConfigBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// Configuration 对象</span></span><br><span class="line">      Configuration targetConfiguration;</span><br><span class="line">      Optional var10000;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.configuration != <span class="literal">null</span>) &#123; <span class="comment">// 判断是否存在 configuration对象，如果存在说明已经解析过了</span></span><br><span class="line">          targetConfiguration = <span class="built_in">this</span>.configuration;</span><br><span class="line">          <span class="comment">// 覆盖属性</span></span><br><span class="line">          <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="literal">null</span>) &#123;</span><br><span class="line">              targetConfiguration.setVariables(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configurationProperties != <span class="literal">null</span>) &#123;</span><br><span class="line">              targetConfiguration.getVariables().putAll(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果configuration对象不存在，但是存在configLocation属性，就根据mybatis-config.xml的文件路径来构建 xmlConfigBuilder对象</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configLocation != <span class="literal">null</span>) &#123;  </span><br><span class="line">          xmlConfigBuilder = <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(<span class="built_in">this</span>.configLocation.getInputStream(), (String)<span class="literal">null</span>, <span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 属性&#x27;configuration&#x27;或&#x27;configLocation&#x27;未指定，使用默认MyBatis配置</span></span><br><span class="line">          LOGGER.debug(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          targetConfiguration = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">          var10000 = Optional.ofNullable(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          Objects.requireNonNull(targetConfiguration);</span><br><span class="line">          var10000.ifPresent(targetConfiguration::setVariables);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 设置 Configuration 中的属性  即我们可以在Mybatis和Spring的整合文件中来设置 MyBatis的全局配置文件中的设置</span></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.objectFactory);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.objectWrapperFactory);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.vfs);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line">      Stream var24;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">          var24 = <span class="built_in">this</span>.scanClasses(<span class="built_in">this</span>.typeAliasesPackage, <span class="built_in">this</span>.typeAliasesSuperType).stream().filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isMemberClass();</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="type">TypeAliasRegistry</span> <span class="variable">var10001</span> <span class="operator">=</span> targetConfiguration.getTypeAliasRegistry();</span><br><span class="line">          Objects.requireNonNull(var10001);</span><br><span class="line">          var24.forEach(var10001::registerAlias);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeAliases)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.typeAliases).forEach((typeAlias) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered type alias: &#x27;&quot;</span> + typeAlias + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.plugins)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.plugins).forEach((plugin) -&gt; &#123;</span><br><span class="line">              targetConfiguration.addInterceptor(plugin);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered plugin: &#x27;&quot;</span> + plugin + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">          var24 = <span class="built_in">this</span>.scanClasses(<span class="built_in">this</span>.typeHandlersPackage, TypeHandler.class).stream().filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !Modifier.isAbstract(clazz.getModifiers());</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="type">TypeHandlerRegistry</span> <span class="variable">var25</span> <span class="operator">=</span> targetConfiguration.getTypeHandlerRegistry();</span><br><span class="line">          Objects.requireNonNull(var25);</span><br><span class="line">          var24.forEach(var25::register);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.typeHandlers).forEach((typeHandler) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered type handler: &#x27;&quot;</span> + typeHandler + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.scriptingLanguageDrivers).forEach((languageDriver) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered scripting language driver: &#x27;&quot;</span> + languageDriver + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.defaultScriptingLanguageDriver);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              targetConfiguration.setDatabaseId(<span class="built_in">this</span>.databaseIdProvider.getDatabaseId(<span class="built_in">this</span>.dataSource));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException var23) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed getting a databaseId&quot;</span>, var23);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.cache);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::addCache); <span class="comment">// 如果cache不为空就把cache 添加到 configuration对象中</span></span><br><span class="line">      <span class="keyword">if</span> (xmlConfigBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              xmlConfigBuilder.parse(); <span class="comment">// 解析全局配置文件</span></span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="built_in">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception var21) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="built_in">this</span>.configLocation, var21);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ErrorContext.instance().reset();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      targetConfiguration.setEnvironment(<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="built_in">this</span>.environment, (TransactionFactory)(<span class="built_in">this</span>.transactionFactory == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>() : <span class="built_in">this</span>.transactionFactory), <span class="built_in">this</span>.dataSource));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">              LOGGER.warn(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Resource[] var3 = <span class="built_in">this</span>.mapperLocations;</span><br><span class="line">              <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> var3.length;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                  <span class="type">Resource</span> <span class="variable">mapperLocation</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">                  <span class="keyword">if</span> (mapperLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">//创建了一个用来解析Mapper.xml的XMLMapperBuilder，调用了它的parse()方法。这个步骤我们之前了解过了，</span></span><br><span class="line">                          <span class="comment">//主要做了两件事情，一个是把增删改查标签注册成MappedStatement对象。</span></span><br><span class="line">                          <span class="comment">// 第二个是把接口和对应的MapperProxyFactory工厂类注册到MapperRegistry中</span></span><br><span class="line">                          <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(), targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                          xmlMapperBuilder.parse();</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, var19);</span><br><span class="line">                      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          ErrorContext.instance().reset();</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                          <span class="keyword">return</span> <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                      &#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          LOGGER.debug(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 最后调用sqlSessionFactoryBuilder.build()返回了一个DefaultSqlSessionFactory。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在afterPropertiesSet方法中完成了SqlSessionFactory对象的创建，已经相关配置文件和映射文件的解析操作。</p><p>方法小结一下：通过定义一个实现了InitializingBean接口的SqlSessionFactoryBean类，里面有一个afterPropertiesSet()方法会在bean的属性值设置完的时候被调用。Spring在启动初始化这个Bean的时候，完成了解析和工厂类的创建工作。</p><h4 id="2-1-2-getObject"><a href="#2-1-2-getObject" class="headerlink" title="2.1.2 getObject"></a>2.1.2 getObject</h4><p>另外SqlSessionFactoryBean实现了FactoryBean接口。</p><p>FactoryBean的作用是让用户可以自定义实例化Bean的逻辑。如果从BeanFactory中根据Bean的ID获取一个Bean，它获取的其实是FactoryBean的getObject()返回的对象。</p><p>也就是说，我们获取SqlSessionFactoryBean的时候，就会调用它的getObject()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObject方法中的逻辑就非常简单，返回SqlSessionFactory对象，如果SqlSessionFactory对象为空的话就又调用一次afterPropertiesSet来解析和创建一次。</p><h4 id="2-1-3-onApplicationEvent"><a href="#2-1-3-onApplicationEvent" class="headerlink" title="2.1.3 onApplicationEvent"></a>2.1.3 onApplicationEvent</h4><p>实现ApplicationListener接口让SqlSessionFactoryBean有能力监控应用发出的一些事件通知。比如这里监听了ContextRefreshedEvent（上下文刷新事件），会在Spring容器加载完之后执行。这里做的事情是检查ms是否加载完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.failFast &amp;&amp; event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-SqlSession"><a href="#2-2-SqlSession" class="headerlink" title="2.2 SqlSession"></a>2.2 SqlSession</h3><h4 id="2-2-1-DefaultSqlSession的问题"><a href="#2-2-1-DefaultSqlSession的问题" class="headerlink" title="2.2.1 DefaultSqlSession的问题"></a>2.2.1 DefaultSqlSession的问题</h4><p>在前面介绍MyBatis的使用的时候，通过SqlSessionFactory的open方法获取的是DefaultSqlSession，但是在Spring中我们不能直接使用DefaultSqlSession，因为DefaultSqlSession是线程不安全的。所以直接使用会存在数据安全问题，针对这个问题的，在整合的MyBatis-Spring的插件包中给我们提供了一个对应的工具SqlSessionTemplate。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/1f28ec9841ef4031816dc12cd59e0c80.png" alt="image.png"></p><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/d62b09e3616e4ff586ade9b5637073b8.png" alt="image.png"></p><p>也就是在我们使用SqlSession的时候都需要使用try catch 块来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   session = sqlSessionFactory.openSession();</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整合Spring中通过提供的SqlSessionTemplate来简化了操作，提供了安全处理。</p><h4 id="2-2-2-SqlSessionTemplate"><a href="#2-2-2-SqlSessionTemplate" class="headerlink" title="2.2.2 SqlSessionTemplate"></a>2.2.2 SqlSessionTemplate</h4><p>在mybatis-spring的包中，提供了一个线程安全的SqlSession的包装类，用来替代SqlSession，这个类就是SqlSessionTemplate。因为它是线程安全的，所以可以在所有的DAO层共享一个实例（默认是单例的）。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/9479734db48f42b28115dfe44d85be1a.png" alt="image.png"></p><p>SqlSessionTemplate虽然跟DefaultSqlSession一样定义了操作数据的selectOne()、selectList()、insert()、update()、delete()等所有方法，但是没有自己的实现，全部调用了一个代理对象的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/4bc98188f0ca467086c9c1ed3b3341b7.png" alt="image.png"></p><p>那么SqlSessionProxy是怎么来的呢？在SqlSessionTemplate的构造方法中有答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span><br><span class="line"><span class="params">    PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">  notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="built_in">this</span>.executorType = executorType;</span><br><span class="line">  <span class="built_in">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="comment">// 创建了一个 SqlSession 接口的代理对象， 调用SqlSessionTemplate中的 selectOne() 方法，其实就是调用</span></span><br><span class="line">    <span class="comment">// SqlSessionProxy的 selectOne() 方法，然后执行的是 SqlSessionInterceptor里面的 invoke方法</span></span><br><span class="line">  <span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的介绍那么我们应该进入到 SqlSessionInterceptor 的 invoke 方法中。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/cd0625c0163a4d55b0657a595760c829.png" alt="image.png"></p><p>上面的代码虽然看着比较复杂，但是本质上就是下面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   session = sqlSessionFactory.openSession();</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSqlSession方法中的关键代码：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/bdba616d94ba402fb2b7fb7ef5af3cdc.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/5d887bfb8e5c45c2bcd5d8aaf204a80a.png" alt="image.png"></p><p><strong>总结一下</strong>：因为DefaultSqlSession自己做不到每次请求调用产生一个新的实例，我们干脆创建一个代理类，也实现SqlSession，提供跟DefaultSqlSession一样的方法，在任何一个方法被调用的时候都先创建一个DefaultSqlSession实例，再调用被代理对象的相应方法。</p><p>MyBatis还自带了一个线程安全的SqlSession实现：SqlSessionManager，实现方式一样，如果不集成到Spring要保证线程安全，就用SqlSessionManager。</p><h4 id="2-2-3-SqlSessionDaoSupport"><a href="#2-2-3-SqlSessionDaoSupport" class="headerlink" title="2.2.3 SqlSessionDaoSupport"></a>2.2.3 SqlSessionDaoSupport</h4><p>通过上面的介绍我们清楚了在Spring项目中我们应该通过SqlSessionTemplate来执行数据库操作，那么我们就应该首先将SqlSessionTemplate添加到IoC容器中，然后我们在Dao通过@Autowired来获取具体步骤参考官网：<a href="http://mybatis.org/spring/zh/sqlsession.html">http://mybatis.org/spring/zh/sqlsession.html</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/9e232bb8c69845d0bd7ff903fea08829.png" alt="image.png"></p><p>然后我们可以看看SqlSessionDaoSupport中的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/a703e6fb875647ccba442245474496fe.png" alt="image.png"></p><p>如此一来在Dao层我们就只需要继承 SqlSessionDaoSupport就可以通过getSqlSession方法来直接操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他代码省略</span></span><br></pre></td></tr></table></figure><p>也就是说我们让DAO层（实现类）继承抽象类SqlSessionDaoSupport，就自动拥有了getSqlSession()方法。调用getSqlSession()就能拿到共享的SqlSessionTemplate。</p><p>在DAO层执行SQL格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getSqlSession().selectOne(statement, parameter);</span><br><span class="line">getSqlSession().insert(statement);</span><br><span class="line">getSqlSession().update(statement);</span><br><span class="line">getSqlSession().delete(statement);</span><br></pre></td></tr></table></figure><p>还是不够简洁。为了减少重复的代码，我们通常不会让我们的实现类直接去继承SqlSessionDaoSupport，而是先创建一个BaseDao继承SqlSessionDaoSupport。在BaseDao里面封装对数据库的操作，包括selectOne()、selectList()、insert()、delete()这些方法，子类就可以直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">BaseDao</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> &#123;</span><br><span class="line">   <span class="comment">//使用sqlSessionFactory</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getSqlSession().selectOne(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure><p>然后让我们的DAO层实现类继承BaseDao并且实现我们的Mapper接口。实现类需要加上@Repository的注解。</p><p>在实现类的方法里面，我们可以直接调用父类（BaseDao）封装的selectOne()方法，那么它最终会调用sqlSessionTemplate的selectOne()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span> <span class="keyword">implements</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Employee <span class="title function_">selectByPrimaryKey</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> (Employee) <span class="built_in">this</span>.selectOne(<span class="string">&quot;com.boboedu.crud.dao.EmployeeMapper.selectByPrimaryKey&quot;</span>,empId);</span><br><span class="line">       <span class="keyword">return</span> emp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure><p>然后在需要使用的地方，比如Service层，注入我们的实现类，调用实现类的方法就行了。我们这里直接在单元测试类DaoSupportTest.java里面注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">EmployeeDaoImpl employeeDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">EmployeeDaoSupportTest</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(employeeDao.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到DefaultSqlSession的方法。</p><h4 id="2-2-4-MapperScannerConfigurer"><a href="#2-2-4-MapperScannerConfigurer" class="headerlink" title="2.2.4 MapperScannerConfigurer"></a>2.2.4 MapperScannerConfigurer</h4><p>上面我们介绍了SqlSessionTemplate和SqlSessionDaoSupport，也清楚了他们的作用，但是我们在实际开发的时候，还是能够直接获取到 Mapper 的代理对象，并没有创建Mapper的实现类，这个到底是怎么实现的呢？这个我们就要注意在整合MyBatis的配置文件中除了SqlSessionFactoryBean以外我们还设置了一个MapperScannerConfigurer，我们来分析下这个类</p><p>首先是MapperScannerConfigurer的继承结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/70e0612bcf1548188206d3f683af3c72.png" alt="image.png"></p><p>MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor接口。BeanDefinitionRegistryPostProcessor 是BeanFactoryPostProcessor的子类，里面有一个postProcessBeanDefinitionRegistry()方法。</p><p>实现了这个接口，就可以在Spring创建Bean之前，修改某些Bean在容器中的定义。Spring创建Bean之前会调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">    processPropertyPlaceHolders(); <span class="comment">// 处理 占位符</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ClassPathMapperScanner 对象</span></span><br><span class="line">  <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">  scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">  scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">  scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">  scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">  scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">  scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">  scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">  scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">  scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">  scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 根据上面的配置生成对应的 过滤器</span></span><br><span class="line">  scanner.registerFilters();</span><br><span class="line">    <span class="comment">// 开始扫描basePackage字段中指定的包及其子包</span></span><br><span class="line">  scanner.scan(</span><br><span class="line">      StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的核心是 scan方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    <span class="built_in">this</span>.doScan(basePackages);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用子类ClassPathMapperScanner 中的 doScan方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类中的 doScan方法 扫描所有的接口，把接口全部添加到beanDefinitions中。</span></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">    LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">        + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在注册beanDefinitions的时候，BeanClass被改为MapperFactoryBean</span></span><br><span class="line">    processBeanDefinitions(beanDefinitions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/dd0804867b50469285cbf1a56f79075b.png" alt="image.png"></p><p>因为一个接口是没法创建实例对象的，这时我们就在创建对象之前将这个接口类型指向了一个具体的普通Java类型，MapperFactoryBean .也就是说，所有的Mapper接口，在容器里面都被注册成一个支持泛型的MapperFactoryBean了。然后在创建这个接口的对象时创建的就是MapperFactoryBean 对象。</p><h4 id="2-2-5-MapperFactoryBean"><a href="#2-2-5-MapperFactoryBean" class="headerlink" title="2.2.5 MapperFactoryBean"></a>2.2.5 MapperFactoryBean</h4><p>为什么要注册成它呢？那注入使用的时候，也是这个对象，这个对象有什么作用？首先来看看他们的类图结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/1f31b3afbf8248ddb8e4a1e982b25359.png" alt="image.png"></p><p>从类图中我们可以看到MapperFactoryBean继承了SqlSessionDaoSupport,那么每一个注入Mapper的地方，都可以拿到SqlSessionTemplate对象了。然后我们还发现MapperFactoryBean实现了 FactoryBean接口，也就意味着，向容器中注入MapperFactoryBean对象的时候，本质上是把getObject方法的返回对象注入到了容器中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// 从这可以看到 本质上 Mapper接口 还是通过DefaultSqlSession.getMapper方法获取了一个JDBC的代理对象，和我们前面讲解的就关联起来了</span></span><br><span class="line">  <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并没有直接返回一个MapperFactoryBean。而是调用了SqlSessionTemplate的getMapper()方法。SqlSessionTemplate的本质是一个代理，所以它最终会调用DefaultSqlSession的getMapper()方法。后面的流程我们就不重复了。也就是说，最后返回的还是一个JDK的动态代理对象。</p><p>所以最后调用Mapper接口的任何方法，也是执行MapperProxy的invoke()方法，后面的流程就跟编程式的工程里面一模一样了</p><p>总结一下，Spring是怎么把MyBatis继承进去的？</p><p>1、提供了SqlSession的替代品SqlSessionTemplate，里面有一个实现了实现了InvocationHandler的内部SqlSessionInterceptor，本质是对SqlSession的代理。</p><p>2、提供了获取SqlSessionTemplate的抽象类SqlSessionDaoSupport。</p><p>3、扫描Mapper接口，注册到容器中的是MapperFactoryBean，它继承了SqlSessionDaoSupport，可以获得SqlSessionTemplate。</p><p>4、把Mapper注入使用的时候，调用的是getObject()方法，它实际上是调用了SqlSessionTemplate的getMapper()方法，注入了一个JDK动态代理对象。</p><p>5、执行Mapper接口的任意方法，会走到触发管理类MapperProxy，进入SQL处理流程。</p><p>核心对象：</p><div class="table-container"><table><thead><tr><th><strong>对象</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>SqlSessionTemplate</td><td>Spring中SqlSession的替代品，是线程安全的</td></tr><tr><td>SqlSessionDaoSupport</td><td>用于获取SqlSessionTemplate</td></tr><tr><td>SqlSessionInterceptor（内部类）</td><td>代理对象，用来代理DefaultSqlSession，在SqlSessionTemplate中使用</td></tr><tr><td>MapperFactoryBean</td><td>代理对象，继承了SqlSessionDaoSupport用来获取SqlSessionTemplate</td></tr><tr><td>SqlSessionHolder</td><td>控制SqlSession和事务</td></tr></tbody></table></div><h2 id="3-设计模式总结"><a href="#3-设计模式总结" class="headerlink" title="3.设计模式总结"></a>3.设计模式总结</h2><div class="table-container"><table><thead><tr><th>设计模式</th><th><strong>类</strong></th></tr></thead><tbody><tr><td>工厂模式</td><td>SqlSessionFactory、ObjectFactory、MapperProxyFactory</td></tr><tr><td>建造者模式</td><td>XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuidler</td></tr><tr><td>单例模式</td><td>SqlSessionFactory、Configuration、ErrorContext</td></tr><tr><td>代理模式</td><td>绑定：MapperProxy<br>延迟加载：ProxyFactory   &#x3c;br/&gt;插件：PluginSpring  &#x3c;br&gt;集成MyBaits：  SqlSessionTemplate的内部SqlSessionInterceptorMyBatis&#x3c;br&gt;自带连接池：PooledConnection&#x3c;br/&gt;日志打印：ConnectionLogger、StatementLogger</td></tr><tr><td>适配器模式</td><td>Log，对于Log4j、JDK logging这些没有直接实现slf4j接口的日志组件，需要适配器</td></tr><tr><td>模板方法</td><td>BaseExecutor、SimpleExecutor、BatchExecutor、ReuseExecutor</td></tr><tr><td>装饰器模式</td><td>LoggingCache、LruCache对PerpetualCacheCachingExecutor对其他Executor</td></tr><tr><td>责任链模式</td><td>Interceptor、InterceptorChain</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis整合Spring的原理分析&quot;&gt;&lt;a href=&quot;#MyBatis整合Spring的原理分析&quot; class=&quot;headerlink&quot; title=&quot;MyBatis整合Spring的原理分析&quot;&gt;&lt;/a&gt;MyBatis整合Spring的原理分析&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis核心工作原理讲解</title>
    <link href="https://eizo01.github.io/posts/7233d38e.html"/>
    <id>https://eizo01.github.io/posts/7233d38e.html</id>
    <published>2022-12-08T12:00:00.000Z</published>
    <updated>2023-04-04T08:57:38.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis核心工作原理讲解"><a href="#MyBatis核心工作原理讲解" class="headerlink" title="MyBatis核心工作原理讲解"></a>MyBatis核心工作原理讲解</h1><h1 id="一、MyBatis源码分析"><a href="#一、MyBatis源码分析" class="headerlink" title="一、MyBatis源码分析"></a>一、MyBatis源码分析</h1><h2 id="1-三层划分介绍"><a href="#1-三层划分介绍" class="headerlink" title="1.三层划分介绍"></a>1.三层划分介绍</h2><p>首先大家要从宏观上了解Mybatis的整体框架分为三层，分别是基础支持层、核心处理层、和接口层。如下图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/0f2aea0caa394ff1bee96bb8bbb97dc9.png" alt="image.png"></p><p>然后根据前面讲解的MyBatis的应用案例，给出MyBatis的主要工作流程图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/561666a5f7f447f1b64927dcd15b1316.png" alt="image.png"></p><p>在MyBatis的主要工作流程里面，不同的功能是由很多不同的类协作完成的，它们分布在MyBatis jar包的不同的package里面。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/68b1458fe3b7431c8abdd50a66c760f4.png" alt="image.png"></p><p>大概有一千多个类，这样看起来不够清楚，不知道什么类在什么环节工作，属于什么层次。MyBatis按照功能职责的不同，所有的package可以分成不同的工作层次。上面的那个图已经给大家展现了</p><h3 id="1-1-接口层"><a href="#1-1-接口层" class="headerlink" title="1.1 接口层"></a>1.1 接口层</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先接口层是我们打交道最多的。核心对象是SqlSession，它是上层应用和MyBatis打交道的桥梁，SqlSession上定义了非常多的对数据库的操作方法。接口层在接收到调用请求的时候，会调用核心处理层的相应模块来完成具体的数据库操作。</span><br></pre></td></tr></table></figure><h3 id="1-2-核心处理层"><a href="#1-2-核心处理层" class="headerlink" title="1.2 核心处理层"></a>1.2 核心处理层</h3><p>接下来是核心处理层。既然叫核心处理层，也就是跟数据库操作相关的动作都是在这一层完成的。</p><p>核心处理层主要做了这几件事：</p><ol><li>把接口中传入的参数解析并且映射成JDBC类型；</li><li>解析xml文件中的SQL语句，包括插入参数，和动态SQL的生成；</li><li>执行SQL语句；</li><li>处理结果集，并映射成Java对象。</li></ol><p>插件也属于核心层，这是由它的工作方式和拦截的对象决定的。</p><h3 id="1-3-基础支持层"><a href="#1-3-基础支持层" class="headerlink" title="1.3 基础支持层"></a>1.3 基础支持层</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后一个就是基础支持层。基础支持层主要是一些抽取出来的通用的功能（实现复用），用来支持核心处理层的功能。比如数据源、缓存、日志、<span class="built_in">xml</span>解析、反射、IO、事务等等这些功能，</span><br></pre></td></tr></table></figure><h2 id="2-核心流程"><a href="#2-核心流程" class="headerlink" title="2. 核心流程"></a>2. 核心流程</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析源码我们还是从编程式的Demo入手。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis getMapper 方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.selectUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们通过一个比较复杂的步骤实现了MyBatis的数据库查询操作。下面我们会按照这5个步骤来分析MyBatis的运行原理</span><br></pre></td></tr></table></figure><p><strong>第一步：资源配置文件的读取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>第二步：解析配置文件，完成SqlSessionFactory的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">// 通过建造者模式来 构建复杂的对象  1.完成配置文件的加载解析  2.完成SqlSessionFactory的创建</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br></pre></td></tr></table></figure><p>原理：要获取SqlSessionFactory的实例，通常需要先读取MyBatis配置文件（比如mybatis-config.xml），然后使用该配置文件中的信息来创建一个Configuration对象。Configuration对象包含了MyBatis的所有配置信息，并且具备解析映射文件、构建执行器等能力。接着，使用Configuration对象构建DefaultSqlSessionFactory类的实例，这个类实现了SqlSessionFactory接口，提供了默认的SqlSession实现方式并将其返回给调用者。</p><p>问题：SqlSessionFactory 的实例我们没有通过 DefaultSqlSessionFactory直接来获取？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory是一个顶级接口，它由DefaultSqlSessionFactory来实现</span><br></pre></td></tr></table></figure><p>主要原因：</p><ul><li>SqlSessionFactoryBuilder：用于解析 MyBatis 配置文件并构建出基本的 SqlSessionFactory 对象。</li><li>DefaultSqlSessionFactory：用于创建 SqlSession 对象，提供数据库操作的接口。</li></ul><p>所以为了职责不同，SqlSessionFactory 生产 SqlSession 对象的 SqlSessionFactory 应该是单例。<br>SqlSessionFactoryBuilder负责读取 MyBatis 配置文件和映射文件等资源，并将其解析为内存对象，最终生成 SqlSessionFactory 实例。也只需要在 系统启动的时候完成加载操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 `SqlSessionFactoryBuilder` 来从配置文件中构建 `SqlSessionFactory` 实例。</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的设计模式：建造者和工厂模式</p><p>所以前面这两步就是启动MyBatis，加载了配置文件，创建了一个SqlSessionFactory</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 在启动的时候会做哪些操作？</span><br><span class="line">   <span class="number">1</span>.加载全局配置文件</span><br><span class="line">   <span class="number">2</span>.加载映射文件</span><br><span class="line">   <span class="number">3</span>.加载的内容存储在了那个<span class="keyword">Java对象中？ </span>Configuration</span><br></pre></td></tr></table></figure><p><strong>第三步：根据SqlSessionFactory对象获取SqlSession对象</strong></p><p>程序每一次操作数据库，都需要创建一个全局会话，我们用openSession()方法来创建，执行器一般有简单，可复用的，批处理的。（SIMPLE（默认）,REUSE,BATCH）</p><p>真正干活的是我们的执行器，而openSession只是我们的一个对外接口。</p><p>获得事务工厂，那么得到我们的事务对象就很简单了，然后根据事务对象和执行器类型得到一个执行器。</p><p>总结：创建会话的过程，我们获得了一个DefaultSqlSession，里面包含了一个Executor，Executor是SQL的实际执行对象。</p><p><strong>第四步：sql的执行过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = </span><br><span class="line">    <span class="comment">//名称空间 + id 在mapper.xml里</span></span><br><span class="line">    sqlSession.selectList(<span class="string">&quot;com.zdw.mapper.UserMapper.selectUserList&quot;</span>);</span><br></pre></td></tr></table></figure><p>查询怎么查</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230331140344451.png" alt="image-20230331140344451"></p><p>一级缓存是session级别，二级缓存是进程级别</p><p>在浏览器发送一次请求里，如果是请求数据的话，在进程里面缓存是可能性非常大的，而一级缓存它是会话级别的，有可能请求时会话就已经断开了</p><blockquote><p>MyBatis使用二级缓存来提高查询性能。当查询语句执行时，MyBatis先检查是否开启了二级缓存，如果开启了则会先从二级缓存中查找是否有匹配的结果。如果有匹配的结果，则直接返回结果，否则继续执行查询并将结果存放到二级缓存中。</p><p>MyBatis优先选择二级缓存的原因是，相比于从数据库中进行查询，从缓存中获取数据可以大大提高查询性能和响应速度，避免频繁地访问数据库，减轻数据库的压力，并且在一定程度上保证数据的一致性。</p><p>因此，对于同一个SqlSession对象，在执行了一次查询后，再次查询相同的数据，是从缓存中取出来的，并没有发送SQL语句到数据库。</p><p>但是，如果使用了多个SqlSession对象，每个SqlSession都有自己的一级缓存，那么第二个SqlSession查询相同的数据并不会从第一个SqlSession的缓存中取出来，而是会发送SQL到数据库查询数据。所以，如果需要跨SqlSession对象共享缓存，可以使用MyBatis的二级缓存。</p></blockquote><p>真正从数据库查询的操作，进一步的对jdbc的封装</p><p>执行器到最后也是交给StatementHandler去处理，而这里就是对原生JDBC的封装</p><h3 id="2-1-核心对象的生命周期"><a href="#2-1-核心对象的生命周期" class="headerlink" title="2.1 核心对象的生命周期"></a>2.1 核心对象的生命周期</h3><h4 id="2-1-1-SqlSessionFactoryBuiler"><a href="#2-1-1-SqlSessionFactoryBuiler" class="headerlink" title="2.1.1 SqlSessionFactoryBuiler"></a>2.1.1 SqlSessionFactoryBuiler</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是SqlSessionFactoryBuiler。它是用来构建SqlSessionFactory的，而SqlSessionFactory只需要一个，所以只要构建了这一个SqlSessionFactory，它的使命就完成了，也就没有存在的意义了。所以它的生命周期只存在于方法的局部。</span><br></pre></td></tr></table></figure><h4 id="2-1-2-SqlSessionFactory"><a href="#2-1-2-SqlSessionFactory" class="headerlink" title="2.1.2 SqlSessionFactory"></a>2.1.2 SqlSessionFactory</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory是用来创建SqlSession的，每次应用程序访问数据库，都需要创建一个会话。因为我们一直有创建会话的需要，所以SqlSessionFactory应该存在于应用的整个生命周期中（作用域是应用作用域）。创建SqlSession只需要一个实例来做这件事就行了，否则会产生很多的混乱，和浪费资源。所以我们要采用单例模式。</span><br></pre></td></tr></table></figure><h4 id="2-1-3-SqlSession"><a href="#2-1-3-SqlSession" class="headerlink" title="2.1.3 SqlSession"></a>2.1.3 SqlSession</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession是一个会话，因为它不是线程安全的，不能在线程间共享。所以我们在请求开始的时候创建一个SqlSession对象，在请求结束或者说方法执行完毕的时候要及时关闭它（一次请求或者操作中）。</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Mapper"><a href="#2-1-4-Mapper" class="headerlink" title="2.1.4 Mapper"></a>2.1.4 Mapper</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapper（实际上是一个代理对象）是从SqlSession中获取的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>它的作用是发送SQL来操作数据库的数据。它应该在一个SqlSession事务方法之内。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/f53b812216e84dcb94c50f92671b429d.png" alt="image.png"></p><h3 id="2-2-SqlSessionFactory"><a href="#2-2-SqlSessionFactory" class="headerlink" title="2.2 SqlSessionFactory"></a>2.2 SqlSessionFactory</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331133249354.png" alt="image-20230331133249354">映射文件就是CRUD标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先我们来看下SqlSessionFactory对象的获取</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br></pre></td></tr></table></figure><h5 id="2-2-1-SqlSessionFactoryBuilder"><a href="#2-2-1-SqlSessionFactoryBuilder" class="headerlink" title="2.2.1 SqlSessionFactoryBuilder"></a>2.2.1 SqlSessionFactoryBuilder</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先我们<span class="keyword">new</span><span class="type"></span>了一个SqlSessionFactoryBuilder，这是建造者模式的运用（建造者模式用来创建复杂对象，而不需要关注内部细节，是一种封装的体现）。MyBatis中很多地方用到了建造者模式（名字以Builder结尾的类还有<span class="number">9</span>个）。</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder中用来创建SqlSessionFactory对象的方法是<span class="built_in">build</span>()，<span class="built_in">build</span>()方法有<span class="number">9</span>个重载，可以用不同的方式来创建SqlSessionFactory对象。SqlSessionFactory对象默认是单例的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 用于解析 mybatis-config.xml，同时创建了 Configuration 对象 &gt;&gt;</span></span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">    <span class="comment">// 解析XML，最终返回一个 DefaultSqlSessionFactory &gt;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">build</span>方法中首先是创建了一个XMLConfigBuilder对象，XMLConfigBuilder是抽象类BaseBuilder的一个子类，专门用来解析全局配置文件，针对不同的构建目标还有其他的一些子类（关联到源码路径），比如：</span><br></pre></td></tr></table></figure><ul><li>XMLMapperBuilder：解析Mapper映射器</li><li>XMLStatementBuilder：解析增删改查标签</li><li>XMLScriptBuilder：解析动态SQL</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后是执行了</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build(parser.parse());</span><br></pre></td></tr></table></figure><p>构建的代码，parser.parse()方法返回的是一个Configuration对象，build方法的如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这儿我们可以看到SessionFactory最终实现是DefaultSqlSessionFactory对象。</p><h4 id="2-2-2-XMLConfigBuilder"><a href="#2-2-2-XMLConfigBuilder" class="headerlink" title="2.2.2 XMLConfigBuilder"></a>2.2.2 XMLConfigBuilder</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们再来看下XMLConfigBuilder初始化的时候做了哪些操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> &#123;</span><br><span class="line">  <span class="comment">// EntityResolver的实现类是XMLMapperEntityResolver 来完成配置文件的校验，根据对应的DTD文件来实现</span></span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(inputStream, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再去进入重载的构造方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>()); <span class="comment">// 完成了Configuration的初始化</span></span><br><span class="line">  ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.configuration.setVariables(props); <span class="comment">// 设置对应的Properties属性</span></span><br><span class="line">  <span class="built_in">this</span>.parsed = <span class="literal">false</span>; <span class="comment">// 设置 是否解析的标志为 false</span></span><br><span class="line">  <span class="built_in">this</span>.environment = environment; <span class="comment">// 初始化environment</span></span><br><span class="line">  <span class="built_in">this</span>.parser = parser; <span class="comment">// 初始化 解析器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Configuration"><a href="#2-2-3-Configuration" class="headerlink" title="2.2.3 Configuration"></a>2.2.3 Configuration</h4><p>然后我们可以看下Configuration初始化做了什么操作</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/559d82906a7646e3838fc24858978e30.png" alt="image.png"></p><p>完成了类型别名的注册工作，通过上面的分析我们可以看到XMLConfigBuilder完成了XML文件的解析对应XPathParser和Configuration对象的初始化操作，然后我们再来看下parse方法到底是如何解析配置文件的</p><h4 id="2-2-4-parse解析"><a href="#2-2-4-parse解析" class="headerlink" title="2.2.4 parse解析"></a>2.2.4 parse解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.parse()</span><br></pre></td></tr></table></figure><p>进入具体的解析方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 检查是否已经解析过了</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// XPathParser，dom 和 SAX 都有用到 &gt;&gt;  开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseConfiguration方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//issue #117 read properties first</span></span><br><span class="line">    <span class="comment">// 对于全局配置文件各种标签的解析</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 settings 标签</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    <span class="comment">// 日志设置</span></span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    <span class="comment">// 类型别名</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    <span class="comment">// 用于创建对象</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 用于对对象进行加工</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 反射工具箱</span></span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">// 创建了数据源 &gt;&gt;</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析引用的Mapper映射器</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-4-1-全局配置文件解析"><a href="#2-2-4-1-全局配置文件解析" class="headerlink" title="2.2.4.1 全局配置文件解析"></a>2.2.4.1 全局配置文件解析</h5><p><strong>properties解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建了一个 Properties 对象，后面可以用到</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">defaults</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// url 和 resource 不能同时存在</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载resource或者url属性中指定的 properties 文件</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">vars</span> <span class="operator">=</span> configuration.getVariables();</span><br><span class="line">    <span class="keyword">if</span> (vars != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 和 Configuration中的 variables 属性合并</span></span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新对应的属性信息</span></span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个是解析\<properties>标签，读取我们引入的外部配置文件，例如db.properties。</properties></p><p>这里面又有两种类型，一种是放在resource目录下的，是相对路径，一种是写的绝对路径的（url）。</p><p>解析的最终结果就是我们会把所有的配置信息放到名为defaults的Properties对象里面（Hashtable对象，KV存储），最后把XPathParser和Configuration的Properties属性都设置成我们填充后的Properties对象。</p><p><strong>settings解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Properties <span class="title function_">settingsAsProperties</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取settings节点下的所有的子节点</span></span><br><span class="line">  <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">  <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">  <span class="type">MetaClass</span> <span class="variable">metaConfig</span> <span class="operator">=</span> MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The setting &quot;</span> + key + <span class="string">&quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getChildrenAsProperties方法就是具体的解析了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Properties <span class="title function_">getChildrenAsProperties</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  <span class="keyword">for</span> (XNode child : getChildren()) &#123;</span><br><span class="line">    <span class="comment">// 获取对应的name和value属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      properties.setProperty(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadCustomVfs(settings)方法</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadCustomVfs是获取Vitual <span class="keyword">File</span> <span class="keyword">System</span>的自定义实现类，比如要读取本地文件，或者FTP远程文件的时候，就可以用到自定义的VFS类。</span><br></pre></td></tr></table></figure><p>根据\<settings>标签里面的\<vfsImpl>标签，生成了一个抽象类VFS的子类，在MyBatis中有JBoss6VFS和DefaultVFS两个实现，在io包中。</vfsImpl></settings></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadCustomVfs</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;vfsImpl&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] clazzes = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String clazz : clazzes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!clazz.isEmpty()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt; vfsImpl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt;)Resources.classForName(clazz);</span><br><span class="line">        configuration.setVfsImpl(vfsImpl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后赋值到<span class="keyword">Configuration</span>中。</span><br></pre></td></tr></table></figure><p><strong>loadCustomLogImpl(settings)方法</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">load</span>CustomLogImpl是根据</span><br></pre></td></tr></table></figure><p>\<logImpl>标签获取日志的实现类，我们可以用到很多的日志的方案，包括LOG4J，LOG4J2，SLF4J等等，在logging包中。</logImpl></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadCustomLogImpl</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; logImpl = resolveClass(props.getProperty(<span class="string">&quot;logImpl&quot;</span>));</span><br><span class="line">  configuration.setLogImpl(logImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typeAliases解析</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一步是类型别名的解析</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeAliasesElement</span><span class="params">(XNode parent)</span> &#123;</span><br><span class="line">  <span class="comment">// 放入 TypeAliasRegistry</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeAliasPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;alias&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描 @Alias 注解使用</span></span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接注册</span></span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error registering typeAlias for &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>plugins解析</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件标签的解析</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 获取&lt;plugin&gt; 节点的 interceptor 属性的值</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取&lt;plugin&gt; 下的所有的properties子节点</span></span><br><span class="line">      <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 获取 Interceptor 对象</span></span><br><span class="line">      <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">      <span class="comment">// 设置 interceptor的 属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">// Configuration中记录 Interceptor</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件的具体使用后面专门介绍</p><p>objectFactory，objectWrapperFactory及reflectorFactory解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取&lt;objectFactory&gt; 节点的 type 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 &lt;objectFactory&gt; 节点下的配置信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 获取ObjectFactory 对象的对象 通过反射方式</span></span><br><span class="line">    <span class="type">ObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">// ObjectFactory 和 对应的属性信息关联</span></span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    <span class="comment">// 将创建的ObjectFactory对象绑定到Configuration中</span></span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectWrapperFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="type">ObjectWrapperFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reflectorFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="type">ReflectorFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFactory用来创建返回的对象。</p><p>ObjectWrapperFactory用来对对象做特殊的处理。比如：select没有写别名，查询返回的是一个Map，可以在自定义的objectWrapperFactory中把下划线命名变成驼峰命名。</p><p>ReflectorFactory是反射的工具箱，对反射的操作进行了封装（官网和文档没有这个对象的描述）。</p><p>以上四个对象，都是用resolveClass创建的。</p><p><strong>settingsElement(settings)方法</strong></p><p>这里就是对\<settings>标签里面所有子标签的处理了，前面我们已经把子标签全部转换成了Properties对象，所以在这里处理Properties对象就可以了。</settings></p><p>settings二级标签中一共26个配置，比如二级缓存、延迟加载、默认执行器类型等等。</p><p>需要注意的是，我们之前提到的所有的默认值，都是在这里赋值的。如果说后面我们不知道这个属性的值是什么，也可以到这一步来确认一下。</p><p>所有的值，都会赋值到Configuration的属性里面去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">settingsElement</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingBehavior&quot;</span>, <span class="string">&quot;PARTIAL&quot;</span>)));</span><br><span class="line">  configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span>, <span class="string">&quot;NONE&quot;</span>)));</span><br><span class="line">  configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;cacheEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">&quot;proxyFactory&quot;</span>)));</span><br><span class="line">  configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;lazyLoadingEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(<span class="string">&quot;aggressiveLazyLoading&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;multipleResultSetsEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setUseColumnLabel(booleanValueOf(props.getProperty(<span class="string">&quot;useColumnLabel&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(<span class="string">&quot;useGeneratedKeys&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(<span class="string">&quot;defaultExecutorType&quot;</span>, <span class="string">&quot;SIMPLE&quot;</span>)));</span><br><span class="line">  configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(<span class="string">&quot;defaultStatementTimeout&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">  configuration.setDefaultFetchSize(integerValueOf(props.getProperty(<span class="string">&quot;defaultFetchSize&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">  configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(<span class="string">&quot;defaultResultSetType&quot;</span>)));</span><br><span class="line">  configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeRowBoundsEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(<span class="string">&quot;localCacheScope&quot;</span>, <span class="string">&quot;SESSION&quot;</span>)));</span><br><span class="line">  configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(<span class="string">&quot;jdbcTypeForNull&quot;</span>, <span class="string">&quot;OTHER&quot;</span>)));</span><br><span class="line">  configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(<span class="string">&quot;lazyLoadTriggerMethods&quot;</span>), <span class="string">&quot;equals,clone,hashCode,toString&quot;</span>));</span><br><span class="line">  configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeResultHandlerEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(<span class="string">&quot;defaultScriptingLanguage&quot;</span>)));</span><br><span class="line">  configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(<span class="string">&quot;defaultEnumTypeHandler&quot;</span>)));</span><br><span class="line">  configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(<span class="string">&quot;callSettersOnNulls&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setUseActualParamName(booleanValueOf(props.getProperty(<span class="string">&quot;useActualParamName&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(<span class="string">&quot;returnInstanceForEmptyRow&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setLogPrefix(props.getProperty(<span class="string">&quot;logPrefix&quot;</span>));</span><br><span class="line">  configuration.setConfigurationFactory(resolveClass(props.getProperty(<span class="string">&quot;configurationFactory&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>environments解析</strong></p><p>这一步是解析\<environments>标签。</environments></p><p>我们前面讲过，一个environment就是对应一个数据源，所以在这里我们会根据配置的\<transactionManager>创建一个事务工厂，根据\<dataSource>标签创建一个数据源，最后把这两个对象设置成Environment对象的属性，放到Configuration里面。</dataSource></transactionManager></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        <span class="comment">// 事务工厂</span></span><br><span class="line">        <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">        <span class="comment">// 数据源工厂（例如 DruidDataSourceFactory ）</span></span><br><span class="line">        <span class="type">DataSourceFactory</span> <span class="variable">dsFactory</span> <span class="operator">=</span> dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">        <span class="comment">// 数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> dsFactory.getDataSource();</span><br><span class="line">        <span class="comment">// 包含了 事务工厂和数据源的 Environment</span></span><br><span class="line">        Environment.<span class="type">Builder</span> <span class="variable">environmentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">        <span class="comment">// 放入 Configuration</span></span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>databaseIdProviderElement()</strong></p><p>解析databaseIdProvider标签，生成DatabaseIdProvider对象（用来支持不同厂商的数据库）。</p><p><strong>typeHandlerElement()</strong></p><p>跟TypeAlias一样，TypeHandler有两种配置方式，一种是单独配置一个类，一种是指定一个package。最后我们得到的是JavaType和JdbcType，以及用来做相互映射的TypeHandler之间的映射关系，存放在TypeHandlerRegistry对象里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeHandlerElement</span><span class="params">(XNode parent)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeHandlerPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;javaType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jdbcTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;jdbcType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">        <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">        <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper解析</strong></p><p>最后就是\<mappers>标签的解析。</mappers></p><p>根据全局配置文件中不同的注册方式，用不同的方式扫描，但最终都是做了两件事情，对于语句的注册和接口的注册。</p><div class="table-container"><table><thead><tr><th>扫描类型</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>resource</td><td>相对路径</td></tr><tr><td>url</td><td>绝对路径</td></tr><tr><td>package</td><td>包</td></tr><tr><td>class</td><td>单个接口</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        &lt;mapper class=<span class="string">&quot;com.zdw.mapper.UserMapper&quot;</span> /&gt;--&gt; <span class="comment">//包路径</span></span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 不同的定义方式的扫描，最终都是调用 addMapper()方法（添加到 MapperRegistry）。这个方法和 getMapper() 对应</span></span><br><span class="line">      <span class="comment">// package包</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// resource相对路径</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">            <span class="comment">// 读取映射文件</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">// XMLMapperBuilder 解析映射文件</span></span><br><span class="line">          XMLMapperBuilder 解析 mapperParser = <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">// 解析 Mapper.xml，总体上做了两件事情 &gt;&gt; 往下看</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// url绝对路径</span></span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// class 单个接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始进入具体的配置文件的解析操作</p><h5 id="2-2-4-2-映射文件的解析"><a href="#2-2-4-2-映射文件的解析" class="headerlink" title="2.2.4.2 映射文件的解析"></a>2.2.4.2 映射文件的解析</h5><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先进入<span class="built_in">parse</span>方法，<span class="number">1</span>、对于语句注册和接口注册</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 总体上做了两件事情，对于语句的注册和接口的注册</span></span><br><span class="line">    <span class="comment">//判断是否加载过映射文件</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 1、具体增删改查标签的解析。</span></span><br><span class="line">    <span class="comment">// 一个标签一个MappedStatement。 &gt;&gt;</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 2、把namespace（接口类型）和工厂类绑定起来，放到一个map。</span></span><br><span class="line">    <span class="comment">// 一个namespace 一个 MapperProxyFactory &gt;&gt;</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configurationElement()——解析所有的子标签，最终获得MappedStatement对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.boge.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span></span><br><span class="line">        id,user_name,real_name,password,age,d_id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>bindMapperForNamespace()——把namespace（接口类型）和工厂类MapperProxyFactory绑定起来。</p><h6 id="configurationElement方法"><a href="#configurationElement方法" class="headerlink" title="configurationElement方法"></a><strong>configurationElement方法</strong></h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configurationElement是对Mapper.xml中所有具体的标签的解析，包括<span class="keyword">namespace</span>、<span class="symbol">cache</span>、<span class="symbol">parameterMap</span>、<span class="symbol">resultMap</span>、<span class="symbol">sql</span>和<span class="symbol">select</span>|<span class="symbol">insert</span>|<span class="symbol">update</span>|<span class="symbol">delete</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绑定名称空间</span></span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 添加缓存对象 如果希望多个名称空间共同使用同一个二级缓存就可以使用</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 cache 属性，添加缓存对象</span></span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建 ParameterMapping 对象 不推荐废弃了</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建 List&lt;ResultMapping&gt;</span></span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析可以复用的SQL</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析增删改查标签，得到 MappedStatement &gt;&gt;</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在buildStatementFromContext()方法中，创建了用来解析增删改查标签的XMLStatementBuilder，并且把创建的MappedStatement添加到mappedStatements中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">MappedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> statementBuilder.build();</span><br><span class="line">   <span class="comment">// 最关键的一步，在 Configuration 添加了 MappedStatement &gt;&gt;</span></span><br><span class="line">   configuration.addMappedStatement(statement);</span><br></pre></td></tr></table></figure><h6 id="bindMapperForNamespace方法"><a href="#bindMapperForNamespace方法" class="headerlink" title="bindMapperForNamespace方法"></a><strong>bindMapperForNamespace方法</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindMapperForNamespace</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> builderAssistant.getCurrentNamespace();</span><br><span class="line">  <span class="keyword">if</span> (namespace != <span class="literal">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; boundType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据名称空间加载对应的接口类型</span></span><br><span class="line">      boundType = Resources.classForName(namespace);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boundType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">        <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">        <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">        <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">        configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">        <span class="comment">// 添加到 MapperRegistry，本质是一个 map，里面也有 Configuration &gt;&gt;</span></span><br><span class="line">        configuration.addMapper(boundType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过源码分析发现主要是是调用了<span class="built_in">addMapper</span>()。<span class="built_in">addMapper</span>()方法中，把接口类型注册到MapperRegistry中：实际上是为接口创建一个对应的MapperProxyFactory（用于为这个type提供工厂类，创建MapperProxy）。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123; <span class="comment">// 检测 type 是否为接口</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123; <span class="comment">// 检测是否已经加装过该接口</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ！Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; 存放的是接口类型，和对应的工厂类的关系</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;&gt;(type));</span><br><span class="line">      <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册了接口之后，根据接口，开始解析所有方法上的注解，例如 @Select &gt;&gt;</span></span><br><span class="line">      <span class="type">MapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperAnnotationBuilder</span>(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的再进入parse方法中查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> type.toString();</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 先判断 Mapper.xml 有没有解析，没有的话先解析 Mapper.xml（例如定义 package 方式）</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    <span class="comment">// 处理 @CacheNamespace</span></span><br><span class="line">    parseCache();</span><br><span class="line">    <span class="comment">// 处理 @CacheNamespaceRef</span></span><br><span class="line">    parseCacheRef();</span><br><span class="line">    <span class="comment">// 获取所有方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// issue #237</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">// 解析方法上的注解，添加到 MappedStatement 集合中 &gt;&gt;</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">MethodResolver</span>(<span class="built_in">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以继续进入到parseStatement方法中查看。</p><p>总结：</p><ol><li>我们主要完成了config配置文件、Mapper文件、Mapper接口中注解的解析。</li><li>我们得到了一个最重要的对象Configuration，这里面存放了全部的配置信息，它在属性里面还有各种各样的容器。</li><li>最后，返回了一个DefaultSqlSessionFactory，里面持有了Configuration的实例。</li></ol><p>最后的时序图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/0ec80d74c1f546c08dd5e79eee31ff37.png" alt="image.png"></p><h3 id="2-3-SqlSession"><a href="#2-3-SqlSession" class="headerlink" title="2.3 SqlSession"></a>2.3 SqlSession</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331135531498.png" alt="image-20230331135531498"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序每一次操作数据库，都需要创建一个会话，我们用<span class="keyword">open</span><span class="constructor">Session()</span>方法来创建。接下来我们看看SqlSession创建过程中做了哪些操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过前面创建的DefaultSqlSessionFactory的openSession方法来创建</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会获取默认的执行器类型。默认的是simple</p><p><strong>继续往下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 创建事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们在解析environment标签的时候有创建TransactionFactory对象</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/a38daed1923a4eca86a46da0314346c0.png" alt="image.png"></p><p><strong>根据事务工厂和默认的执行器类型，创建执行器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      <span class="comment">//穿一件衣服-》装饰模式</span></span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后返回的是一个DefaultSqlSession对象</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/ec8d7ab5e6194cf4a6cc10ee303149f2.png" alt="image.png"></p><p>在这个DefaultSqlSession对象中包括了Configuration和Executor对象</p><p>总结：创建会话的过程，我们获得了一个DefaultSqlSession，里面包含了一个Executor，Executor是SQL的实际执行对象。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/96fdcffdb1e54f4f8fb72a84133b7f26.png" alt="image.png"></p><h3 id="2-4-Mapper代理对象"><a href="#2-4-Mapper代理对象" class="headerlink" title="2.4 Mapper代理对象"></a>2.4 Mapper代理对象</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来看下通过getMapper方法获取对应的接口的代理对象的实现原理</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>进入DefaultSqlSession中查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="comment">// mapperRegistry中注册的有Mapper的相关信息 在解析映射文件时 调用过addMapper方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入getMapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Mapper接口对应的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取Mapper接口对应的 MapperProxyFactory 对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入newInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实现了 mapperInterface 接口的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">  <span class="comment">// 1：类加载器:2：被代理类实现的接口、3：实现了 InvocationHandler 的触发管理类</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们在代码中发现代理对象是通过JDK动态代理创建，返回的代理对象。而且里面也传递了一个实现了InvocationHandler接口的触发管理类。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/61cfbb435a3f41c397683c15cbe4a81a.png" alt="image.png"></p><p>总结：获得Mapper对象的过程，实质上是获取了一个JDK动态代理对象（类型是$ProxyN）。这个代理类会继承Proxy类，实现被代理的接口，里面持有了一个MapperProxy类型的触发管理类。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/99732f0f96dc44f4b463a1eb9c469d1b.png" alt="image.png"></p><h3 id="2-5-SQL执行"><a href="#2-5-SQL执行" class="headerlink" title="2.5 SQL执行"></a>2.5 SQL执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们看看<span class="keyword">SQL</span>语句的具体执行过程是怎么样的</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = mapper.selectUserList();</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于所有的Mapper都是JDK动态代理对象，所以任意的方法都是执行触发管理类MapperProxy的<span class="built_in">invoke</span>()方法</span><br></pre></td></tr></table></figure><h4 id="2-5-1-MapperProxy-invoke"><a href="#2-5-1-MapperProxy-invoke" class="headerlink" title="2.5.1 MapperProxy.invoke()"></a>2.5.1 MapperProxy.invoke()</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们直接进入到<span class="keyword">invoke</span>方法中</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // toString hashCode equals getClass等方法，无需走到执行SQL的流程</span><br><span class="line">   <span class="built_in"> if </span>(Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">     <span class="built_in"> return </span>method.invoke(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的<span class="built_in"> invoke</span></span><br><span class="line"><span class="built_in"></span>      // 普通方法会走到 PlainMethodInvoker（内部类） 的<span class="built_in"> invoke</span></span><br><span class="line"><span class="built_in"></span>     <span class="built_in"> return </span>cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">   <span class="built_in"> throw </span>ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入到PlainMethodInvoker的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">// SQL执行的真正起点</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-mapperMethod-execute"><a href="#2-5-2-mapperMethod-execute" class="headerlink" title="2.5.2 mapperMethod.execute()"></a>2.5.2 mapperMethod.execute()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123; <span class="comment">// 根据SQL语句的类型调用SqlSession对应的方法</span></span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 通过 ParamNameResolver 处理args[] 数组 将用户传入的实参和指定参数名称关联起来</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      <span class="comment">// sqlSession.insert(command.getName(), param) 调用SqlSession的insert方法</span></span><br><span class="line">      <span class="comment">// rowCountResult 方法会根据 method 字段中记录的方法的返回值类型对结果进行转换</span></span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        <span class="comment">// 返回值为空 且 ResultSet通过 ResultHandler处理的方法</span></span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值为 单一对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        <span class="comment">// 普通 select 语句的执行入口 &gt;&gt;</span></span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == <span class="literal">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">          result = Optional.ofNullable(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">        + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这一步，根据不同的type（INSERT、UPDATE、DELETE、SELECT）和返回类型：</p><p>1）调用convertArgsToSqlCommandParam()将方法参数转换为SQL的参数。</p><p>2）调用sqlSession的insert()、update()、delete()、selectOne ()方法。我们以查询为例，会走到selectOne()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure><h4 id="2-5-3-sqlSession-selectOne"><a href="#2-5-3-sqlSession-selectOne" class="headerlink" title="2.5.3 sqlSession.selectOne"></a>2.5.3 sqlSession.selectOne</h4><p>这里来到了对外的接口的默认实现类DefaultSqlSession。</p><p>selectOne()最终也是调用了selectList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 来到了 DefaultSqlSession</span></span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SelectList()中，我们先根据command name（Statement ID）从Configuration中拿到MappedStatement。ms里面有xml中增删改查标签配置的所有属性，包括id、statementType、sqlSource、useCache、入参、出参等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 如果 cacheEnabled = true（默认），Executor会被 CachingExecutor装饰</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行了Executor的query()方法。</p><p>Executor是第二步openSession的时候创建的，创建了执行器基本类型之后，依次执行了二级缓存装饰，和插件包装。</p><p>所以，如果有被插件包装，这里会先走到插件的逻辑。如果没有显式地在settings中配置cacheEnabled=false，再走到CachingExecutor的逻辑，然后会走到BaseExecutor的query()方法。</p><h4 id="2-5-4-CachingExecutor-query"><a href="#2-5-4-CachingExecutor-query" class="headerlink" title="2.5.4 CachingExecutor.query()"></a>2.5.4 CachingExecutor.query()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 获取SQL</span></span><br><span class="line">  <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span></span><br><span class="line">  <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的CacheKey是怎么构成的呢？或者说，什么样的查询才能确定是同一个查询呢？</p><p>在BaseExecutor的createCacheKey方法中，用到了六个要素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cacheKey.update(ms.getId()); <span class="comment">// com.msb.mapper.BlogMapper.selectBlogById</span></span><br><span class="line">cacheKey.update(rowBounds.getOffset()); <span class="comment">// 0</span></span><br><span class="line">cacheKey.update(rowBounds.getLimit()); <span class="comment">// 2147483647 = 2^31-1</span></span><br><span class="line">cacheKey.update(boundSql.getSql());</span><br><span class="line">cacheKey.update(value);</span><br><span class="line">cacheKey.update(configuration.getEnvironment().getId());</span><br></pre></td></tr></table></figure><p>也就是说，方法相同、翻页偏移相同、SQL相同、参数值相同、数据源环境相同，才会被认为是同一个查询。</p><p>CacheKey的实际值举例（toString()生成的），debug可以看到：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1381545870:4796102018:com.msb.mapper.BlogMapper.selectBlogById:0:2147483647:select * from blog where bid = ?:1:development</span><br></pre></td></tr></table></figure><p>注意看一下CacheKey的属性，里面有一个List按顺序存放了这些要素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MULTIPLIER</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HASHCODE</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> multiplier;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> hashcode;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> checksum;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> <span class="keyword">private</span> List&lt;Object&gt; updateList</span><br></pre></td></tr></table></figure><p>怎么比较两个CacheKey是否相等呢？如果一上来就是依次比较六个要素是否相等，要比较6次，这样效率不高。有没有更高效的方法呢？继承Object的每个类，都有一个hashCode ()方法，用来生成哈希码。它是用来在集合中快速判重的。</p><p>在生成CacheKey的时候（update方法），也更新了CacheKey的hashCode，它是用乘法哈希生成的（基数baseHashCode=17，乘法因子multiplier=37）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcode = multiplier * hashcode + baseHashCode;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span>中的<span class="built_in">hashCode</span>()是一个本地方法，通过随机数算法生成（OpenJDK8 ，默认，可以通过-XX<span class="selector-pseudo">:has</span>hCode修改）。CacheKey中的<span class="built_in">hashCode</span>()方法进行了重写，返回自己生成的hashCode。</span><br></pre></td></tr></table></figure><p>为什么要用37作为乘法因子呢？跟String中的31类似。</p><p>CacheKey中的equals也进行了重写，比较CacheKey是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span> == object) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (CacheKey) object;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">thisObject</span> <span class="operator">=</span> updateList.get(i);</span><br><span class="line">     <span class="type">Object</span> <span class="variable">thatObject</span> <span class="operator">=</span> cacheKey.updateList.get(i);</span><br><span class="line">     <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果哈希值（乘法哈希）、校验值（加法哈希）、要素个数任何一个不相等，都不是同一个查询，最后才循环比较要素，防止哈希碰撞。</p><p>CacheKey生成之后，调用另一个query()方法。</p><h4 id="2-5-5-BaseExecutor-query方法"><a href="#2-5-5-BaseExecutor-query方法" class="headerlink" title="2.5.5 BaseExecutor.query方法"></a>2.5.5 BaseExecutor.query方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">  <span class="comment">// cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span></span><br><span class="line">  <span class="comment">// 由 &lt;cache&gt; 标签决定</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// flushCache=&quot;true&quot; 清空一级二级缓存 &gt;&gt;</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="comment">// 获取二级缓存</span></span><br><span class="line">      <span class="comment">// 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 写入二级缓存</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span></span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 异常体系之 ErrorContext</span></span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// flushCache=&quot;true&quot;时，即使是查询，也清空一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 防止递归查询重复处理缓存</span></span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 查询一级缓存</span></span><br><span class="line">    <span class="comment">// ResultHandler 和 ResultSetHandler的区别</span></span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 真正的查询流程</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">// 先占位</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 三种 Executor 的区别，看doUpdate</span></span><br><span class="line">    <span class="comment">// 默认Simple</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 移除占位符</span></span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入一级缓存</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-6-SimpleExecutor-doQuery方法"><a href="#2-5-6-SimpleExecutor-doQuery方法" class="headerlink" title="2.5.6 SimpleExecutor.doQuery方法"></a>2.5.6 SimpleExecutor.doQuery方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 获取一个 Statement对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 用完就关闭</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在configuration.<span class="keyword">new</span><span class="type">StatementHandler</span>()中，<span class="keyword">new</span><span class="type"></span>一个StatementHandler，先得到RoutingStatementHandler。</span><br></pre></td></tr></table></figure><p>RoutingStatementHandler里面没有任何的实现，是用来创建基本的StatementHandler的。这里会根据MappedStatement里面的statementType决定StatementHandler的类型。默认是PREPARED（STATEMENT、PREPARED、CALLABLE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType=&quot;PREPARED&quot;，默认值 PREPARED</span></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">SimpleStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      <span class="comment">// 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span></span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">PreparedStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">CallableStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatementHandler里面包含了处理参数的ParameterHandler和处理结果集的ResultSetHandler。</p><p>这两个对象都是在上面new的时候创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  <span class="built_in">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">  <span class="built_in">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  <span class="built_in">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (boundSql == <span class="literal">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了四大对象的其它两大对象 &gt;&gt;</span></span><br><span class="line">  <span class="comment">// 创建这两大对象的时候分别做了什么？</span></span><br><span class="line">  <span class="built_in">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="built_in">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这三个对象都是可以被插件拦截的四大对象之一，所以在创建之后都要用拦截器进行包装的方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ParameterHandler <span class="title function_">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">ParameterHandler</span> <span class="variable">parameterHandler</span> <span class="operator">=</span> mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ResultSetHandler <span class="title function_">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span><br><span class="line"><span class="params">    ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">ResultSetHandler</span> <span class="variable">resultSetHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultSetHandler</span>(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> StatementHandler <span class="title function_">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingStatementHandler</span>(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建Statement</strong></p><p>用new出来的StatementHandler创建Statement对象。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/2ebb88356cf347ad835ee7f9ec97f0e9.png" alt="image.png"></p><p><strong>执行查询操作,如果有插件包装，会先走到被拦截的业务逻辑。</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="keyword">handler</span>.<span class="title">query</span><span class="params">(stmt, resultHandler)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>进入到PreparedStatementHandler中处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">    <span class="comment">// 到了JDBC的流程</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">// 处理结果集</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行PreparedStatement的execute()方法，后面就是JDBC包中的PreparedStatement的执行了。</strong><br><strong>ResultSetHandler处理结果集，如果有插件包装，会先走到被拦截的业务逻辑。</strong></p><p><strong>总结：调用代理对象执行SQL操作的流程</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/f5e29e9810c444df970c45e802d3ad23.png" alt="image.png"></p><h3 id="2-6-MyBatis核心对象"><a href="#2-6-MyBatis核心对象" class="headerlink" title="2.6 MyBatis核心对象"></a>2.6 MyBatis核心对象</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331144755674.png" alt="image-20230331144755674"></p><div class="table-container"><table><thead><tr><th><strong>对象</strong></th><th>相关对象</th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>Configuration</td><td>MapperRegistry<br>TypeAliasRegistry<br>TypeHandlerRegistry</td><td>包含了MyBatis的所有的配置信息</td></tr><tr><td>SqlSession</td><td>SqlSessionFactory<br>DefaultSqlSession</td><td>对操作数据库的增删改查的API进行了封装，提供给应用层使用</td></tr><tr><td>Executor</td><td>BaseExecutor<br>SimpleExecutor<br>BatchExecutor<br>ReuseExecutor</td><td>MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</td></tr><tr><td>StatementHandler</td><td>BaseStatementHandler<br>SimpleStatementHandler<br>PreparedStatementHandler<br>CallableStatementHandler</td><td>封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</td></tr><tr><td>ParameterHandler</td><td>DefaultParameterHandler</td><td>把用户传递的参数转换成JDBC Statement 所需要的参数</td></tr><tr><td>ResultSetHandler</td><td>DefaultResultSetHandler</td><td>把JDBC返回的ResultSet结果集对象转换成List类型的集合</td></tr><tr><td>MapperProxy</td><td>MapperProxyFactory</td><td>触发管理类，用于代理Mapper接口方法</td></tr><tr><td>MappedStatement</td><td>SqlSource<br>BoundSql</td><td>MappedStatement维护了一条&lt;select\</td><td>update\</td><td>delete\</td><td>insert&gt;节点的封装，表示一条SQL包括了SQL信息、入参信息、出参信息</td></tr></tbody></table></div><blockquote><p><strong>看源码的注意事项</strong></p><ol><li>一定要带着问题去看，猜想验证。</li><li>不要只记忆流程，学编程风格，设计思想（他的代码为什么这么写？如果不这么写呢？包括接口的定义，类的职责，涉及模式的应用，高级语法等等）。</li><li>先抓重点，就像开车熟路，哪个地方限速，哪个地方变道，要走很多次。先走主干道，再去、覆盖分支小路。</li><li>记录核心流程和对象，总结层次、结构、关系，输出（图片或者待注释的源码）。</li><li>培养看源码的信心和感觉，从带着看到自己去看，看更多的源码。</li><li>debug还是直接Ctrl+Alt+B跟方法？debug可以看到实际的值，比如到底是哪个实现类，value到底是什么。但是Ctrl+Alt+B不一定能走到真正的对象，比如有代理或者父类方法，或者多个实现的时候。熟悉流程之后，直接跟方法。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis核心工作原理讲解&quot;&gt;&lt;a href=&quot;#MyBatis核心工作原理讲解&quot; class=&quot;headerlink&quot; title=&quot;MyBatis核心工作原理讲解&quot;&gt;&lt;/a&gt;MyBatis核心工作原理讲解&lt;/h1&gt;&lt;h1 id=&quot;一、MyBatis源码分析</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis最佳实践</title>
    <link href="https://eizo01.github.io/posts/eced4617.html"/>
    <id>https://eizo01.github.io/posts/eced4617.html</id>
    <published>2022-12-04T12:00:00.000Z</published>
    <updated>2023-04-16T14:02:11.835Z</updated>
    
    <content type="html"><![CDATA[<h1>MyBatis最佳实践</h1><h2 id="1-动态SQL语句">1.动态SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态 <span class="keyword">SQL</span> 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 <span class="keyword">SQL</span> 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 <span class="keyword">SQL</span>，可以彻底摆脱这种痛苦。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用动态 <span class="keyword">SQL</span> 并非一件易事，但借助可用于任何 <span class="keyword">SQL</span> 映射语句中的强大的动态 <span class="keyword">SQL</span> 语言，MyBatis 显著地提升了这一特性的易用性。</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你之前用过 JSTL 或任何基于类 <span class="keyword">XML</span> <span class="title">语言的文本处理器，你对动态 SQL</span> 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis <span class="number">3</span> 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</span><br></pre></td></tr></table></figure><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h3 id="1-1-if">1.1 if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要判断的时候，条件写在<span class="built_in">test</span>中</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">            and user_name = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-choose">1.2 choose</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要选择一个条件的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- choose 的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;userName != null and userName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_name like CONCAT(CONCAT(&#x27;%&#x27;,#&#123;userName,jdbcType=VARCHAR&#125;),&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-trim">1.3 trim</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要去掉<span class="keyword">where</span>、<span class="keyword">and</span>、逗号之类的符号的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    trim 的使用</span></span><br><span class="line"><span class="comment">    替代where标签的使用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListTrim&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;where&gt;</span></span><br><span class="line"><span class="comment">        &lt;if test=&quot;username!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">            and name = #&#123;username&#125;</span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">    &lt;/where&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null&quot;</span>&gt;</span></span><br><span class="line">            and user_name = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 替代set标签的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    update t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null&quot;</span>&gt;</span></span><br><span class="line">            user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-foreach">1.4 foreach</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要遍历集合的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user </span><br><span class="line">     where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">         #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color:red">动态SQL主要是用来解决SQL语句生成的问题。</span></p><h2 id="2-批量操作">2.批量操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在项目中会有一些批量操作的场景，比如导入文件批量处理数据的情况（批量新增商户、批量修改商户信息），当数据量非常大，比如超过几万条的时候，在Java代码中循环发送<span class="keyword">SQL</span>到数据库执行肯定是不现实的，因为这个意味着要跟数据库创建几万次会话。即使在同一个连接中，也有重复编译和执行<span class="keyword">SQL</span>的开销。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如循环插入10000条（大约耗时3秒钟）：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Batch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.获取配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">        session = factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环插入10000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">            mapper.insertUser(user);</span><br><span class="line">         &#125;</span><br><span class="line">         session.commit();</span><br><span class="line">         session.close();</span><br><span class="line">         <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">         System.out.println(<span class="string">&quot;循环批量插入&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="variable">MyBatis</span>里面是支持批量的操作的，包括批量的插入、更新、删除。我们可以直接传入一个<span class="built_in">List</span>、<span class="built_in">Set</span>、<span class="built_in">Map</span>或者数组，配合动态<span class="variable">SQL</span>的标签，<span class="variable">MyBatis</span>会自动帮我们生成语法正确的<span class="variable">SQL</span>语句。</span><br></pre></td></tr></table></figure><h3 id="2-1-批量插入">2.1 批量插入</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">批量插入的语法是这样的，只要在<span class="built_in">values</span>后面增加插入的值就可以了。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_emp (emp_id, emp_name, gender,email, d_id) <span class="keyword">values</span> ( ?,?,?,?,? ),( ?,?,?,?,? ),( ?,?,?,?,? )</span><br></pre></td></tr></table></figure><p>在Mapper文件里面，我们使用foreach标签拼接 values部分的语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量插入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUserList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span> &gt;</span></span><br><span class="line">    insert into t_user(user_name,real_name)</span><br><span class="line">    values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;user.userName&#125;,#&#123;user.realName&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java代码里面，直接传入一个List类型的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    mapper.insertUserList(list);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;循环批量插入&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入一万条大约耗时1秒钟。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到，动态<span class="keyword">SQL</span>批量插入效率要比循环发送<span class="keyword">SQL</span>执行要高得多。最关键的地方就在于减少了跟数据库交互的次数，并且避免了开启和结束事务的时间消耗。</span><br></pre></td></tr></table></figure><h3 id="2-2-批量更新">2.2 批量更新</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">批量更新的语法是这样的，通过<span class="keyword">case</span> <span class="keyword">when</span>，来匹<span class="built_in">配id</span>相关的字段值</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> </span><br><span class="line">user_name <span class="operator">=</span> </span><br><span class="line"><span class="keyword">case</span> id </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> ,</span><br><span class="line">real_name <span class="operator">=</span> </span><br><span class="line"><span class="keyword">case</span> id</span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> ( ? , ? , ? )</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以在Mapper文件里面最关键的就是<span class="keyword">case</span> <span class="keyword">when</span>和<span class="keyword">where</span>的配置。</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要注意一下open属性和separator属性。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserList&quot;</span>&gt;</span></span><br><span class="line"> update t_user set</span><br><span class="line">    user_name =</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span> <span class="attr">open</span>=<span class="string">&quot;case id&quot;</span> <span class="attr">close</span>=<span class="string">&quot;end&quot;</span>&gt;</span></span><br><span class="line">    when #&#123;user.id&#125; then #&#123;user.userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">     ,real_name =</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span> <span class="attr">open</span>=<span class="string">&quot;case id&quot;</span> <span class="attr">close</span>=<span class="string">&quot;end&quot;</span>&gt;</span></span><br><span class="line">      when #&#123;user.id&#125; then #&#123;user.realName&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">     where id in</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">      #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(i);</span><br><span class="line">        user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    mapper.updateUserList(list);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;批量更新&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-批量删除">2.3 批量删除</h3><p>批量删除也是类似的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-BatchExecutor">2.4 BatchExecutor</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然MyBatis的动态标签的批量操作也是存在一定的缺点的，比如数据量特别大的时候，拼接出来的<span class="keyword">SQL</span>语句过大。</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MySQL</span>的服务端对于接收的数据包有大小限制，max_allowed_packet 默认是 <span class="number">4</span>M，需要修改默认配置或者手动地控制条数，才可以解决这个问题。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.PacketTooBigException: Packet <span class="keyword">for</span> query is too <span class="title function_">large</span> <span class="params">(<span class="number">7188967</span> &gt; <span class="number">4194304</span>)</span>. You can change <span class="built_in">this</span> value on the server by setting the max_allowed_packet<span class="string">&#x27; variable.</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们的全局配置文件中，可以配置默认的Executor的类型（默认是SIMPLE）。其中有一种BatchExecutor。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在创建会话的时候指定执行器类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br></pre></td></tr></table></figure><p><strong>Executor</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/a01141b547b3498f81bb8509c81ddbe6.png" alt="image.png"></p><ol><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。executeUpdate()是一个语句访问一次数据库，executeBatch()是一批语句访问一次数据库（具体一批发送多少条SQL跟服务端的max_allowed_packet有关）。BatchExecutor底层是对JDBC ps.addBatch()和ps. executeBatch()的封装。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?rewriteBatchedStatements=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">       ps = conn.prepareStatement(</span><br><span class="line">               <span class="string">&quot;INSERT into blog values (?, ?, ?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">101000</span>; i++) &#123;</span><br><span class="line">           <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blog</span>();</span><br><span class="line">           ps.setInt(<span class="number">1</span>, i);</span><br><span class="line">           ps.setString(<span class="number">2</span>, String.valueOf(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           ps.setInt(<span class="number">3</span>, <span class="number">1001</span>);</span><br><span class="line">           ps.addBatch();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       ps.executeBatch();</span><br><span class="line">       ps.close();</span><br><span class="line">       conn.close();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">       se.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException se2) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-关联查询">3.关联查询</h2><h3 id="3-1-嵌套查询">3.1 嵌套查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在查询业务数据的时候经常会遇到关联查询的情况，比如查询员工就会关联部门（一对一），查询学生成绩就会关联课程（一对一），查询订单就会关联商品（一对多），等等。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户和部门的对应关系是1对1的关系</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌套查询 1对1 1个用户对应一个部门--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserNested&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap1&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            t1.`id`</span><br><span class="line">            ,t1.`user_name`</span><br><span class="line">            ,t1.`real_name`</span><br><span class="line">            ,t1.`password`</span><br><span class="line">            ,t1.`age`</span><br><span class="line">            ,t2.`did`</span><br><span class="line">            ,t2.`d_name`</span><br><span class="line">            ,t2.`d_desc`</span><br><span class="line">        FROM t_user t1</span><br><span class="line">        LEFT JOIN</span><br><span class="line">            t_department t2</span><br><span class="line">            ON t1.`d_id` = t2.`did`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有就是1对多的关联关系，嵌套查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌套查询 1对多 1个部门有多个用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptNested&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap2&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            t1.`id`</span><br><span class="line">            ,t1.`user_name`</span><br><span class="line">            ,t1.`real_name`</span><br><span class="line">            ,t1.`password`</span><br><span class="line">            ,t1.`age`</span><br><span class="line">            ,t2.`did`</span><br><span class="line">            ,t2.`d_name`</span><br><span class="line">            ,t2.`d_desc`</span><br><span class="line">        FROM t_user t1</span><br><span class="line">        RIGHT JOIN</span><br><span class="line">            t_department t2</span><br><span class="line">            ON t1.`d_id` = t2.`did`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-延迟加载">3.2 延迟加载</h3><p>在MyBatis里面可以通过开启延迟加载的开关来解决这个问题。</p><p>在settings标签里面可以配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。默认false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;proxyFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CGLIB&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>lazyLoadingEnabled决定了是否延迟加载（默认false）。</p><p>aggressiveLazyLoading决定了是不是对象的所有方法都会触发查询。</p><p>1对1的延迟加载配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 延迟加载 1对1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap1Lazy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;queryDeptByUserIdLazy&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserNestedLazy&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap1Lazy&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        t1.`id`</span><br><span class="line">        ,t1.`user_name`</span><br><span class="line">        ,t1.`real_name`</span><br><span class="line">        ,t1.`password`</span><br><span class="line">        ,t1.`age`</span><br><span class="line">        ,t1.d_id</span><br><span class="line">    FROM t_user t1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptByUserIdLazy&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseDept&quot;</span>&gt;</span></span><br><span class="line">    select * from t_department where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：开启了延迟加载的开关，调用user.getDept()以及默认的（equals,clone,hashCode,toString）时才会发起第二次查询，其他方法并不会触发查询，比如blog.getName()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1对1  关联查询 延迟加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.queryUserNestedLazy();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user.getUserName() );</span><br><span class="line">        <span class="comment">//System.out.println(user.getUserName() + &quot;----&gt;&quot;+user.getDept());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发延迟加载的方法可以通过&lt;lazyLoadTriggerMethods&gt;配置，默认equals(),clone(),hashCode(),toString()。</p><p>1对多的延迟加载的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1对多 延迟加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap2Lazy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">select</span>=<span class="string">&quot;queryUserByDeptLazy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptNestedLazy&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap2&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        ,t2.`did`</span><br><span class="line">        ,t2.`d_name`</span><br><span class="line">        ,t2.`d_desc`</span><br><span class="line">    FROM</span><br><span class="line">        t_department t2</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByDeptLazy&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select * from t_user where d_id = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-分页操作">4.分页操作</h2><h3 id="4-1-逻辑分页">4.1 逻辑分页</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis里面有一个逻辑分页对象RowBounds，里面主要有两个属性，<span class="keyword">offset</span>和<span class="keyword">limit</span>（从第几条开始，查询多少条）。我们可以在Mapper接口的方法上加上这个参数，不需要修改<span class="type">xml</span>里面的<span class="keyword">SQL</span>语句。</span><br></pre></td></tr></table></figure><p>接口中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserList</span><span class="params">(RowBounds rowBounds)</span>;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 设置分页的数据</span></span><br><span class="line">    <span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    List&lt;User&gt; users = mapper.queryUserList(rowBounds);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RowBounds的工作原理其实是对ResultSet的处理。它会舍弃掉前面<span class="keyword">offset</span>条数据，然后再取剩下的数据的<span class="keyword">limit</span>条。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>();</span><br><span class="line">   <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> rsw.getResultSet();</span><br><span class="line">   <span class="built_in">this</span>.skipRows(resultSet, rowBounds);</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">this</span>.shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">       <span class="type">ResultMap</span> <span class="variable">discriminatedResultMap</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveDiscriminatedResultMap(resultSet, resultMap, (String)<span class="literal">null</span>);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> <span class="built_in">this</span>.getRowValue(rsw, discriminatedResultMap, (String)<span class="literal">null</span>);</span><br><span class="line">       <span class="built_in">this</span>.storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，如果数据量大的话，这种翻页方式效率会很低（跟查询到内存中再使用subList(start,end)没什么区别）。所以我们要用到物理翻页。</p><h3 id="4-2-物理分页">4.2 物理分页</h3><p>物理翻页是真正的翻页，它是通过数据库支持的语句来翻页。</p><p>第一种简单的办法就是传入参数（或者包装一个page对象），在SQL语句中翻页。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserPage&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">  select * from t_user limit #&#123;curIndex&#125; , #&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一个问题是我们要在Java业务代码里面去计算起止序号；第二个问题是：每个需要翻页的Statement都要编写limit语句，会造成Mapper映射器里面很多代码冗余。</p><p>那我们就需要一种通用的方式，不需要去修改配置的任何一条SQL语句，我们只要传入当前是第几页，每页多少条就可以了，自动计算出来起止序号。</p><p>我们最常用的做法就是使用翻页的插件，比如PageHelper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageSize每一页几条</span></span><br><span class="line">PageHelper.startPage(pn, <span class="number">10</span>);</span><br><span class="line">List&lt;Employee&gt; emps = employeeService.getAll();</span><br><span class="line"><span class="comment">// navigatePages 导航页码数</span></span><br><span class="line"><span class="type">PageInfo</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInfo</span>(emps, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> Msg.success().add(<span class="string">&quot;pageInfo&quot;</span>, page);</span><br></pre></td></tr></table></figure><p>PageHelper是通过MyBatis的拦截器实现的，插件的具体原理我们后面的课再分析。简单地来说，它会根据PageHelper的参数，改写我们的SQL语句。比如MySQL会生成limit语句，Oracle会生成rownum语句，SQL Server会生成top语句。</p><h2 id="5-MBG与Example">5.MBG与Example</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mybatis/g</span>enerator</span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在项目中使用MyBaits的时候，针对需要操作的一张表，需要创建实体类、Mapper映射器、Mapper接口，里面又有很多的字段和方法的配置，这部分的工作是非常繁琐的。而大部分时候我们对于表的基本操作是相同的，比如根据主键查询、根据<span class="built_in">Map</span>查询、单条插入、批量插入、根据主键删除等等等等。当我们的表很多的时候，意味着有大量的重复工作。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以有没有一种办法，可以根据我们的表，自动生成实体类、Mapper映射器、Mapper接口，里面包含了我们需要用到的这些基本方法和<span class="keyword">SQL</span>呢？</span><br></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis也提供了一个代码生成器，叫做MyBatis <span class="built_in">Generator</span>，简称MBG（它是MyBatis的一个插件）。我们只需要修改一个配置文件，使用相关的jar包命令或者Java代码就可以帮助我们生成实体类、映射器和接口文件。</span><br></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MBG的配置文件里面有一个<span class="keyword">Example</span>的开关，这个东西用来构造复杂的筛选条件的，换句话说就是根据我们的代码去生成<span class="keyword">where</span>条件。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理：在实体类中包含了两个有继承关系的Criteria，用其中自动生成的方法来构建查询条件。把这个包含了Criteria的实体类作为参数传到查询参数中，在解析Mapper映射器的时候会转换成<span class="keyword">SQL</span>条件。</span><br></pre></td></tr></table></figure><h3 id="5-1-添加配置文件">5.1 添加配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们添加如下的配置文件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库的驱动包路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;C:\Users\dpb\.m2\repository\mysql\mysql-connector-java\8.0.11\mysql-connector-java-8.0.11.jar&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 去掉生成文件中的注释 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库链接URL、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot;</span></span><br><span class="line"><span class="comment">              connectionURL=&quot;jdbc:oracle:thin:@localhost:1521:XE&quot;</span></span><br><span class="line"><span class="comment">              userId=&quot;car&quot;</span></span><br><span class="line"><span class="comment">              password=&quot;car&quot;&gt;</span></span><br><span class="line"><span class="comment">      &lt;/jdbcConnection&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成模型的包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.domain&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否在当前路径下新加一层schema,eg：fase路径com.oop.eksp.user.model， true:com.oop.eksp.user.model.[schemaName] --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的映射文件包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成DAO的包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">&quot;t_user&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;User&quot;</span>   /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-添加插件">5.2 添加插件</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们需要在pom.<span class="built_in">xml</span>中添加对应的插件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-生成">5.3 生成</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们就可以利用插件帮助我们快速生成我们需要的表结构对应的相关文件</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/31e53fbe324044ad90e09d5256518ba3.png" alt="image.png"></p><p>有springboot配置类的方式生成！</p><h2 id="6-通用Mapper">6. 通用Mapper</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：当我们的表字段发生变化的时候，我们需要修改实体类和Mapper文件定义的字段和方法。如果是增量维护，那么一个个文件去修改。如果是全量替换，我们还要去对比用MBG生成的文件。字段变动一次就要修改一次，维护起来非常麻烦。</span><br></pre></td></tr></table></figure><h3 id="6-1-方式一">6.1 方式一</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个，因为MyBatis的Mapper是支持继承的（见：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mybatis/my</span>batis-<span class="number">3</span><span class="regexp">/issues/</span><span class="number">35</span>）。所以我们可以把我们的Mapper.xml和Mapper接口都分成两个文件。一个是MBG生成的，这部分是固定不变的。然后创建DAO类继承生成的接口，变化的部分就在DAO里面维护。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapperExt</span> <span class="keyword">extends</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUserByName</span><span class="params">(String userName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.boge.vip.mapper.UserMapperExt&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMapExt&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.vip.domain.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;i_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;iId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMapExt&quot;</span> &gt;</span></span><br><span class="line">    select * from t_user where user_name = #&#123;userName&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在全局配置文件中我们也需要扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapperExt.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以以后只要修改Ext的文件就可以了。这么做有一个缺点，就是文件会增多。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/9b8ab56ac56746938c1ce5836f7c6c18.png" alt="image.png"></p><h3 id="6-2-方式二">6.2 方式二</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">既然针对每张表生成的基本方法都是一样的，也就是公共的方法部分代码都是一样的，我们能不能把这部分合并成一个文件，让它支持泛型呢？</span><br></pre></td></tr></table></figure><p>当然可以！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个支持泛型的通用接口，比如叫GPBaseMapper</span><br></pre></td></tr></table></figure><p><T>，把实体类作为参数传入。这个接口里面定义了大量的增删改查的基础方法，这些方法都是支持泛型的。</T></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义的Mapper接口继承该通用接口，例如<span class="keyword">BlogMapper </span><span class="keyword">extends </span>GPBaseMapper</span><br></pre></td></tr></table></figure><p><Blog>，自动获得对实体类的操作方法。遇到没有的方法，我们依然可以在我们自己的Mapper里面编写。</Blog></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们能想到的解决方案，早就有人做了这个事了，这个东西就叫做通用Mapper。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/abel533/Mapper/wiki">https://github.com/abel533/Mapper/wiki</a></p><p>用途：主要解决单表的增删改查问题，并不适用于多表关联查询的场景。</p><p>除了配置文件变动的问题之外，通用Mapper还可以解决：</p><ol><li>每个Mapper接口中大量的重复方法的定义；</li><li>屏蔽数据库的差异；</li><li>提供批量操作的方法；</li><li>实现分页。</li></ol><p>使用方式：在Spring中使用时，引入jar包，替换applicationContext.xml中的sqlSessionFactory和configure。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.boge.crud.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-MyBatis-Plus">7.MyBatis-Plus</h2><p><a href="https://mybatis.plus/guide">https://mybatis.plus/guide</a></p><p>MyBatis-Plus是原生MyBatis的一个增强工具，可以在使用原生MyBatis的所有功能的基础上，使用plus特有的功能。</p><p>MyBatis-Plus的核心功能：</p><p><strong>通用 CRUD</strong>：定义好Mapper接口后，只需要继承BaseMapper<T> 接口即可获得通用的增删改查功能，无需编写任何接口方法与配置文件。</T></p><p><strong>条件构造器</strong>：通过EntityWrapper<T>（实体包装类），可以用于拼接 SQL 语句，并且支持排序、分组查询等复杂的SQL。</T></p><p><strong>代码生成器</strong>：支持一系列的策略配置与全局配置，比MyBatis的代码生成更好用。</p><p>另外MyBatis-Plus也有分页的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MyBatis最佳实践&lt;/h1&gt;
&lt;h2 id=&quot;1-动态SQL语句&quot;&gt;1.动态SQL语句&lt;/h2&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门</title>
    <link href="https://eizo01.github.io/posts/4658a061.html"/>
    <id>https://eizo01.github.io/posts/4658a061.html</id>
    <published>2022-12-02T12:00:00.000Z</published>
    <updated>2023-04-16T14:02:10.111Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MyBatis的介绍</h1><p>官网地址：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p><p>推荐一个网站：<a href="http://www.mybatis.cn/archives/789.html">http://www.mybatis.cn/archives/789.html</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 <span class="keyword">JDBC </span>代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 <span class="keyword">Java </span>POJO（Plain Old <span class="keyword">Java </span>Objects，普通老式 <span class="keyword">Java </span>对象）为数据库中的记录。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“半自动”的ORM框架能够很好的解决上面所讲的Hibernate的几个问题，半自动化”是相对于Hibernate的全自动化来说的。它的封装程度没有Hibernate那么高，不会自动生成全部的<span class="keyword">SQL</span>语句，主要解决的是<span class="keyword">SQL</span>和对象的映射问题。</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis的前身是ibatis，<span class="number">2001</span>年开始开发，是“internet”和“abatis [&#x27;æbətɪs]（障碍物）”两个单词的组合。04年捐赠给Apache。<span class="number">2010</span>年更名为MyBatis。</span><br></pre></td></tr></table></figure><p>在MyBatis里面，SQL和代码是分离的，所以会写SQL基本上就会用MyBatis，没有额外的学习成本。</p><h1>二、MyBatis使用</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们就通过实际的案例代码来演示下MyBatis的具体使用。</span><br></pre></td></tr></table></figure><h2 id="1-环境准备">1. 环境准备</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们先来搭建MyBatis的使用环境</span><br></pre></td></tr></table></figure><h3 id="1-1-创建项目">1.1 创建项目</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个普通的Maven项目，然后添加对应的Mybatis和MySQL的相关依赖</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-POJO对象">1.2 POJO对象</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的案例通过数据库中的 T_USER 表来讲解，创建的对应的POJO对象为,有用到Lombok，大家可以自行添加对应的依赖</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer dId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-添加配置文件">1.3 添加配置文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis中我们需要添加全局的配置文件和对应的映射文件。</span><br><span class="line">默认名字：mybatis-config.xml</span><br></pre></td></tr></table></figure><p>全局配置文件,这里面是对MyBatis的核心行为的控制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印查询语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- STATEMENT级别的缓存，使一级缓存，只针对当前执行的这一statement有效 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zdw.domain.User&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关联的映射文件,通常来说一张表对应一个，我们会在这个里面配置我们增删改查的SQL语句，以及参数和返回的结果集的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zdw.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- $只能用在自定义类型和map上 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByBean&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user where user_name = &#x27;$&#123;userName&#125;&#x27;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库属性的配置文件一并贴出 db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h2 id="2-编程式的使用">2. 编程式的使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境准备好后我们就可以来使用其帮助我们实现数据库的操作了。在MyBatis中的使用方式有两种，首先来看下第一种编程式的方式</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis API 的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;com.zdw.mapper.UserMapper.selectUserList&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了执行效果</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230330164348963.png" alt="image-20230330164348963"></p><p>这种方式其实就是通过SqlSession中给我们提供的相关的API方法来执行对应的CRUD操作，查找我们写的SQL语句是通过 namespace+“.”+id的方式实现的</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/b027e8acea894748ad6f4d68abf34feb.png" alt="image.png"></p><p>这样的调用方式，解决了重复代码、资源管理、SQL耦合、结果集映射这4大问题。</p><p>不过，这样的调用方式还是会存在一些问题：</p><ol><li>Statement ID是硬编码，维护起来很不方便；</li><li>不能在编译时进行类型检查，如果namespace或者Statement ID输错了，只能在运行的时候报错。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以我们通常会使用第二种方式，也是新版的MyBatis里面推荐的方式：定义一个Mapper接口的方式。这个接口全路径必须跟Mapper.xml里面的<span class="keyword">namespace</span>对应起来，方法也要跟<span class="symbol">Statement</span> <span class="symbol">ID</span>一一对应。</span><br></pre></td></tr></table></figure><h2 id="3-代理方式的使用">3. 代理方式的使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们还可以通过SqlSession中提供的getMapper方法来获取声明接口的代理对象来处理。实现如下</span><br></pre></td></tr></table></figure><h3 id="3-1-接口声明">3.1 接口声明</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们需要声明一个Dao的接口。然后在接口中定义相关的方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dao 的接口声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-映射文件">3.2 映射文件</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们通过getMapper的方式来使用的话，我们需要添加对应的映射文件，在映射文件中我们需要将<span class="keyword">namespace</span>声明为上面接口的全类路径名，同时对应的<span class="symbol">sql</span>标签的<span class="symbol">id</span>要和方法名称一致。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/6ca7a8099bf1466e9e5596b664d18b1d.png" alt="image.png"></p><p>最后我们还有保证映射文件的名称和接口的名称要一致。在文件很多的情况能很好的管理</p><h3 id="3-3-getMapper">3.3 getMapper</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后我们在通过getMapper方法来获取声明的Dao接口的代码对象来实现数据库操作。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis getMapper 方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.selectUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过执行接口方法，来执行映射器中的<span class="keyword">SQL</span>语句。</span><br></pre></td></tr></table></figure><p>最后总结下MyBatis的特点：</p><ol><li>使用连接池对连接进行管理</li><li>SQL和代码分离，集中管理</li><li>结果集映射</li><li>参数映射和动态SQL</li><li>重复SQL的提取</li><li>缓存管理</li><li>插件机制</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate和MyBatis跟DbUtils、Spring JDBC一样，都是对JDBC的一个封装，我们去看源码，最后一定会看到<span class="keyword">Connection</span>、<span class="keyword">Statement</span>和ResultSet这些对象。对应的选择</span><br></pre></td></tr></table></figure><ol><li>在一些业务比较简单的项目中，我们可以使用Hibernate；</li><li>如果需要更加灵活的SQL，可以使用MyBatis，对于底层的编码，或者性能要求非常高的场合，可以用JDBC；</li><li>实际上在我们的项目中，MyBatis和Spring JDBC是可以混合使用的；</li><li>当然，我们也根据项目的需求自己写ORM框架。</li></ol><h1>三、MyBatis核心配置</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis中我们发现其实他最核心的应该是那两个配置文件，一个全局配置文件，一个映射文件。我们只要把这两个文件弄清楚，其实对于MyBatis的使用就掌握了大部分。接下来我们详细的给大家来介绍下这两个配置文件</span><br></pre></td></tr></table></figure><h2 id="1-全局配置文件">1.全局配置文件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MyBatis</span> 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。他们是有先序顺序的，配置文档的顶层结构如下：</span><br></pre></td></tr></table></figure><blockquote><ul><li>configuration（配置）</li><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ul></blockquote><h3 id="1-1-configuration">1.1 configuration</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configuration</span>是整个配置文件的根标签，实际上也对应着MyBatis里面最重要的配置类<span class="keyword">Configuration</span>。它贯穿MyBatis执行流程的每一个环节。我们打开这个类看一下，这里面有很多的属性，跟其他的子标签也能对应上。</span><br></pre></td></tr></table></figure><h3 id="1-2-properties">1.2 properties</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个一级标签是<span class="keyword">properties</span>，用来配置参数信息，比如最常见的数据库连接信息。</span><br></pre></td></tr></table></figure><p>为了避免直接把参数写死在xml配置文件中，我们可以把这些参数单独放在properties文件中，用properties标签引入进来，然后在xml配置文件中用${}引用就可以了。可以用resource引用应用里面的相对路径，也可以用url指定本地服务器或者网络的绝对路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入一个属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-settings">1.3 settings</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。</span><br></pre></td></tr></table></figure><table><thead><tr><th>设置参数</th><th style="text-align:left">描述</th><th style="text-align:left">有效值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td style="text-align:left">全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>lazyLoadingEnabled</td><td style="text-align:left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>aggressiveLazyLoading</td><td style="text-align:left">当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考lazyLoadTriggerMethods).</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>multipleResultSetsEnabled</td><td style="text-align:left">是否允许单一语句返回多结果集（需要兼容驱动）。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>useColumnLabel</td><td style="text-align:left">使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>useGeneratedKeys</td><td style="text-align:left">允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>autoMappingBehavior</td><td style="text-align:left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td style="text-align:left">NONE, PARTIAL, FULL</td><td style="text-align:left">PARTIAL</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td style="text-align:left">指定发现自动映射目标未知列（或者未知属性类型）的行为。 NONE: 不做任何反应WARNING: 输出提醒日志(‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN) FAILING: 映射失败 (抛出 SqlSessionException)</td><td style="text-align:left">NONE, WARNING, FAILING</td><td style="text-align:left">NONE</td></tr><tr><td>defaultExecutorType</td><td style="text-align:left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td style="text-align:left">SIMPLE REUSE BATCH</td><td style="text-align:left">SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td style="text-align:left">设置超时时间，它决定驱动等待数据库响应的秒数。</td><td style="text-align:left">任意正整数</td><td style="text-align:left">Not Set (null)</td></tr><tr><td>defaultFetchSize</td><td style="text-align:left">为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。</td><td style="text-align:left">任意正整数</td><td style="text-align:left">Not Set (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td style="text-align:left">允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>safeResultHandlerEnabled</td><td style="text-align:left">允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>mapUnderscoreToCamelCase</td><td style="text-align:left">是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td style="text-align:left">true| false</td><td style="text-align:left">False</td></tr><tr><td>localCacheScope</td><td style="text-align:left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td style="text-align:left">SESSION| STATEMENT</td><td style="text-align:left">SESSION</td></tr><tr><td>jdbcTypeForNull</td><td style="text-align:left">当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td><td style="text-align:left">JdbcType 常量. 大多都为: NULL, VARCHAR and OTHER</td><td style="text-align:left">OTHER</td></tr><tr><td>lazyLoadTriggerMethods</td><td style="text-align:left">指定哪个对象的方法触发一次延迟加载。</td><td style="text-align:left">用逗号分隔的方法列表。</td><td style="text-align:left">equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td style="text-align:left">指定动态 SQL 生成的默认语言。</td><td style="text-align:left">一个类型别名或完全限定类名。</td><td style="text-align:left">org.apache.ibatis.scripting.xmltags.XMLLanguageDriver</td></tr><tr><td>defaultEnumTypeHandler</td><td style="text-align:left">指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始) 一个类型别名或完全限定类名。</td><td style="text-align:left">org.apache.ibatis.type.EnumTypeHandler</td><td style="text-align:left"></td></tr><tr><td>callSettersOnNulls</td><td style="text-align:left">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</td><td style="text-align:left">true| false</td><td style="text-align:left">false</td></tr><tr><td>returnInstanceForEmptyRow</td><td style="text-align:left">当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始）</td><td style="text-align:left">true| false</td><td style="text-align:left">false</td></tr><tr><td>logPrefix</td><td style="text-align:left">指定 MyBatis 增加到日志名称的前缀。</td><td style="text-align:left">任何字符串</td><td style="text-align:left">Not set</td></tr><tr><td>logImpl</td><td style="text-align:left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td style="text-align:left">SLF4J</td><td style="text-align:left">LOG4J| LOG4J2 | JDK_LOGGING | COMMONS_LOGGING\</td></tr><tr><td>proxyFactory</td><td style="text-align:left">指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</td><td style="text-align:left">CGLIB\</td><td style="text-align:left">JAVASSIST</td></tr><tr><td>vfsImpl</td><td style="text-align:left">指定VFS的实现</td><td style="text-align:left">自定义VFS的实现的类全限定名，以逗号分隔。</td><td style="text-align:left">Not set</td></tr><tr><td>useActualParamName</td><td style="text-align:left">允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的工程必须采用Java 8编译，并且加上-parameters选项。（从3.4.1开始）</td><td style="text-align:left">true| false</td><td style="text-align:left">true</td></tr><tr><td>configurationFactory</td><td style="text-align:left">指定一个提供Configuration实例的类。 这个被返回的Configuration实例用来加载被反序列化对象的懒加载属性值。 这个类必须包含一个签名方法static Configuration getConfiguration(). (从 3.2.3 版本开始)</td><td style="text-align:left">类型别名或者全类名.</td><td style="text-align:left">Not set</td></tr></tbody></table><p>设置的案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打印查询语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- STATEMENT级别的缓存，使一级缓存，只针对当前执行的这一statement有效 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-typeAliases">1.4 typeAliases</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeAlias是类型的别名，跟Linux系统里面的<span class="built_in">alias</span>一样，主要用来简化类名全路径的拼写。比如我们的参数类型和返回值类型都可能会用到我们的Bean，如果每个地方都配置全路径的话，那么内容就比较多，还可能会写错。</span><br></pre></td></tr></table></figure><p>我们可以为自己的Bean创建别名，既可以指定单个类，也可以指定一个package，自动转换。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.domain.User&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在使用的时候我们就可以简化了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/ec167bbe0a78409aa6904b5dbbba4e3e.png" alt="image.png"></p><p>MyBatis里面有很多系统预先定义好的类型别名，在TypeAliasRegistry中。所以可以用string代替java.lang.String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TypeAliasRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">  registerAlias(<span class="string">&quot;string&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;byte&quot;</span>, Byte.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;long&quot;</span>, Long.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;short&quot;</span>, Short.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;int&quot;</span>, Integer.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;integer&quot;</span>, Integer.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;double&quot;</span>, Double.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;float&quot;</span>, Float.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;boolean&quot;</span>, Boolean.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;byte[]&quot;</span>, Byte[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;long[]&quot;</span>, Long[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;short[]&quot;</span>, Short[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;int[]&quot;</span>, Integer[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;integer[]&quot;</span>, Integer[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;double[]&quot;</span>, Double[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;float[]&quot;</span>, Float[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;boolean[]&quot;</span>, Boolean[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;_byte&quot;</span>, <span class="type">byte</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_long&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_short&quot;</span>, <span class="type">short</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_int&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_integer&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_double&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_float&quot;</span>, <span class="type">float</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_boolean&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;_byte[]&quot;</span>, <span class="type">byte</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_long[]&quot;</span>, <span class="type">long</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_short[]&quot;</span>, <span class="type">short</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_int[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_integer[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_double[]&quot;</span>, <span class="type">double</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_float[]&quot;</span>, <span class="type">float</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_boolean[]&quot;</span>, <span class="type">boolean</span>[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;date&quot;</span>, Date.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;decimal&quot;</span>, BigDecimal.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;bigdecimal&quot;</span>, BigDecimal.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;biginteger&quot;</span>, BigInteger.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;object&quot;</span>, Object.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;date[]&quot;</span>, Date[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;decimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;bigdecimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;biginteger[]&quot;</span>, BigInteger[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;object[]&quot;</span>, Object[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;map&quot;</span>, Map.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;hashmap&quot;</span>, HashMap.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;list&quot;</span>, List.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;arraylist&quot;</span>, ArrayList.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;collection&quot;</span>, Collection.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;iterator&quot;</span>, Iterator.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;ResultSet&quot;</span>, ResultSet.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-TypeHandler">1.5 TypeHandler</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于Java类型和数据库的JDBC类型不是一一对应的（比如<span class="type">String</span>与varchar、<span class="type">char</span>、text），所以我们把Java对象转换为数据库的值，和把数据库的值转换成Java对象，需要经过一定的转换，这两个方向的转换就要用到TypeHandler。</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当参数类型和返回值是一个对象的时候，我没有做任何的配置，为什么对象里面的一个<span class="type">String</span>属性，可以转换成数据库里面的varchar字段？</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是因为<span class="type">MyBatis</span>已经内置了很多<span class="type">TypeHandler</span>（在<span class="keyword">type</span>包下），它们全部全部注册在<span class="type">TypeHandlerRegistry</span>中，他们都继承了抽象类<span class="type">BaseTypeHandler</span>，泛型就是要处理的<span class="type">Java</span>数据类型。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个也是为什么大部分类型都不需要处理。当我们查询数据和登记数据，做数据类型转换的时候，就会自动调用对应的TypeHandler的方法。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/7645fcdfbdcf4ca1b1749ab2ad12f5cb.png" alt="image.png"></p><p>我们可以自定义一个TypeHandler来帮助我们简单的处理数据，比如查询的结果的字段如果是一个字符串，且值为&quot;zhangsan&quot;就修饰下这个信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类型处理器</span></span><br><span class="line"><span class="comment"> *    处理的字段如果是 String类型的话就 且 内容是 zhangsan 拼接个信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeHandler</span>  <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据的时候回调的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jdbcType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------setNonNullParameter1：&quot;</span>+parameter);</span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnName);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时将我们的处理器在全局配置文件中注册下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.boge.type.MyTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在映射文件中配置对应的处理器</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/f16ae2441126453da41dffbd9c5dda98.png" alt="image.png"></p><h3 id="1-6-objectFactory">1.6 objectFactory</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们把数据库返回的结果集转换为实体类的时候，需要创建对象的实例，由于我们不知道需要处理的类型是什么，有哪些属性，所以不能用<span class="keyword">new</span><span class="type"></span>的方式去创建。只能通过反射来创建。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis里面，它提供了一个工厂类的接口，叫做ObjectFactory，专门用来创建对象的实例（MyBatis封装之后，简化了对象的创建），里面定义了4个方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span>;</span><br><span class="line">  &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isCollection</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>void</strong> setProperties(Properties properties);</td><td>设置参数时调用</td></tr><tr><td><T> T create(Class<T> type);</T></T></td><td>创建对象（调用无参构造函数）</td></tr><tr><td><T> T create(Class<T> type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List<Object> constructorArgs);</Object></T></T></td><td>创建对象（调用带参数构造函数）</td></tr><tr><td><T> <strong>boolean</strong> isCollection(Class<T> type)</T></T></td><td>判断是否集合</td></tr></tbody></table><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory有一个默认的实现类DefaultObjectFactory。创建对象的方法最终都调用了<span class="built_in">instantiateClass</span>()，这里面能看到反射的代码。</span><br></pre></td></tr></table></figure><p>默认情况下，所有的对象都是由DefaultObjectFactory创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.boge.objectfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.boge.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.factory.DefaultObjectFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义ObjectFactory，通过反射的方式实例化对象</span></span><br><span class="line"><span class="comment"> * 一种是无参构造函数，一种是有参构造函数——第一个方法调用了第二个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">(Class type)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建对象方法：&quot;</span> + type);</span><br><span class="line">        <span class="keyword">if</span> (type.equals(User.class)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">blog</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.create(type);</span><br><span class="line">            blog.setUserName(<span class="string">&quot;object factory&quot;</span>);</span><br><span class="line">            blog.setId(<span class="number">1111</span>);</span><br><span class="line">            blog.setRealName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> blog;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.create(type);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObjectFactory</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">myBlog</span> <span class="operator">=</span> (User) factory.create(User.class);</span><br><span class="line">        System.out.println(myBlog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在config文件里面注册，在创建对象的时候会被自动调用：</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.objectfactory.MyObjectFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;boge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样，就可以让MyBatis的创建实体类的时候使用我们自己的对象工厂。</span><br></pre></td></tr></table></figure><h3 id="1-7-plugins">1.7 plugins</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件是MyBatis的一个很强大的机制。跟很多其他的框架一样，MyBatis预留了插件的接口，让MyBatis更容易扩展。</span><br></pre></td></tr></table></figure><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins</a></p><h3 id="1-8-environments">1.8 environments</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environments标签用来管理数据库的环境，比如我们可以有开发环境、测试环境、生产环境的数据库。可以在不同的环境中使用不同的数据库地址或者类型。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span><span class="comment">&lt;!--unPOOLED 不用连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些别名都在configuration</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230330171020089.png" alt="image-20230330171020089"></p><p><strong>environment</strong></p><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个<span class="built_in">environment</span>标签就是一个数据源，代表一个数据库。这里面有两个关键的标签，一个是事务管理器，一个是数据源。</span><br></pre></td></tr></table></figure><p><strong>transactionManager</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果配置的是JDBC，则会使用Connection对象的<span class="built_in">commit</span>()、<span class="built_in">rollback</span>()、<span class="built_in">close</span>()管理事务。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果配置成MANAGED，会把事务交给容器来管理，比如JBOSS，Weblogic。因为我们跑的是本地程序，如果配置成MANAGE不会有任何事务。</span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是Spring + MyBatis，则没有必要配置，因为我们会直接在applicationContext.<span class="built_in">xml</span>里面配置数据源和事务，覆盖MyBatis的配置。</span><br></pre></td></tr></table></figure><p><strong>dataSource</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据源，顾名思义，就是数据的来源，一个数据源就对应一个数据库。在Java里面，它是对数据库连接的一个抽象。</span><br></pre></td></tr></table></figure><p>一般的数据源都会包括连接池管理的功能，所以很多时候也把DataSource直接 称为连接池，准确的说法应该是：带连接池功能的数据源。</p><h3 id="1-9-mappers">1.9 mappers</h3><p>&lt;mappers&gt;标签配置的是映射器，也就是Mapper.xml的路径。这里配置的目的是让MyBatis在启动的时候去扫描这些映射器，创建映射关系。</p><p>我们有四种指定Mapper文件的方式：</p><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers">http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers</a></p><p>a.使用相对于类路径的资源引用（resource）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.使用完全限定资源定位符（绝对路径）（URL）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;file:///app/sale/mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c.使用映射器接口实现类的完全限定类名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.boge.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>d.将包内的映射器接口实现全部注册为映射器（最常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.boge.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-映射文件">2. 映射文件</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 <span class="keyword">XML</span> <span class="title">文件就显得相对简单。如果拿它跟具有相同功能的 JDBC</span> 代码进行对比，你会立即发现省掉了将近 <span class="number">95</span>% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</span><br></pre></td></tr></table></figure><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><h3 id="2-1-cache">2.1 cache</h3><p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：<cache></cache></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定命名空间的缓存配置（是否开启二级缓存）。</span><br><span class="line">使用自定义缓存：可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。</span><br><span class="line">&lt;<span class="keyword">cache</span> <span class="keyword">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-cache-ref">2.2 cache-ref</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其他命名空间缓存配置的引用。缓存相关两个标签在缓存组件模块的时候会使用到。</span><br><span class="line">目前很少使用</span><br></pre></td></tr></table></figure><h3 id="2-3-resultMap">2.3 resultMap</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie<span class="symbol">&#x27;g</span>是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;CHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-sql">2.4 sql</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可被其他语句引用的可重用语句块。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">emp_id, emp_name, gender, email, d_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-增删改查标签">2.5 增删改查标签</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对常用的增删改查操作提供的有对应的标签来处理</span><br></pre></td></tr></table></figure><p>&lt;insert&gt; – 映射插入语句</p><p>&lt;update&gt; – 映射更新语句</p><p>&lt;delete&gt; – 映射删除语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag"> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">parameterMap</span>=<span class="string">&quot;deprecated&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultMap</span>=<span class="string">&quot;personResultMap&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">timeout</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">fetchSize</span>=<span class="string">&quot;256&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultSetType</span>=<span class="string">&quot;FORWARD_ONLY&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td style="text-align:left"><code>parameterType</code></td><td style="text-align:left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td style="text-align:left"><code>parameterMap</code></td><td style="text-align:left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td></tr><tr><td style="text-align:left"><code>resultType</code></td><td style="text-align:left">期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td style="text-align:left"><code>resultMap</code></td><td style="text-align:left">对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td style="text-align:left"><code>flushCache</code></td><td style="text-align:left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr><tr><td style="text-align:left"><code>useCache</code></td><td style="text-align:left">将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td style="text-align:left"><code>timeout</code></td><td style="text-align:left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td style="text-align:left"><code>fetchSize</code></td><td style="text-align:left">这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td style="text-align:left"><code>statementType</code></td><td style="text-align:left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td style="text-align:left"><code>resultSetType</code></td><td style="text-align:left">FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td></tr><tr><td style="text-align:left"><code>databaseId</code></td><td style="text-align:left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr><tr><td style="text-align:left"><code>resultOrdered</code></td><td style="text-align:left">这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td></tr><tr><td style="text-align:left"><code>resultSets</code></td><td style="text-align:left">这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、MyBatis的介绍&lt;/h1&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/index.html&quot;&gt;https://mybatis.org/mybatis-3/zh/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>ORM框架的发展历程</title>
    <link href="https://eizo01.github.io/posts/6b5152eb.html"/>
    <id>https://eizo01.github.io/posts/6b5152eb.html</id>
    <published>2022-12-01T10:19:03.000Z</published>
    <updated>2023-04-16T14:02:07.186Z</updated>
    
    <content type="html"><![CDATA[<h1>一、ORM框架的发展历程</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/c8fb12ecffb042fea929ce1fb4b9029a.png" alt="image.png"><br>从面向sql编程到面向对象编程。</p><h2 id="1-JDBC操作">1. JDBC操作</h2><h3 id="1-1-JDBC操作的特点">1.1 JDBC操作的特点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最初的时候我们肯定是直接通过jdbc来直接操作数据库的，本地数据库我们有一张student表，那么我们的操作流程是</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接</span></span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from student where id = 1&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">major</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;major&quot;</span>);</span><br><span class="line"></span><br><span class="line">    student.setId(id);</span><br><span class="line">    student.setName(name);</span><br><span class="line">    student.setMajor(major);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的操作步骤是，首先在pom.xml中引入MySQL的驱动依赖，注意MySQL数据库的版本</p><ol><li>Class.forName注册驱动</li><li>获取一个Connection对象</li><li>创建一个Statement对象</li><li>execute()方法执行SQL语句，获取ResultSet结果集</li><li>通过ResultSet结果集给POJO的属性赋值</li><li>最后关闭相关的资源</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种实现方式首先给我们的感觉就是操作步骤比较繁琐，在复杂的业务场景中会更麻烦。尤其是我们需要自己来维护管理资源的连接，如果忘记了，就很可能造成数据库服务连接耗尽。同时我们还能看到具体业务的<span class="keyword">SQL</span>语句直接在代码中写死耦合性增强。每个连接都会经历这几个步骤，重复代码很多，总结上面的操作的特点：</span><br></pre></td></tr></table></figure><ol><li>代码重复</li><li>资源管理</li><li>结果集处理</li><li>SQL耦合</li></ol><p>针对这些问题我们可以把公共的部分提取出来</p><h3 id="1-2-JDBC优化1-0">1.2 JDBC优化1.0</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对常规jdbc操作的特点，我们可以先从代码重复和资源管理方面来优化，我们可以创建一个工具类来专门处理这个问题</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_NAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供获取数据库连接的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn = DriverManager.getConnection(JDBC_URL,JDBC_NAME,JDBC_PASSWORD);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn )</span>&#123;</span><br><span class="line">        close(conn,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts )</span>&#123;</span><br><span class="line">        close(conn,sts,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts , ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sts != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sts.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的jdbc操作代码可以简化如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 通过JDBC查询用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">           <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 打开连接</span></span><br><span class="line">           conn = DBUtils.getConnection();</span><br><span class="line">           <span class="comment">// 执行查询</span></span><br><span class="line">           stmt = conn.createStatement();</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from student where id = 1&quot;</span>;</span><br><span class="line">           rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取结果集</span></span><br><span class="line">           <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">               <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">major</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;major&quot;</span>);</span><br><span class="line"></span><br><span class="line">               student.setId(id);</span><br><span class="line">               student.setName(userName);</span><br><span class="line">               student.setMajor(major);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               System.out.println(student);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           DBUtils.close(conn,stmt,rs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过JDBC实现添加用户信息的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 打开连接</span></span><br><span class="line">           conn = DBUtils.getConnection();</span><br><span class="line">           <span class="comment">// 执行查询</span></span><br><span class="line">           stmt = conn.createStatement();</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student(name,major)values(&#x27;李四&#x27;,&#x27;管理学&#x27;)&quot;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">           System.out.println(<span class="string">&quot;影响的行数:&quot;</span> + i);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           DBUtils.close(conn,stmt);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但是整体的操作步骤还是会显得比较复杂，这时我们可以进一步优化</p><h3 id="1-3-JDBC优化2-0">1.3 JDBC优化2.0</h3><p>我们可以针对DML操作的方法来优化，先解决SQL耦合的问题，在DBUtils中添加封装DML操作的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行数据库的DML操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">update</span><span class="params">(String sql,Object ... paramter)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(paramter != <span class="literal">null</span> &amp;&amp; paramter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,paramter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    close(conn,ps);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在DML操作的时候我们就可以简化为如下步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过JDBC实现添加用户信息的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student(name,major)values(?,?)&quot;</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           DBUtils.update(sql,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;数学&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>显然这种方式会比最初的使用要简化很多，但是在查询处理的时候我们还是没有解决ResultSet结果集的处理问题，表的不同结构还是需要自己构造，在上面我们只优化了添加和更新的优化。对于查询JDBC代码还是过于冗余。</p><h3 id="1-4-JDBC优化3-0">1.4 JDBC优化3.0</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对<span class="keyword">ResultSet</span>的优化我们需要从反射和元数据两方面入手，具体如下</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法的简易封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, Class clazz, Object ... parameter)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(parameter != <span class="literal">null</span> &amp;&amp; parameter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,parameter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="comment">// 获取对应的表结构的元数据</span></span><br><span class="line">    <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> ps.getMetaData();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        <span class="comment">// 根据 字段名称获取对应的值 然后将数据要封装到对应的对象中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; columnCount+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据每列的名称获取对应的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnName(i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line">            setFieldValueForColumn(o,columnName,columnValue);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add((T) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据字段名称设置 对象的属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> columnName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValueForColumn</span><span class="params">(Object o, String columnName,Object columnValue)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = o.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据字段获取属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">        <span class="comment">// 私有属性放开权限</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(o,columnValue);</span><br><span class="line">        field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">// 说明不存在 那就将 _ 转换为 驼峰命名法</span></span><br><span class="line">        <span class="keyword">if</span>(columnName.contains(<span class="string">&quot;_&quot;</span>))&#123;</span><br><span class="line">            <span class="type">Pattern</span> <span class="variable">linePattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;_(\\w)&quot;</span>);</span><br><span class="line">            columnName = columnName.toLowerCase();</span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> linePattern.matcher(columnName);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                matcher.appendReplacement(sb, matcher.group(<span class="number">1</span>).toUpperCase());</span><br><span class="line">            &#125;</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">            <span class="comment">// 再次调用复制操作</span></span><br><span class="line">            setFieldValueForColumn(o,sb.toString(),columnValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了以上方法后我们的查询操作就可以简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 通过JDBC查询用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from t_user where id = ?&quot;</span>;</span><br><span class="line">           List&lt;Student&gt; list = DBUtils.query(sql, Student.class,<span class="number">1</span>);</span><br><span class="line">           System.out.println(list);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样一来我们在操作数据库中数据的时候就只需要关注于核心的SQL操作了。当然以上的设计还比较粗糙，这时Apache 下的 DbUtils是一个很好的选择。</p><h2 id="2-Apache-DBUtils">2.Apache DBUtils</h2><p>官网地址：<a href="https://commons.apache.org/proper/commons-dbutils/">https://commons.apache.org/proper/commons-dbutils/</a></p><h3 id="2-1-初始配置">2.1 初始配置</h3><p>DButils中提供了一个QueryRunner类，它对数据库的增删改查的方法进行了封装，获取QueryRunner的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROPERTY_PATH</span> <span class="operator">=</span> <span class="string">&quot;druid.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource dataSource;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> DBUtils.class.getClassLoader().getResourceAsStream(PROPERTY_PATH);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        properties.load(in);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    dataSource = <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    dataSource.configFromPropety(properties);</span><br><span class="line">    <span class="comment">// 使用数据源初始化 QueryRunner</span></span><br><span class="line">    queryRunner = <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建QueryRunner对象的时候我们需要传递一个DataSource对象，这时我们可以选择Druid或者Hikai等常用的连接池工具，我这儿用的是Druid。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">druid.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">druid.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">druid.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">druid.minIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">druid.maxActive</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><h3 id="2-2-基本操作">2.2 基本操作</h3><p>QueryRunner中提供的方法解决了重复代码的问题，传入数据源解决了资源管理的问题。而对于ResultSet结果集的处理则是通过 ResultSetHandler 来处理。我们可以自己来实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询所有的用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">       DruidUtils.init();</span><br><span class="line">       <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> DruidUtils.getQueryRunner();</span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">       List&lt;Student&gt; list = queryRunner.query(sql, <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 直接回调</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">               List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">               <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                   <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">                   student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                   student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                   student.setMajor(rs.getString(<span class="string">&quot;major&quot;</span>));</span><br><span class="line"></span><br><span class="line">                   list.add(student);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> list;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">           System.out.println(student);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者用DBUtils中提供的默认的相关实现来解决</p><p><img src="/posts/6b5152eb.htm/img%5Cimage-20220707143936426.png" alt="image-20220707143936426"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ResultHandle的实现类处理查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserUseBeanListHandle</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    DruidUtils.init();</span><br><span class="line">    <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> DruidUtils.getQueryRunner();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">    <span class="comment">// 不会自动帮助我们实现驼峰命名的转换</span></span><br><span class="line">    List&lt;User&gt; list = queryRunner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Apache 封装的DBUtils是能够很方便的帮助我们实现相对比较简单的数据库操作</p><h2 id="3-SpringJDBC">3.SpringJDBC</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Spring框架平台下，也提供的有<span class="keyword">JDBC的封装操作，在Spring中提供了一个模板方法 </span><span class="keyword">JdbcTemplate，里面封装了各种各样的 </span>execute,query和update方法。</span><br></pre></td></tr></table></figure><p>JdbcTemplate这个类是JDBC的核心包的中心类，简化了JDBC的操作，可以避免常见的异常，它封装了JDBC的核心流程，应用只要提供SQL语句，提取结果集就可以了，它是线程安全的。</p><h3 id="3-1-初始配置">3.1 初始配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在SpringJdbcTemplate的使用中，我们依然要配置对应的数据源，然后将JdbcTemplate对象注入到IoC容器中。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        template.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-CRUD操作">3.2 CRUD操作</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们具体操作数据库中数据的时候，我们只需要从容器中获取JdbcTemplate实例即可</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(<span class="string">&quot;insert into t_user(user_name,real_name)values(?,?)&quot;</span>,<span class="string">&quot;bobo&quot;</span>,<span class="string">&quot;波波&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">        List&lt;User&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                user.setUserName(rs.getString(<span class="string">&quot;user_name&quot;</span>));</span><br><span class="line">                user.setRealName(rs.getString(<span class="string">&quot;real_name&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">        List&lt;User&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Hibernate">4.Hibernate</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面介绍的Apache DBUtils和SpringJdbcTemplate虽然简化了数据库的操作，但是本身提供的功能还是比较简单的(缺少缓存，事务管理等)，所以我们在实际开发中往往并没有直接使用上述技术，而是用到了Hibernate和MyBatis等这些专业的ORM持久层框架。</span><br></pre></td></tr></table></figure><h3 id="4-1-ORM介绍">4.1 ORM介绍</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ORM</span><span class="params">( Object Relational Mapping)</span></span> ，也就是对象与关系的映射，对象是程序里面的对象，关系是它与数据库里面的数据的关系，也就是说，ORM框架帮助我们解决的问题是程序对象和关系型数据库的相互映射的问题</span><br></pre></td></tr></table></figure><p>O:对象</p><p>M:映射</p><p>R:关系型数据库</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/4cfe3e6447fa4bae84ccfa7b6321ed8f.png" alt="image.png"></p><h3 id="4-2-Hibernate的使用">4.2 Hibernate的使用</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hibernate</span>是一个很流行的ORM框架，<span class="number">2001</span>年的时候就出了第一个版本。使用步骤如下</span><br></pre></td></tr></table></figure><h4 id="4-2-1-创建项目">4.2.1 创建项目</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个Maven项目并添加相关的依赖即可，我们在此处直接通过 SpringDataJpa的依赖处理</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-配置文件">4.2.2 配置文件</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在使用Hibernate的使用，我们需要为实体类创建一些hbm的<span class="built_in">xml</span>映射文件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&#x27;-//Hibernate/Hibernate Mapping DTD 3.0//EN&#x27;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&#x27;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.boge.model.User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;t_user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及Hibernate的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-configuration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span></span><br><span class="line">            com.mysql.cj.jdbc.Driver</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span></span><br><span class="line">            jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span></span><br><span class="line">            org.hibernate.dialect.MySQLDialect</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-CRUD-操作">4.2.3 CRUD 操作</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在程序中我们可以通过Hibernate提供的 <span class="keyword">Session</span>对象来实现CRUD操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hibernate操作案例演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 默认使用hibernate.cfg.xml</span></span><br><span class="line">        configuration.configure();</span><br><span class="line">        <span class="comment">// 创建Session工厂</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">        <span class="comment">// 创建Session</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="comment">// 获取事务对象</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> session.getTransaction();</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">// 把对象添加到数据库中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">666</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;hibernate&quot;</span>);</span><br><span class="line">        user.setRealName(<span class="string">&quot;持久层框架&quot;</span>);</span><br><span class="line">        session.save(user);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-4-其他方式">4.2.4 其他方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在映射文件的位置，我们也可以通过注解的方式来替换掉映射文件</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;real_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;i_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer dId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Spring中给我们提供的JPA对持久层框架做了统一的封装，而且本质上就是基于HibernateJPA来实现的，所以我们在使用的时候也可以通过SpringDataJPA的API来操作</p><p>dao的接口只需要继承JpaRepository接口即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserDao extends JpaRepository&lt;User,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层正常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-Hibernate总结">4.3 Hibernate总结</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate的出现大大简化了我们的数据库操作，同时也能够更好的应对更加复杂的业务场景，Hibernate具有如下的特点</span><br></pre></td></tr></table></figure><ol><li>根据数据库方言自定生成SQL，移植性好</li><li>自动管理连接资源</li><li>实现了对象和关系型数据的完全映射，操作对象就想操作数据库记录一样</li><li>提供了缓存机制</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate在处理复杂业务的时候同样也存在一些问题</span><br></pre></td></tr></table></figure><ol><li>比如API中的get(),update()和save()方法，操作的实际上是所有的字段，没有办法指定部分字段，换句话说就是不够灵活</li><li>自定生成SQL的方式，如果要基于SQL去做一些优化的话，也是非常困难的。</li><li>不支持动态SQL，比如分表中的表名，条件，参数变化等，无法根据条件自动生成SQL</li></ol><p>因此我们需要一个更为灵活的框架-MyBatis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、ORM框架的发展历程&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/c8fb12ecffb042fea929c</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="https://eizo01.github.io/posts/54cf796.html"/>
    <id>https://eizo01.github.io/posts/54cf796.html</id>
    <published>2022-11-07T12:00:00.000Z</published>
    <updated>2023-03-18T14:02:16.597Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis底层数据结构</h1><p><strong>Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构</strong>。</p><p>现在附上3.0和6.0的数据结构图</p><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>在最新的 Redis 代码6.0，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318165759154.png" alt="image-20230318165759154"></p><p><img src="https://zdwtop.cn/blog/a9c3e7dc4ac79363d8eb8eb2290a58e6.png" alt="img"></p><p>图有xiaolincoding的贡献。感谢。</p><h2 id="redis的key-value结构">redis的key-value结构</h2><p>我们还是得复习一下整个redis的key-value结构</p><p><img src="https://zdwtop.cn/blog/3c386666e4e7638a07b230ba14b400fe.png" alt="img"></p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 *<em>void * key 和 void * value 指针， <em>key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</em></em>。</li></ul><p>void * key 和 void * value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><p><img src="https://zdwtop.cn/blog/58d3987af2af868dca965193fb27c464.png" alt="img"></p><p>对象结构里包含的成员变量：</p><ul><li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li><li>encoding，标识该对象使用了哪种底层的数据结构；</li><li><strong>ptr，指向底层数据结构的指针</strong>。</li></ul><h2 id="SDS">SDS</h2><p>简单动态字符串（SDS）是Redis的字符串实现之一，它是一个动态字符串，可以自动扩展和收缩，支持O(1)时间复杂度的字符串长度获取.</p><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p><h3 id="C-语言字符串的缺陷">C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p><p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p><img src="https://zdwtop.cn/blog/bcf6bde3b647bdc343efcbc1a8f10579.png" alt="img" style="zoom:80%;"><p>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方*</strong>）</p><p>还有<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（这也是一个可以改进的地方）</strong></p><p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所有字符串操作的函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方*</strong>）。</p><p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul><p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p><h3 id="SDS-结构设计">SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><img src="https://zdwtop.cn/blog/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom:50%;"><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p><h4 id="O（1）复杂度获取字符串长度">O（1）复杂度获取字符串长度</h4><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p><p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p><h4 id="二进制安全">二进制安全</h4><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p><h4 id="不会发生缓冲区溢出">不会发生缓冲区溢出</h4><p>C 语言的字符串标准库提供的字符串操作函数，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p><p>Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p><p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p><p>SDS 扩容的规则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hisds <span class="title function_">hi_sdsMakeRoomFor</span><span class="params">(hisds s, <span class="type">size_t</span> addlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// s目前的剩余空间已足够，无需扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//获取目前s的长度</span></span><br><span class="line">    len = hi_sdslen(s);</span><br><span class="line">    sh = (<span class="type">char</span> *)s - hi_sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">//扩展之后 s 至少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    <span class="comment">//根据新长度，为s分配新空间所需要的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; HI_SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">//新长度&lt;HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则，分配长度为目前长度+1MB</span></span><br><span class="line">        newlen += HI_SDS_MAX_PREALLOC;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li><li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li></ul><h4 id="节省内存空间">节省内存空间</h4><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p><p>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p><p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><p><img src="https://zdwtop.cn/blog/image-20230318171838299.png" alt="image-20230318171838299"></p><p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li><li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li></ul><p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p>「字节对齐」的方式分配内存</p><h2 id="链表">链表</h2><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。</p><p>链表是Redis的列表实现之一，它是一个双向链表，每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针.</p><h3 id="链表结构设计">链表结构设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    struct listNode *next;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 在 listNode 结构体基础上又封装了 list 这个数据结构</span></span><br><span class="line">    typedef struct list &#123;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    unsigned <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/cadf797496816eb343a19c2451437f1e.png" alt="img"></p><h3 id="链表的优势与缺陷">链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>；</li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li></ul><p>链表的缺陷也是有的：</p><ul><li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li><li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li></ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p><h2 id="压缩列表ZipList">压缩列表<strong>ZipList</strong></h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>压缩列表是Redis的列表和哈希表实现之一，它是一个紧凑的数据结构，可以在内存中存储多个元素，每个元素可以是一个字符串或一个整数.</p><p>但是，压缩列表的缺陷也是有的：</p><ul><li>不能保存过多的元素，否则查询效率就会降低；</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li></ul><p>Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><h3 id="压缩列表结构设计">压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="https://zdwtop.cn/blog/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img"></p><p>压缩列表在表头有三个字段：</p><ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>压缩列表节点（<strong>entry</strong>）的构成如下：</p><ul><li><em><strong>prevlen</strong></em>，<strong>记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</strong></li><li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；占用1个、2个或5个字节</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318182627294.png" alt="image-20230318182627294"></p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关.</p><ul><li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li><li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节/2字节/5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。</p><h3 id="连锁更新">连锁更新</h3><p>压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p><ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p><h3 id="压缩列表的缺陷">压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题.</p><h2 id="哈希表-dict">哈希表 <strong>dict</strong></h2><p>字典是Redis的哈希表实现之一，它是一个键值对的无序集合，其中每个键都映射到一个值.</p><p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。<strong>Redis 采用了「链式哈希」来解决哈希冲突</strong></p><h3 id="哈希表结构设计">哈希表结构设计</h3><p><img src="https://zdwtop.cn/blog/image-20230318183756294.png" alt="image-20230318183756294"></p><p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p><p><img src="https://zdwtop.cn/blog/dc495ffeaa3c3d8cb2e12129b3423118.png" alt="img"></p><p>跳跃表是Redis的有序集合实现之一，它是一个有序的数据结构，其中每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针。跳跃表是一种高效的有序数据结构，可以在O(log N)时间内执行插入、删除和查找操作.</p><h3 id="rehash">rehash</h3><p>哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//两个Hash表，交替使用，用于rehash操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    …</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p><p><img src="https://zdwtop.cn/blog/2fedbc9cd4cb7236c302d695686dd478.png" alt="img"></p><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><p><img src="https://zdwtop.cn/blog/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img"></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><h3 id="渐进式-rehash">渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p><blockquote><p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p></blockquote><h3 id="rehash-触发条件">rehash 触发条件</h3><p>rehash 的触发条件跟**负载因子（load factor）**有关系。</p><p>负载因子可以通过下面这个公式计算：</p><p><img src="https://zdwtop.cn/blog/image-20230318184250548.png" alt="image-20230318184250548"></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul><h2 id="整数集合Inset">整数集合<strong>Inset</strong></h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p><p><img src="https://zdwtop.cn/blog/image-20230318184640470.png" alt="image-20230318184640470"></p><h3 id="升级扩容">升级扩容</h3><p><img src="https://zdwtop.cn/blog/image-20230318184733792.png" alt="image-20230318184733792"></p><h2 id="跳表skip-list">跳表<strong>skip list</strong></h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><p>struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</p><p>跳表结构里包含了：</p><ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li></ul><h3 id="跳表结构设计">跳表结构设计</h3><p><strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p><img src="https://zdwtop.cn/blog/image-20230318185333886.png" alt="image-20230318185333886"></p><p><img src="https://zdwtop.cn/blog/redis_skiplist_example.png" alt="Redis 核心数据结构（二） - &quot;地瓜哥&quot;博客网"></p><p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p><p><strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>其中，ZSKIPLIST_MAXLEVEL 定义的是最高的层数，Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32。</p><p>跳表的查找复杂度就是 O(logN)。</p><h3 id="为什么用跳表而不用平衡树？">为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL树、红黑树等）？</p><p>简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。平衡树每个节点包含 2 个指针,跳表平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。</li></ul><p>对象是Redis的所有数据类型的底层实现，它是一个通用的数据结构，可以表示字符串、列表、哈希表、有序集合等多种数据类型.</p><h2 id="quicklist">quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList</p><p>头尾指针-双端链表 节点是ziplist</p><p><img src="https://zdwtop.cn/blog/image-20230318190615928.png" alt="image-20230318190615928"></p><p><img src="https://zdwtop.cn/blog/image-20230318190619375.png" alt="image-20230318190619375"></p><p><img src="https://zdwtop.cn/blog/f46cbe347f65ded522f1cc3fd8dba549.png" alt="img"></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h2 id="listpack">listpack</h2><p>Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p><strong>在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p><h3 id="listpack-结构设计">listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构</p><p><img src="https://zdwtop.cn/blog/4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img"></p><p>stpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis底层数据结构&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Key和Value的数据结构组织</title>
    <link href="https://eizo01.github.io/posts/1cc613d0.html"/>
    <id>https://eizo01.github.io/posts/1cc613d0.html</id>
    <published>2022-11-05T12:00:00.000Z</published>
    <updated>2023-03-18T14:04:30.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的Key和Value的数据结构组织"><a href="#Redis的Key和Value的数据结构组织" class="headerlink" title="Redis的Key和Value的数据结构组织"></a>Redis的Key和Value的数据结构组织</h2><h3 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p><img src="HTTPs://zdwtop.cn/blog/1eb5ca015a3b4389ad4ede842d98df1f.png" alt="image.png"></p><p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。</p><p>哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对：我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p><p>但当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在<br>的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p><p><img src="HTTPs://zdwtop.cn/blog/f2a1f73d63f1428cad1324a7b67283b4.png" alt="image.png"></p><p>Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</p><p>当然如果这个数组一直不变，那么hash冲突会变很多，这个时候检索效率会大打折扣，所以Redis就需要把数组进行扩容（一般是扩大到原来的两倍），但是问题来了，扩容后每个hash桶的数据会分散到不同的位置，这里设计到元素的移动，必定会阻塞IO，所以这个ReHash过程会导致很多请求阻塞。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免这个问题，Redis 采用了渐进式 rehash。</p><p>首先、Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash。</p><p>1、给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍</p><p>2、把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中</p><p>3、释放哈希表 1 的空间</p><p>在上面的第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。</p><p><img src="HTTPs://zdwtop.cn/blog/2406a8206e944d449b03f1f390bedf0d.png" alt="image.png"></p><p>在Redis 开始执行 rehash，Redis仍然正常处理客户端请求，但是要加入一个额外的处理：</p><p>处理第1个请求时，把哈希表 1中的第1个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>处理第2个请求时，把哈希表 1中的第2个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>如此循环，直到把所有的索引位置的数据都拷贝到哈希表 2 中。</p><p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><p>所以这里基本上也可以确保根据key找value的操作在O（1）左右。</p><p>不过这里要注意，如果Redis中有海量的key值的话，这个Rehash过程会很长很长，虽然采用渐进式Rehash，但在Rehash的过程中还是会导致请求有不小的卡顿。并且像一些统计命令也会非常卡顿：比如keys</p><p>按照Redis的配置每个实例能存储的最大<em>的key的数量</em>为2的32次方,即2.5亿，但是尽量把key的数量控制在千万以下，这样就可以避免Rehash导致的卡顿问题，如果数量确实比较多，建议采用分区hash存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;a href=&quot;#Redis的Key和Value的数据结构组织&quot; class=&quot;headerlink&quot; title=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;/a&gt;Redis的Key和Value的数据结构</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的Buffer Pool</title>
    <link href="https://eizo01.github.io/posts/1eb869e1.html"/>
    <id>https://eizo01.github.io/posts/1eb869e1.html</id>
    <published>2022-11-05T12:00:00.000Z</published>
    <updated>2023-04-16T14:00:46.488Z</updated>
    
    <content type="html"><![CDATA[<h1>调节磁盘和CPU的矛盾-InnoDB的Buffer Pool</h1><h2 id="为什么要有-Buffer-Pool？">为什么要有 Buffer Pool？</h2><p>对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚 簇索引和二级索引），还是各种系统数据，都是以 页 的形式存放在 表空间 中的，而所谓的 表空间 只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。</p><p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>所以 InnoDB 存储引擎在处 理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说<font color="red"><strong>即使我们 只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</strong></font></p><p>将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 缓存 起来，这样将来有 请求再次访问该页面时，就可以省去磁盘 IO 的开销了。</p><h2 id="Buffer-Pool的大小？">Buffer Pool的大小？</h2><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> ，最小值为 5M (当小于该值时会自动设置成 5M )。</p><p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p><h2 id="Buffer-Pool内部组成">Buffer Pool内部组成</h2><p>为了更好的管理这些在 Buffer Pool 中的缓存页，设计 InnoDB 的大叔为每一个缓存页都创建了一些所谓的 控制信息 ，这些控制信息 包括该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息。</p><blockquote><p>在MySQL的缓冲池中，LSN是一个用于跟踪日志序列号（Log Sequence Number）的值。在InnoDB引擎中，每个页面都有一个LSN值，它指示了最近一次修改页面时对应的日志序列号。</p><p>在进行事务提交和回滚时，数据库使用LSN来保证数据的一致性和完整性。此外，LSN还在崩溃恢复过程中扮演重要的角色，它用于确定哪些日志需要被应用到数据库中以进行数据恢复。</p></blockquote><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102320659.png" alt="image-20230323102320659"></p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102429464.png" alt="image-20230323102429464"></p><p>每一个控制块都对应一个缓存页，那在分配 足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的那点儿内存空间就被称为 碎片 了。</p><h2 id="如何管理-Buffer-Pool？">如何管理 Buffer Pool？</h2><h3 id="如何管理空闲页？-Free-链表">如何管理空闲页？-Free 链表</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p><p>那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。</p><p>所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p><p>刚刚完成初始化的 Buffer Pool 中 所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到 free链表 中，假设该 Buffer Pool 中 可容纳的缓存页数量为 n ，那增加了 free链表 的效果图就是这样的</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102820147.png" alt="image-20230323102820147"></p><blockquote><p>链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里，每个基节点只占用40字节大小。MySQL中许多不同的链表，它们的基节点和free链表的基节点的内存分配方式是一样一样的，都是 单独申请的一块40字节大小的内存空间，并不包含在为Buffer Pool申请的一大片连续内存空间之内。</p></blockquote><p>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 free链表 中 取一个空闲的缓存页，并且把该缓存页对应的 控制块 的信息填上（就是该页所在的表空间、页号之类的信 息），然后把该缓存页对应的 free链表 节点从链表中移除，表示该缓存页已经被使用了</p><h3 id="缓存页的哈希处理">缓存页的哈希处理</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到 Buffer Pool 中，如果该页已经 在 Buffer Pool 中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在 Buffer Pool 中呢？难 不成需要依次遍历 Buffer Pool 中各个缓存页么？一个 Buffer Pool 中的缓存页这么多都遍历完岂不是要累死？</p><p>我们其实是根据 表空间号 + 页号 来定位一个页的，也就相当于 表空间号 + 页号 是一个 key ， 缓存页 就是对应的 value ，怎么通过一个 key 来快速找着一个 value 呢？如果学过数据结构，我们会非常熟悉会用哈希表来处理。</p><p><strong>所以我们可以用 表空间号 + 页号 作为 key ， 缓存页 作为 value 创建一个哈希表，在需要访问某个页的数据 时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没 有，那就从 free链表 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</strong></p><h3 id="如何管理脏页？-flush链表">如何管理脏页？-flush链表</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p><p>凡是修改过的缓存页对 应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的， 所以也叫 flush链表 。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323103506265.png" alt="image-20230323103506265"></p><p>有了flush链表，每次修改缓存页后，我们并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步。</p><h3 id="如何提高缓存命中率？-LRU链表的管理">如何提高缓存命中率？-LRU链表的管理</h3><p>设立 Buffer Pool 的初衷，就是想减少和磁盘的 IO 交互，最好每次在访问某个页的时候它都已经被缓存到 Buffer Pool 中了。假设我们一共访问了 n 次页，那么被访问的页已经 在缓存中的次数除以 n 就是所谓的 <strong>缓存命中率</strong> ，我们的期望就是让 缓存命中率 越高越好～</p><p>从这个角度出发， 回想一下我们的微信聊天列表，排在前边的都是最近很频繁使用的，排在后边的自然就是最近很少使用的，假如 列表能容纳下的联系人有限，你是会把最近很频繁使用的留下还是最近很少使用的留下呢？废话，当然是留下最 近很频繁使用的了</p><p><strong>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</strong></p><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p><h4 id="简单LRU">简单LRU</h4><p>简单的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul><p>比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。</p><p>如果该页不在 Buffer Pool 中，在把该页从磁盘加载到 Buffer Pool 中的缓存页时，就把该缓存页对应的 控制块 作为节点塞到链表的头部。</p><p>如果该页已经缓存在 Buffer Pool 中，则直接把该页对应的 控制块 移动到 LRU链表 的头部。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323110557851.png" alt="image-20230323110557851"></p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul><p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效；</li><li>Buffer Pool 污染；</li></ul><h4 id="划分区域的LRU链表">划分区域的LRU链表</h4><ul><li><p><strong>预读</strong></p><p>InnoDB 提供了一个看起来比较贴心的服务—— 预读 （英文名： read ahead ）。所谓 预读 ，就是 InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 Buffer Pool 中。根据触发方式的不同， 预读又可以细分为下边两种：</p><ul><li><p>线性预读</p><p>MySQL提供了一个系统变量 <code>innodb_read_ahead_threshold </code>默认是 56，如果顺序访问了某个区 （ extent ）的页面超过这个系统变量的值，就会触发一次异步读取**下一个区中全部的页面到 Buffer Pool 的请求，注意 异步 读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常 执行。**线性预读也有一定的缺点，比如可能会占用大量的内存资源，导致系统性能下降，或者使得数据库长时间无法对某些数据进行修改操作。</p></li><li><p>随机预读</p><p>当使用InnoDB存储引擎时，在进行扫描操作（例如SELECT、UPDATE、DELETE等）时，**MySQL会随机读取数据页到内存中。这种优化策略可以避免在扫描操作时将所有数据都一次性读入内存，从而避免了缓存命中率低下的问题。**因此每个数据页只有被访问一次的机会，导致线性预读的数据页在内存中暂留时间更长。</p><p>默认不开启，通过调整配置参数（例如innodb_random_read.ahead_ratio）可以设置适当的预读阈值来平衡内存占用和系统性能。随机预读的效果一般优于线性预读，因为它更适合 InnoDB 引擎的 B+ 树索引，在查询条件缺失时可以将多个值集中进行扫描，提高查询效率。</p></li></ul></li></ul><p>预读 本来是个好事儿，如果预读到 Buffer Pool 中的页成功的被使用到，那就可以极大的提高语句执 行的效率。可是如果用不到呢？这些预读的页都会放到 LRU 链表的头部，但是如果此时 Buffer Pool 的 容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 LRU链表 尾部的一些缓存页会很快的 被淘汰掉，也就是所谓的 <strong>劣币驱逐良币 ，会大大降低缓存命中率。</strong></p><ul><li><strong>情况二：需要扫描全表的查询语句–Buffer Pool 污染</strong></li></ul><p>​意味着将访问到该表所在的所有页！假设这个表中记录非常多的话，那该表会占用特 别多的 页 ，当需要访问这些页时，会把它们统统都加载到 Buffer Pool 中，相当于 Buffer Pool 的东西全部换一遍，原本在查询的页，也被替换出去了，也需要再次查询，<strong>又得执行一次从磁盘加载到 Buffer Pool 的操作。而这种全表扫描的语句执行的频率也不高，每次执行都要把 Buffer Pool 中的缓存页换一次血，这 严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。</strong></p><p>总结一下上边说的可能降低 Buffer Pool 的两种情况：</p><ul><li>加载到 Buffer Pool 中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到 Buffer Pool 时，可能会把那些使用频率非常高的页从 Buffer Pool 中淘汰掉。</li></ul><p>因为有这两种情况的存在，InnoDB 把这个 LRU链表 按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 热数据 ，或者称 young区域 。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 冷数据 ，或者称 old区域 。</li></ul><p><img src="HTTPs://zdwtop.cn/blog/image-20230323114021086.png" alt="image-20230323114021086"></p><p>我们是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某 些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。</p><p>默认情况下，InnoDB的old和young区域的比例为8:2。</p><p>有了这个被划分成 young 和 old 区域的 LRU 链表之后， InnoDB 就可以针对我们上边提到的两种可能 降低缓存命中率的情况进行优化了：</p><ul><li>针对预读的页面可能不进行后续访情况的优化</li></ul><p><font color="red"><strong>当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应 的控制块会被放到old区域的头部。</strong></font>这样针对预读到 Buffer Pool 却不进行后续访问的页面就会被逐渐从 old 区域逐出，而不会影响 young 区域中被使用比较频繁的缓存页。</p><ul><li>针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化</li></ul><p>在对某个处在 old 区域的缓存页进行第一次访问时就在它对应的控制块中 记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被 从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量<code> innodb_old_blocks_time</code> 控制的默认值是 1000 ，它的单位是毫秒.</p><p><strong>也就意味着对于从磁盘上被加载到 LRU 链表的 old 区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于 1s （很明显在一次 全表扫描的过程中，多次访问一个页面中的时间不会超过 1s ），那么该页是不会被加入到 young 区域的</strong></p><p>综上所述，正是因为将 LRU 链表划分为 young 和 old 区域这两个部分，又添加了 <code>innodb_old_blocks_time</code> 这个 系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全 表扫描的页面都只会被放到 old 区域，而不影响 young 区域中的缓存页。</p><h4 id="进一步优化LRU链表">进一步优化LRU链表</h4><p>对于 young 区域的缓存页来说，我们每次访问一个缓存页就要把它移 动到 LRU链表 的头部，这样开销太大啦，毕竟在 young 区域的缓存页都是热点数据，也就是可能被经常访问的。</p><p>为了防止lru节点被频繁操作，规定了<strong>只有被访问的缓存页位于 young 区域的 1/4 的后边，才会被移动到 LRU链表 头部，这样就 可以降低调整 LRU链表 的频率，从而提升性能（也就是说如果某个缓存页对应的节点在 young 区域的 1/4 中， 再次访问该缓存页时也不会将其移动到 LRU 链表头部）</strong></p><p>这些操作都是为了<font color="red"><strong>尽量高效的提高 Buffer Pool 的缓存命中率</strong></font></p><h2 id="刷新脏页到磁盘">刷新脏页到磁盘</h2><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：</p><ul><li><p><strong>从 LRU链表 的冷数据中刷新一部分页面到磁盘。</strong></p><p>后台线程会定时从 LRU链表 尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称 之为 <strong>BUF_FLUSH_LRU</strong> 。</p></li><li><p><strong>从 flush链表 中刷新一部分页面到磁盘。</strong></p><p>后台线程也会定时从 flush链表 中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 <strong>BUF_FLUSH_LIST</strong> 。</p></li></ul><p>在 MySQL InnoDB 存储引擎中，后台专门的线程负责将脏数据（即未写入磁盘的数据）刷新到磁盘上。这个过程被称为 Checkpoint。</p><p>Checkpoint：定期地将缓冲池中的所有脏页刷新到磁盘上，以避免在系统发生故障时丢失重要的数据。这个过程是由InnoDB自动完成的，其频率由<code>innodb_checkpoint_interval</code>参数控制。</p><p>在 Checkpoint 过程中，一般会有两种刷新路径：</p><ul><li><strong>Master thread 写路径</strong></li></ul><p>Master thread 是负责 <strong>LRU List</strong> 管理、缓存池大小控制以及周期性地触发 Checkpoint 的线程。Master thread 在执行 Checkpoint 的过程中，首先会将脏数据写回到 redo log 里面。然后将 checkpoint 信息写到 redo log 文件头部，并强制进行一次 log flush。在这个过程中，InnoDB 引擎使用 async IO 模型，因此不会阻塞主要的用户线程请求。</p><ul><li><strong>Background page cleaner 刷路径</strong></li></ul><p>Background page cleaner 是另一个单独的线程，它的主要作用就是异步执行 <strong>Flush</strong> 操作（**即将脏页刷新到磁盘）。**每当 Master thread 执行一次 Checkpoint 时，都会通知 Background page cleaner 执行 Flush操作。在 Flush 过程中，Background page cleaner 也是采用 async IO 模型，也不会阻塞用户线程请求。</p><h2 id="总的来说，Master-thread-写路径是负责管理车站进出口道闸机器人的、影响依赖性比较大的逻辑，而-Background-page-cleaner-刷路径则是负责执行脏页刷新的工作，两者各自发挥其所长，协同完成数据库运作。">总的来说，<strong>Master thread 写路径是负责管理车站进出口道闸机器人的、影响依赖性比较大的逻辑，而 Background page cleaner 刷路径则是负责执行脏页刷新的工作，两者各自发挥其所长，协同完成数据库运作。</strong></h2><h1>补充-后台线程</h1><p>在 MySQL 中，不同的后台线程执行的刷新或清理操作的时间间隔是不同的。一些常见的后台线程及其执行周期如下：</p><ol><li>刷新线程：刷新缓冲池中的被修改过的数据到磁盘。默认情况下，每个事务提交后都会将日志缓冲区中的日志写入磁盘。可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数的值来控制刷新日志的时间。（即 0-每秒/1-每次提交/2-整个事务提交后）。</li><li>LRU 刷新线程：根据 InnoDB 缓冲池使用率和空闲状态，定期将最近最少使用的数据刷回磁盘，保证缓冲池中始终有可用的空间供新读取的数据使用，默认情况下，LRU 刷新线程每秒刷新一次。</li><li>检查点执行线程：使用“脏页”机制（InnoDB 中指暂未写入磁盘的修改数据页），定期执行检查点来将所有脏页持久化到磁盘上。检查点执行线程的执行周期由内部算法来决定。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;调节磁盘和CPU的矛盾-InnoDB的Buffer Pool&lt;/h1&gt;
&lt;h2 id=&quot;为什么要有-Buffer-Pool？&quot;&gt;为什么要有 Buffer Pool？&lt;/h2&gt;
&lt;p&gt;对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚 簇索引</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="innodb" scheme="https://eizo01.github.io/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级数据结构</title>
    <link href="https://eizo01.github.io/posts/c9e7ec61.html"/>
    <id>https://eizo01.github.io/posts/c9e7ec61.html</id>
    <published>2022-11-03T12:00:00.000Z</published>
    <updated>2023-03-18T14:08:50.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis高级数据结构"><a href="#Redis高级数据结构" class="headerlink" title="Redis高级数据结构"></a>Redis高级数据结构</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>现代计算机用二进制(位)作为信息的基础单位，1个字节等于8位，例如“big”字符串是由3个字节组成，但实际在计算机存储时将其用二进制表示,“big”分别对应的ASCII码分别是98、105、103，对应的二进制分别是01100010、01101001和 01100111。</p><p><img src="https://zdwtop.cn/blog/bitmap.png" alt="img"></p><p>许多开发语言都提供了操作位的功能，合理地使用位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据结构”可以实现对位的操作。把数据结构加上引号主要因为:</p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h4 id="setbit-设置值"><a href="#setbit-设置值" class="headerlink" title="setbit 设置值"></a>setbit 设置值</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key <span class="built_in">offset</span> value</span><br></pre></td></tr></table></figure><p>设置键的第 offset 个位的值(从0算起)。</p><p>假设现在有20个用户，userid=0,2,4,6,8的用户对网站进行了访问，存储键名为日期。</p><p><img src="HTTPs://zdwtop.cn/blog/faf895f88aa940ea854dba440b8030e7.png" alt="image.png"></p><h4 id="getbit-获取值"><a href="#getbit-获取值" class="headerlink" title="getbit 获取值"></a>getbit 获取值</h4><p><code>getbit key offset</code></p><p>获取键的第 offset位的值(从0开始算)，比如<strong>获取userid=8的用户是否在2022（年/这天）访问过,返回0说明没有访问过:</strong></p><p>当然offset是不存在的，也会返回0。</p><p><img src="HTTPs://zdwtop.cn/blog/a32b45af412f4ab6a0345447cd7c4ea7.png" alt="image.png"></p><h4 id="bitcount-获取Bitmaps指定范围值为1的个数"><a href="#bitcount-获取Bitmaps指定范围值为1的个数" class="headerlink" title="bitcount 获取Bitmaps指定范围值为1的个数"></a>bitcount 获取Bitmaps指定范围值为1的个数</h4><p><code>bitcount [start] [end]</code></p><p>下面操作计算26号和27号这天的独立访问用户数量</p><p><strong>[start]和[end]代表起始和结束字节数</strong></p><p><img src="HTTPs://zdwtop.cn/blog/6f10ab793dfa4e4bb9cc297344544f17.png" alt="image.png"></p><h4 id="bitop-Bitmaps-间的运算"><a href="#bitop-Bitmaps-间的运算" class="headerlink" title="bitop Bitmaps 间的运算"></a>bitop Bitmaps 间的运算</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">  <span class="keyword">AND</span> 与运算 <span class="operator">&amp;</span></span><br><span class="line">  <span class="keyword">OR</span> 或运算 <span class="operator">|</span></span><br><span class="line">  XOR 异或 <span class="operator">^</span></span><br><span class="line">  <span class="keyword">NOT</span> 取反 <span class="operator">~</span></span><br><span class="line"># <span class="keyword">result</span> 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，<span class="keyword">not</span>运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [<span class="keyword">result</span>] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定<span class="keyword">value</span>(<span class="number">0</span><span class="operator">/</span><span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [<span class="keyword">value</span>]</span><br></pre></td></tr></table></figure><p>bitop是一个复合操作，它可以做多个Bitmaps 的 and(交集)or(并集)not(非)xor(异或）操作并将结果保存在destkey中。</p><h4 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h4><p>-计算Bitmaps中第一个值为targetBit 的偏移量</p><p><code>bitpos key targetBit [start] [end]</code></p><p>除此之外，bitops有两个选项[start]和[end]，分别代表起始字节和结束字节。</p><p><img src="HTTPs://zdwtop.cn/blog/6cc67c513009442a9ecf29beed3188af.png" alt="image.png"></p><h4 id="Bitmaps优势"><a href="#Bitmaps优势" class="headerlink" title="Bitmaps优势"></a>Bitmaps优势</h4><p>假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和 Bitmaps分别存储活跃用户，很明显，假如用户id是Long型，64位，则集合类型占据的空间为64位x50 000 000= 400MB，而Bitmaps则需要1位×100 000 000=12.5MB，可见Bitmaps能节省很多的内存空间。</p><h5 id="面试题和场景"><a href="#面试题和场景" class="headerlink" title="面试题和场景"></a>面试题和场景</h5><p>1、目前有10亿数量的自然数，乱序排列，需要对其排序。限制条件-在32位机器上面完成，内存限制为 2G。如何完成？</p><p>2、如何快速在亿级黑名单中快速定位URL地址是否在黑名单中？(每条URL平均64字节)</p><p>3、需要进行用户登陆行为分析，来确定用户的活跃情况？</p><p>4、网络爬虫-如何判断URL是否被爬过？</p><p>5、快速定位用户属性（黑名单、白名单等）</p><p>6、数据存储在磁盘中，如何避免大量的无效IO？</p><h5 id="传统数据结构的不足"><a href="#传统数据结构的不足" class="headerlink" title="传统数据结构的不足"></a>传统数据结构的不足</h5><p>当然有人会想，我直接将网页URL存入数据库进行查找不就好了，或者建立一个哈希表进行查找不就OK了。</p><p>当数据量小的时候，这么思考是对的，</p><p>确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，举个例子如果一个1000万HashMap，Key=String（长度不超过16字符，且重复性极小），Value=Integer，会占据多少空间呢？1.2个G。实际上，1000万个int型，只需要40M左右空间，占比3%，1000万个Integer，需要161M左右空间，占比13.3%。可见一旦你的值很多例如上亿的时候，那HashMap 占据的内存大小就变得很可观了。</p><p>但如果整个网页黑名单系统包含100亿个网页URL，在数据库查找是很费时的，并且如果每个URL空间为64B，那么需要内存为640GB，一般的服务器很难达到这个需求。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><p><strong>1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。<br>这种算法由一个二进制数组和一个 Hash 算法组成。</strong></p><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>实际上，布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等，Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数，Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。</p><p><img src="https://zdwtop.cn/blog/801f60ff2d28436faaaab3007dd7d893.png" alt="image.png"></p><h3 id="布隆过滤器的误判问题"><a href="#布隆过滤器的误判问题" class="headerlink" title="布隆过滤器的误判问题"></a>布隆过滤器的误判问题</h3><p>Ø通过hash计算在数组上不一定在集合</p><p>Ø本质是hash冲突</p><p>Ø通过hash计算不在数组的一定不在集合（误判）</p><p><img src="https://zdwtop.cn/blog/d31bbeaf5a8742d2b15ce65bbc5a4537.png" alt="image.png"></p><p><strong>优化方案</strong></p><p>增大数组(预估适合值)</p><p>增加hash函数</p><p><img src="HTTPs://zdwtop.cn/blog/84b1457186f44856b6ad56561ba64229.png" alt="image.png"></p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>HyperLogLog并不是一种新的数据结构(实际类型为字符串类型)，而是一种基数算法,通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p><p>如果你负责开发维护一个大型的网站，有一天产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？</p><p>如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p><p>但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一 ID 来标识。</p><p>一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。</p><p>百万级用户访问网站</p><p><img src="HTTPs://zdwtop.cn/blog/494d8e7c3cbc464db90935208fa20d44.png" alt="image.png"></p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>HyperLogLog提供了3个命令: pfadd、pfcount、pfmerge。</p><h4 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h4><p><code>pfadd key element [element …]</code></p><p>pfadd用于向HyperLogLog 添加元素,如果添加成功返回1:</p><p>pfadd u-9-30 u1 u2 u3 u4 u5 u6 u7 u8</p><p><img src="HTTPs://zdwtop.cn/blog/c6de0b04ae7b43e69528a24301d7920b.png" alt="image.png"></p><h4 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h4><p><code>pfcount key [key …]</code></p><p>pfcount用于计算一个或多个HyperLogLog的独立总数，例如u-9-30 的独立总数为8:</p><p><img src="HTTPs://zdwtop.cn/blog/a86c5c198cef4717864fd2794eaf3624.png" alt="image.png"></p><p>如果此时向插入一些用户，用户并且有重复</p><p><img src="HTTPs://zdwtop.cn/blog/689ddb0df4164a98bb7d078e45af9fda.png" alt="image.png"></p><p>如果我们继续往里面插入数据，比如插入100万条用户记录。内存增加非常少，但是pfcount 的统计结果会出现误差。</p><h4 id="pfmerge"><a href="#pfmerge" class="headerlink" title="pfmerge"></a>pfmerge</h4><p><code>pfmerge destkey sourcekey [sourcekey ... ]</code></p><p>pfmerge可以求出多个HyperLogLog的并集并赋值给destkey，请自行测试。</p><p>可以看到，HyperLogLog内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是100%的正确，其中一定存在误差率。前面说过，Redis官方给出的数字是0.81%的失误率。</p><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>HyperLogLog基于概率论中伯努利试验并结合了极大似然估算方法，并做了分桶优化。</p><p>实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:</p><p>举个例子来理解HyperLogLog<br>算法，有一天李瑾老师和马老师玩打赌的游戏。</p><p>规则如下: 抛硬币的游戏，每次抛的硬币可能正面，可能反面，没回合一直抛，直到每当抛到正面回合结束。</p><p>然后我跟马老师说，抛到正面最长的回合用到了7次，你来猜一猜，我用到了多少个回合做到的？</p><p><img src="https://zdwtop.cn/blog/b908ff160cdd4eed858e76b248fd880e.png" alt="image.png"></p><p>进行了n次实验，比如上图：</p><p>第一次试验: 抛了3次才出现正面，此时 k=3，n=1</p><p>第二次试验: 抛了2次才出现正面，此时 k=2，n=2</p><p>第三次试验: 抛了4次才出现正面，此时 k=4，n=3</p><p>…………</p><p>第n 次试验：抛了7次才出现正面，此时我们估算，k=7</p><p>马老师说大概你抛了128个回合。这个是怎么算的。</p><p>k是每回合抛到1所用的次数，我们已知的是最大的k值，可以用kmax表示。由于每次抛硬币的结果只有0和1两种情况，因此，能够推测出kmax在任意回合出现的概率 ，并由kmax结合极大似然估算的方法推测出n的次数n =<br>2^(k_max) 。概率学把这种问题叫做伯努利实验。</p><p>但是问题是，这种本身就是概率的问题，我跟马老师说，我只用到12次，并且有视频为证。</p><p>所以这种预估方法存在较大误差，为了改善误差情况，HLL中引入分桶平均的概念。</p><p>同样举抛硬币的例子，如果只有一组抛硬币实验，显然根据公式推导得到的实验次数的估计误差较大；如果100个组同时进行抛硬币实验，受运气影响的概率就很低了，每组分别进行多次抛硬币实验，并上报各自实验过程中抛到正面的抛掷次数的最大值，就能根据100组的平均值预估整体的实验次数了。</p><p>分桶平均的基本原理是将统计数据划分为m个桶，每个桶分别统计各自的kmax,并能得到各自的基数预估值，最终对这些基数预估值求平均得到整体的基数估计值。LLC中使用几何平均数预估整体的基数值，但是当统计数据量较小时误差较大；HLL在LLC基础上做了改进，<strong>采用调和平均数过滤掉不健康的统计值</strong>。</p><p>什么叫调和平均数呢？举个例子</p><p>求平均工资：A的是1000/月，B的30000/月。采用平均数的方式就是：<br>(1000 + 30000) / 2 = 15500</p><p>采用调和平均数的方式就是：<br>2/(1/1000 + 1/30000) ≈ 1935.484</p><p>可见调和平均数比平均数的好处就是不容易受到大的数值的影响，比平均数的效果是要更好的。</p><h4 id="结合Redis的实现理解原理"><a href="#结合Redis的实现理解原理" class="headerlink" title="结合Redis的实现理解原理"></a>结合Redis的实现理解原理</h4><p>现在我们和前面的业务场景进行挂钩：统计网页每天的 UV 数据。</p><h4 id="1-转为比特串"><a href="#1-转为比特串" class="headerlink" title="1.转为比特串"></a><strong>1.转为比特串</strong></h4><p>通过hash函数，将数据转为二进制的比特串，例如输入5，便转为：101。为什么要这样转化呢？</p><p>是因为要和抛硬币对应上，比特串中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 10010000，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。</p><p>那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。</p><h4 id="2-分桶"><a href="#2-分桶" class="headerlink" title="2.分桶"></a><strong>2.分桶</strong></h4><p>分桶就是分多少轮。抽象到计算机存储中去，就是存储的是一个以单位是比特(bit)，长度为 L 的大数组 S ，将 S 平均分为 m 组，注意这个 m 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：</p><p>比如有4个桶的话，那么可以截取低2位作为分桶的依据。</p><p>比如</p><p>10010000   进入0号桶</p><p>10010001   进入1号桶</p><p>10010010   进入2号桶</p><p>10010011   进入3号桶</p><h5 id="Redis-中的-HyperLogLog-实现"><a href="#Redis-中的-HyperLogLog-实现" class="headerlink" title="Redis 中的 HyperLogLog 实现"></a>Redis 中的 HyperLogLog 实现</h5><p><strong>pfadd</strong></p><p><img src="HTTPs://zdwtop.cn/blog/116ef8fb48584cc5910184aaf50092a1.png" alt="image.png"></p><p>当我们执行这个操作时，lijin这个字符串就会被转化成64个bit的二进制比特串。</p><p>0010….0001  64位</p><p>然后在Redis中要分到16384个桶中（为什么是这么多桶：第一降低误判，第二，用到了14位二进制：2的14次方=16384）</p><p>怎么分？根据得到的比特串的后14位来做判断即可。</p><p><img src="https://zdwtop.cn/blog/bd71287e85294b14b95e3fcb82243fab.png" alt="image.png"></p><p>根据上述的规则，我们知道这个数据要分到 1号桶，同时从左往右（低位到高位）计算第1个出现的1的位置，这里是第4位，那么就往这个1号桶插入4的数据（转成二进制）</p><p>如果有第二个数据来了，按照上述的规则进行计算。</p><p>那么问题来了，如果分到桶的数据有重复了（这里比大小，大的替换小的）：</p><p>规则如下，比大小（比出现位置的大小），比如有个数据是最高位才出现1，那么这个位置算出来就是50，50比4大，则进行替换。1号桶的数据就变成了50（二进制是110010）</p><p>所以这里可以看到，每个桶的数据一般情况下6位存储即可。</p><p>所以我们这里可以推算一下一个key的HyperLogLog只占据多少的存储。</p><p>16384*6 /8/1024=12k。并且这里最多可以存储多少数据，因为是64位吗，所以就是2的64次方的数据，这个存储的数据非常非常大的，一般用户用long来定义，最大值也只有这么多。</p><p><strong>pfcount</strong></p><p>进行统计的时候，就是把16384桶，把每个桶的值拿出来，比如取出是 n,那么访问次数就是2的n次方。</p><p><img src="https://zdwtop.cn/blog/37ea459470614e8fad06c5eab8a009ca.png" alt="image.png"></p><p>然后把每个桶的值做调和平均数，就可以算出一个算法值。</p><p>同时，在具体的算法实现上，HLL还有一个分阶段偏差修正算法。我们就不做更深入的了解了。</p><p><img src="https://zdwtop.cn/blog/50bed8f5a0394a93aa8033ee9f847672.png" alt="image.png"></p><p>const和m都是Redis里面根据数据做的调和平均数。</p><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="滴滴叫车"><a href="#滴滴叫车" class="headerlink" title="滴滴叫车"></a>滴滴叫车</h4><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p><p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure><p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p><p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>Stream 消息队列操作命令：</p><ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XLEN ：查询消息长度；</li><li>XREAD：用于读取消息，可以按 ID 读取数据；</li><li>XDEL ： 根据消息 ID 删除消息；</li><li>DEL ：删除整个 Stream；</li><li>XRANGE ：读取区间消息</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING 和 XACK：<ul><li>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li><li>XACK 命令用于向消息队列确认消息处理已完成；</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis高级数据结构&quot;&gt;&lt;a href=&quot;#Redis高级数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis高级数据结构&quot;&gt;&lt;/a&gt;Redis高级数据结构&lt;/h2&gt;&lt;h3 id=&quot;Bitmaps&quot;&gt;&lt;a href=&quot;#Bitmaps&quot; c</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用数据结构</title>
    <link href="https://eizo01.github.io/posts/a765d482.html"/>
    <id>https://eizo01.github.io/posts/a765d482.html</id>
    <published>2022-11-02T12:00:00.000Z</published>
    <updated>2023-03-17T14:20:13.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h1><p>Redis提供了一些数据结构供我们往Redis中存取数据，最常用的的有5种，<strong>字符串（String）、哈希(Hash)、列表（list）、集合（set）、有序集合（ZSET）</strong>。</p><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p>字符串类型是Redis最基础的数据结构。首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的，所以字符串类型能为其他四种数据结构的学习奠定基础。字符串类型的值实际可以是字符串(简单的字符串、复杂的字符串(例如JSON、XML))、数字(整数、浮点数)，甚至是二进制(图片、音频、视频)，但是<strong>值最大不能超过512MB</strong>。</p><p>（虽然Redis是C写的，C里面有字符串&#x3c;本质使用char数组来实现&gt;，但是处于种种考虑，Redis还是自己实现了字符串类型）</p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="set-设置值"><a href="#set-设置值" class="headerlink" title="set 设置值"></a>set 设置值</h4><p><code>set key value</code><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/1dab86326fa249cd9d1ab118b48e9c6a.png" alt="image.png"></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emos:3&gt;set name zdw</span><br><span class="line"></span><br><span class="line">&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">emos:3&gt;get name</span><br><span class="line"></span><br><span class="line">&quot;zdw&quot;</span><br></pre></td></tr></table></figure><p>set命令有几个选项:</p><ul><li>ex seconds: 为键设置秒级过期时间。</li></ul><ul><li>px milliseconds: 为键设置毫秒级过期时间。</li></ul><ul><li>nx: 键必须不存在,才可以设置成功，用于添加（分布式锁常用）。</li></ul><ul><li>xx: 与nx相反,键必须存在，才可以设置成功,用于更新。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 设置过期时间</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> name zdw ex <span class="number">10</span></span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl name</span><br><span class="line">&quot;5&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl name</span><br><span class="line">&quot;4&quot;</span><br><span class="line">#设置毫秒数</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> name zdw px <span class="number">100</span></span><br><span class="line">&quot;OK</span><br></pre></td></tr></table></figure><p><strong>从执行效果上看，ex参数和expire命令基本一样。还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了set 方法修改了它，它的过期时间会消失。</strong></p><p>而nx和xx执行效果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#键必须不存在,才可以设置成功</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> nx<span class="operator">-</span>name</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> nx<span class="operator">-</span>name zdw nx</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"># 设置xx 键必须存在才能设置</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw xx</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw nx</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw xx</span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure><p>除了set选项，Redis 还提供了setex和 setnx两个命令:</p><p><code>setex key seconds value</code></p><p><code>setnx key value</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 键必须不存在 setnx成功,返回结果为<span class="number">1</span>。setnx失败,返回结果为<span class="number">0</span>，</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setnx zdw01 zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setnx zdw01 zdw</span><br><span class="line">&quot;0&quot;</span><br><span class="line">#设置key过期时间</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setex zdw <span class="number">10</span> zdw</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl zdw</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl zdw</span><br><span class="line">&quot;4&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>setex和 setnx的作用和ex和nx选项是一样的。也就是，setex为键设置秒级过期时间，setnx设置时键必须不存在,才可以设置成功。</strong></p><p>有什么应用场景吗?以setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。当然分布式锁不是只有一个命令就OK了，其中还有很多的东西要注意，我们后面会用单独的分析来讲述基于Redis的分布式锁。</p><h4 id="get-获取值"><a href="#get-获取值" class="headerlink" title="get 获取值"></a>get 获取值</h4><p>如果要获取的键不存在,则返回nil(空):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> zdw01</span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> zdw02</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="mset-批量设置值"><a href="#mset-批量设置值" class="headerlink" title="mset 批量设置值"></a>mset 批量设置值</h4><p>通过mset命令一次性设置4个键值对</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>mset a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span> d <span class="number">4</span></span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure><h4 id="mget-批量获取值"><a href="#mget-批量获取值" class="headerlink" title="mget 批量获取值"></a>mget 批量获取值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>mget a a1 b c c1 d</span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">2</span>) <span class="keyword">null</span></span><br><span class="line"><span class="number">3</span>) &quot;2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;3&quot;</span><br><span class="line"><span class="number">5</span>) <span class="keyword">null</span></span><br><span class="line"><span class="number">6</span>) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>批量获取了键a、b、c、d的值:</p><p>如果有些键不存在,那么它的值为nil(空)，结果是按照传入键的顺序返回。</p><p>批量操作命令可以有效提高效率，假如没有mget这样的命令，要执行n次get命令具体耗时如下:</p><p><strong>n次 get时间=n次网络时间+n次命令时间</strong></p><p>使用mget命令后，要执行n次get命令操作具体耗时如下:</p><p><strong>n次get时间=1次网络时间+n次命令时间</strong></p><p>Redis可以支撑每秒数万的读写操作，但是这指的是<strong>Redis服务端的处理能力</strong>，对于客户端来说，<strong>一次命令除了命令时间还是有网络时间，假设网络时间为1毫秒，命令时间为0.1毫秒(按照每秒处理1万条命令算)，那么执行1000次 get命令需要1.1秒(1000<em>1+1000</em>0.1=1100ms)，1次mget命令的需要0.101秒(1<em>1+1000</em>0.1=101ms)。</strong></p><h4 id="Incr-数字运算"><a href="#Incr-数字运算" class="headerlink" title="Incr 数字运算"></a>Incr 数字运算</h4><p>incr命令用于对值做自增操作,返回结果分为三种情况：</p><ul><li>值不是整数,返回错误。</li></ul><ul><li>值是整数，返回自增后的结果。</li></ul><ul><li>键不存在，按照值为0自增,返回结果为1。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 键不存在，按照值为<span class="number">0</span>自增,返回结果为<span class="number">1</span>。</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">exists</span> incr<span class="operator">-</span>key</span><br><span class="line">&quot;0&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr incr<span class="operator">-</span>key</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr incr<span class="operator">-</span>key</span><br><span class="line">&quot;2&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> hello zdw</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"># 值不是整数,返回错误。</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr hello</span><br><span class="line">&quot;ERR value is not an integer or out of range&quot;</span><br></pre></td></tr></table></figure><p>除了incr命令，Redis提供了<code>decr</code>(自减)、 <code>incrby</code>(自增指定数字)、<code>decrby</code>(自减指定数字)、<code>incrbyfloat</code>（自增浮点数)，具体效果请大家自行尝试。</p><h4 id="append追加指令"><a href="#append追加指令" class="headerlink" title="append追加指令"></a>append追加指令</h4><p>append可以向字符串尾部追加值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello </span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>append hello good</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello </span><br><span class="line">&quot;zdwgood&quot;</span><br></pre></td></tr></table></figure><h4 id="strlen-字符串长度"><a href="#strlen-字符串长度" class="headerlink" title="strlen 字符串长度"></a>strlen 字符串长度</h4><p>返回字符串长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>strlen hello</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> k1 &quot;中文&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>strlen k1</span><br><span class="line">&quot;6&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> k1</span><br><span class="line">&quot;中文&quot;</span><br></pre></td></tr></table></figure><p>注意：每个中文占3个字节</p><h4 id="getset-设置并返回原值"><a href="#getset-设置并返回原值" class="headerlink" title="getset 设置并返回原值"></a>getset 设置并返回原值</h4><p>客户端测试不出来，在linux测试出来</p><p>getset和set一样会设置值,但是不同的是，它同时会返回键原来的值</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d568dc6e0a6c4adeae13d8f63a8fd0d8.png" alt="image.png"></p><h4 id="setrange-设置指定位置的字符"><a href="#setrange-设置指定位置的字符" class="headerlink" title="setrange 设置指定位置的字符"></a>setrange 设置指定位置的字符</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgood&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setrange hello <span class="number">4</span> d</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgdod&quot;</span><br></pre></td></tr></table></figure><p>下标从0开始计算。</p><h4 id="getrange-截取字符串"><a href="#getrange-截取字符串" class="headerlink" title="getrange 截取字符串"></a>getrange 截取字符串</h4><p>getrange 截取字符串中的一部分，形成一个子串，需要指明开始和结束的偏移量，截取的范围是个闭区间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgood&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>getrange hello <span class="number">0</span> <span class="number">2</span></span><br><span class="line">&quot;zdw&quot;</span><br></pre></td></tr></table></figure><h4 id="命令的时间复杂度"><a href="#命令的时间复杂度" class="headerlink" title="命令的时间复杂度"></a>命令的时间复杂度</h4><p>字符串这些命令中，除了del 、mset、 mget支持多个键的批量操作，时间复杂度和键的个数相关，为O(n)，getrange和字符串长度相关，也是O(n)，其余的命令基本上都是O(1)的时间复杂度，在速度上还是非常快的。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>字符串类型的使用场景很广泛：</p><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL作为存储层，绝大部分请求的数据都是从Redis中获取。由于Redis具有支撑高并发的特性,所以缓存通常能起到加速读写和降低后端压力的作用。</p><p><strong>计数</strong></p><p>使用Redis 作为计数的基础工具，它可以实现快速计数、查询缓存的功能,同时数据可以异步落地到其他数据源。</p><p><strong>共享Session</strong></p><p>一个分布式Web服务将用户的Session信息（例如用户登录信息)保存在各自服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器上，用户刷新一次访问可能会发现需要重新登录，这个问题是用户无法容忍的。</p><p>为了解决这个问题,可以使用Redis将用户的Session进行集中管理,，在这种模式下只要保证Redis是高可用和扩展性的,每次用户更新或者查询登录信息都直接从Redis中集中获取。</p><p><strong>限速</strong></p><p>比如，很多应用出于安全的考虑,会在每次进行登录时,让用户输入手机验证码,从而确定是否是用户本人。但是为了短信接口不被频繁访问,会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。一些网站限制一个IP地址不能在一秒钟之内方问超过n次也可以采用类似的思路。</p><h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h2><p>Java里提供了HashMap，Redis中也有类似的数据结构，就是哈希类型。但是要注意，哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值。</p><h3 id="操作命令-1"><a href="#操作命令-1" class="headerlink" title="操作命令"></a>操作命令</h3><p>基本上，哈希的操作命令和字符串的操作命令很类似，很多命令在字符串类型的命令前面加上了h字母，代表是操作哈希类型，同时还要指明要操作的field的值。</p><h4 id="hset设值"><a href="#hset设值" class="headerlink" title="hset设值"></a>hset设值</h4><p>hset user:1 name lijin</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zdw</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果设置成功会返回1，反之会返回0。此外Redis提供了hsetnx命令，它们的关系就像set和setnx命令一样,只不过作用域由键变为field。</p><h4 id="hget取值"><a href="#hget取值" class="headerlink" title="hget取值"></a>hget取值</h4><p>hget user:1 name</p><p>如果键或field不存在，会返回nil。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">1</span> name </span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">1</span> name1</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">2</span> name1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="hdel删除field"><a href="#hdel删除field" class="headerlink" title="hdel删除field"></a>hdel删除field</h4><p>hdel会删除一个或多个field，返回结果为成功删除field的个数。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/45ed460d37c04b31bbd5122cd964a0e3.png" alt="image.png"></p><h4 id="hlen计算field个数"><a href="#hlen计算field个数" class="headerlink" title="hlen计算field个数"></a>hlen计算field个数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hlen <span class="keyword">user</span>:<span class="number">1</span> </span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zzz</span><br><span class="line">&quot;0&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name1 zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hlen <span class="keyword">user</span>:<span class="number">1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="hmset批量设值"><a href="#hmset批量设值" class="headerlink" title="hmset批量设值"></a>hmset批量设值</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/dbad743d5eed4f7eb98c39e345ba2687.png" alt="image.png"></p><h4 id="hmget批量取值"><a href="#hmget批量取值" class="headerlink" title="hmget批量取值"></a>hmget批量取值</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/04c34b6e61004b32835ff377a05a5586.png" alt="image.png"></p><h4 id="hexists判断field是否存在"><a href="#hexists判断field是否存在" class="headerlink" title="hexists判断field是否存在"></a>hexists判断field是否存在</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7a182a0b69dc43c7a76f2119eca3910e.png" alt="image.png"></p><p>若存在返回1，不存在返回0</p><h4 id="hkeys获取所有field"><a href="#hkeys获取所有field" class="headerlink" title="hkeys获取所有field"></a>hkeys获取所有field</h4><p>它返回指定哈希键所有的field</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7f84f9381fcf48a0ac43af16dbea6b6c.png" alt="image.png"></p><h4 id="hvals获取所有value"><a href="#hvals获取所有value" class="headerlink" title="hvals获取所有value"></a>hvals获取所有value</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d4e3825c1bd446da9973b971834c37be.png" alt="image.png"></p><h4 id="hgetall获取所有field与value"><a href="#hgetall获取所有field与value" class="headerlink" title="hgetall获取所有field与value"></a>hgetall获取所有field与value</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/338a05689b304021aa9b1cd6b601ffd9.png" alt="image.png"></p><p>在使用hgetall时，如果哈希元素个数比较多，会存在阻塞Redis的可能。如果只需要获取部分field，可以使用hmget，如果一定要获取全部field-value，可以使用hscan命令，该命令会渐进式遍历哈希类型，hscan将在后面的章节介绍。</p><h4 id="hincrby增加"><a href="#hincrby增加" class="headerlink" title="hincrby增加"></a>hincrby增加</h4><p>hincrby和 hincrbyfloat，就像incrby和incrbyfloat命令一样，但是它们的作用域是filed。</p><h4 id="hstrlen-计算value的字符串长度"><a href="#hstrlen-计算value的字符串长度" class="headerlink" title="hstrlen 计算value的字符串长度"></a>hstrlen 计算value的字符串长度</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4c52aa4d0f0c4841afa87011982c2151.png" alt="image.png"></p><h4 id="命令的时间复杂度-1"><a href="#命令的时间复杂度-1" class="headerlink" title="命令的时间复杂度"></a>命令的时间复杂度</h4><p>哈希类型的操作命令中，hdel,hmget,hmset的时间复杂度和命令所带的field的个数相关O(k)，hkeys,hgetall,hvals和存储的field的总数相关，O(N)。其余的命令时间复杂度都是O(1)。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>从前面的操作可以看出，String和Hash的操作非常类似，那为什么要弄一个hash出来存储。</p><p>哈希类型比较适宜存放对象类型的数据，我们可以比较下，如果数据库中表记录user为：</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zdw</td><td>18</td></tr><tr><td>2</td><td>msb</td><td>20</td></tr></tbody></table></div><p><strong>1、使用String类型</strong></p><p>需要一条条去插入获取。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">1</span>:name zdw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">1</span>:age  <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">2</span>:name msb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">2</span>:age  <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>优点：简单直观，每个键对应一个值</strong></p><p><strong>缺点：键数过多，占用内存多，用户信息过于分散，不用于生产环境</strong></p><p><strong>2、将对象序列化存入redis</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="keyword">user</span>:<span class="number">1</span> serialize(<span class="keyword">user</span>Info);</span><br></pre></td></tr></table></figure><p><strong>优点：编程简单，若使用序列化合理内存使用率高</strong></p><p><strong>缺点：序列化与反序列化有一定开销，更新属性时需要把userInfo全取出来进行反序列化，更新后再序列化到redis</strong></p><p><strong>3、使用hash类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hmset <span class="keyword">user</span>:<span class="number">1</span> name zdw age <span class="number">18</span></span><br><span class="line"></span><br><span class="line">hmset <span class="keyword">user</span>:<span class="number">2</span> name msb age <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>优点：简单直观，使用合理可减少内存空间消耗</strong></p><p><strong>缺点：要控制内部编码格式，不恰当的格式会消耗更多内存</strong></p><h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>列表( list)类型是用来存储多个有序的字符串，a、b、c、c、b四个元素从左到右组成了一个有序的列表,列表中的每个字符串称为元素(element)，一个列表最多可以存储(2^32-1)个元素(<em>4294967295</em>)。</p><p><img src="https://zdwtop.cn/blog/b2c5e0d8bd6243e59b0c32aa5caa49f1.png" alt="image.png"></p><p>在Redis 中，可以对列表两端插入( push)和弹出(pop)，还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p><p><strong>列表类型有两个特点:</strong></p><p>第一、列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</p><p>第二、列表中的元素可以是重复的。</p><h3 id="操作命令-2"><a href="#操作命令-2" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="lrange-获取指定范围内的元素列表（不会删除元素）"><a href="#lrange-获取指定范围内的元素列表（不会删除元素）" class="headerlink" title="lrange 获取指定范围内的元素列表（不会删除元素）"></a>lrange 获取指定范围内的元素列表（不会删除元素）</h4><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lrange</span> key start end</span><br></pre></td></tr></table></figure><p>索引下标特点：从左到右为0到N-1</p><p><code>lrange 0 -1</code>命令可以从左到右获取列表的所有元素</p><h4 id="rpush-向右插入"><a href="#rpush-向右插入" class="headerlink" title="rpush 向右插入"></a>rpush 向右插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist a</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist b</span><br><span class="line">&quot;2&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist c</span><br><span class="line">&quot;3&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist d</span><br><span class="line">&quot;4&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange demolist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;c&quot;</span><br><span class="line"><span class="number">4</span>) &quot;d&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/33e03ce96b3248ceaac60ccb4fc0b1d8.png" alt="image.png"></p><h4 id="lpush-向左插入"><a href="#lpush-向左插入" class="headerlink" title="lpush 向左插入"></a>lpush 向左插入</h4><p><img src="https://zdwtop.cn/blog/302233f9f0284e46ae26930ac8be1cd2.png" alt="image.png"></p><p><img src="https://zdwtop.cn/blog/abba1d7c8aea4e42a83ca17476c4b9cd.png" alt="image.png"></p><h4 id="linsert-在某个元素前或后插入新元素"><a href="#linsert-在某个元素前或后插入新元素" class="headerlink" title="linsert 在某个元素前或后插入新元素"></a>linsert 在某个元素前或后插入新元素</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE<span class="operator">|</span>AFTER pivot <span class="keyword">value</span></span><br><span class="line"># a之后查个g</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>LINSERT list before a g</span><br><span class="line">&quot;5&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;g&quot;</span><br><span class="line"><span class="number">2</span>) &quot;a&quot;</span><br><span class="line"><span class="number">3</span>) &quot;b&quot;</span><br><span class="line"><span class="number">4</span>) &quot;c&quot;</span><br><span class="line"><span class="number">5</span>) &quot;d&quot;</span><br><span class="line"># a之后插个f</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>LINSERT list after a f</span><br><span class="line">&quot;6&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;g&quot;</span><br><span class="line"><span class="number">2</span>) &quot;a&quot;</span><br><span class="line"><span class="number">3</span>) &quot;f&quot;</span><br><span class="line"><span class="number">4</span>) &quot;b&quot;</span><br><span class="line"><span class="number">5</span>) &quot;c&quot;</span><br><span class="line"><span class="number">6</span>) &quot;d&quot;</span><br></pre></td></tr></table></figure><h4 id="lpop-从列表左侧弹出（会删除元素）"><a href="#lpop-从列表左侧弹出（会删除元素）" class="headerlink" title="lpop 从列表左侧弹出（会删除元素）"></a>lpop 从列表左侧弹出（会删除元素）</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/cf3b7a2f1d85434689734dea9d467c0f.png" alt="image.png">r</p><p>请注意，弹出来元素就没了。</p><h4 id="rpop-从列表右侧弹出"><a href="#rpop-从列表右侧弹出" class="headerlink" title="rpop 从列表右侧弹出"></a>rpop 从列表右侧弹出</h4><p>rpop将会把列表最右侧的元素d弹出。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/6f55895f739b4a32a1e1c8fde0649031.png" alt="image.png"></p><h4 id="lrem-对指定元素进行删除"><a href="#lrem-对指定元素进行删除" class="headerlink" title="lrem 对指定元素进行删除"></a>lrem 对指定元素进行删除</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/e533d9a779074c3286d81031ca408450.png" alt="image.png"></p><p>lrem命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况：</p><ul><li>count&gt;0，从左到右,删除最多count个元素。</li></ul><ul><li>count&#x3c;0，从右到左,删除最多count绝对值个元素。</li></ul><ul><li>count=0，删除所有。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/ad2833b4c011453f91928891e8a0e036.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/584b9986d80c46668f3fda91c466e340.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/ba19aa483a884537a687051f80967ebb.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/0480e571bc1e44f79b2e80b376ec288e.png" alt="image.png"></p><p>返回值是实际删除元素的个数。</p><h4 id="ltirm-按照索引范围修剪列表"><a href="#ltirm-按照索引范围修剪列表" class="headerlink" title="ltirm 按照索引范围修剪列表"></a>ltirm 按照索引范围修剪列表</h4><p>例如想保留列表中第0个到第1个元素</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/8e52841e88f34a05888da5df0a8a4121.png" alt="image.png">ls</p><h4 id="lset修改指定索引下标的元素"><a href="#lset修改指定索引下标的元素" class="headerlink" title="lset修改指定索引下标的元素"></a>lset修改指定索引下标的元素</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/663c682ce56444e382fc3f1b4da4253c.png" alt="image.png"></p><h4 id="lindex-获取列表指定索引下标的元素"><a href="#lindex-获取列表指定索引下标的元素" class="headerlink" title="lindex 获取列表指定索引下标的元素"></a>lindex 获取列表指定索引下标的元素</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/f0b6ab8eca224305bcd97a4916c33947.png" alt="image.png">l</p><h4 id="llen-获取列表长度"><a href="#llen-获取列表长度" class="headerlink" title="llen 获取列表长度"></a>llen 获取列表长度</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/31f34b4b3ec24f2e89d42b958dc3f343.png" alt="image.png"></p><h4 id="blpop和brpop阻塞式弹出元素"><a href="#blpop和brpop阻塞式弹出元素" class="headerlink" title="blpop和brpop阻塞式弹出元素"></a>blpop和brpop阻塞式弹出元素</h4><p>blpop和brpop是lpop和rpop的阻塞版本，除此之外还支持多个列表类型，也支持设定阻塞时间，单位秒，如果阻塞时间为0，表示一直阻塞下去。我们以brpop为例说明。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a83e89040af7495da20b56ef826e6520.png" alt="image.png"></p><p>A客户端阻塞了（因为没有元素就会阻塞）</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/c11fe0ec650c401cbd69500d99805f85.png" alt="image.png"></p><p>A客户端一直处于阻塞状态。此时我们从另一个客户端B执行</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/c4c83e7fe2ac4f6385ac04b1ecbcf231.png" alt="image.png"></p><p>A客户端则输出</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4b2c7c7b95da4190ab6c772075faec7c.png" alt="image.png"></p><p>注意：brpop后面如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>列表类型可以用于比如：</p><p>消息队列，Redis 的 lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素,多个客户端保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表,因为列表不但是有序的,同时支持按照索引范围获取元素。</p><p><strong>实现其他数据结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpush <span class="operator">+</span>lpop <span class="operator">=</span>Stack（栈)</span><br><span class="line"></span><br><span class="line">lpush <span class="operator">+</span> rpop <span class="operator">=</span>Queue(队列)</span><br><span class="line"></span><br><span class="line">lpsh <span class="operator">+</span> ltrim <span class="operator">=</span>Capped Collection（有限集合)</span><br><span class="line"></span><br><span class="line">lpush <span class="operator">+</span> brpop<span class="operator">=</span>Message Queue(消息队列)</span><br></pre></td></tr></table></figure><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p><img src="https://zdwtop.cn/blog/4b28f3a2aa6b4d4f9c5dd09317508102.png" alt="image.png"></p><p>集合( set）类型也是用来保存多个的字符串元素,但和列表类型不一样的是，<strong>集合中不允许有重复元素,并且集合中的元素是无序的,不能通过索引下标获取元素。</strong></p><p>一个集合最多可以存储2的32次方-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取<strong>交集、并集、差集</strong>，合理地使用好集合类型,能在实际开发中解决很多实际问题。</p><h3 id="集合内操作命令"><a href="#集合内操作命令" class="headerlink" title="集合内操作命令"></a>集合内操作命令</h3><h4 id="sadd-添加元素"><a href="#sadd-添加元素" class="headerlink" title="sadd 添加元素"></a>sadd 添加元素</h4><p>允许添加多个，返回结果为添加成功的元素个数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d94f1e8871054f6dad9dad1d245d3dfb.png" alt="image.png"></p><h4 id="srem-删除元素"><a href="#srem-删除元素" class="headerlink" title="srem 删除元素"></a>srem 删除元素</h4><p>允许删除多个，返回结果为成功删除元素个数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/fdcc39ccdf4c4ca1bb26003e65d40ec7.png" alt="image.png"></p><h4 id="scard-计算元素个数"><a href="#scard-计算元素个数" class="headerlink" title="scard 计算元素个数"></a>scard 计算元素个数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/292819f68b294180ad037dc590e8c562.png" alt="image.png"></p><h4 id="sismember-判断元素是否在集合中"><a href="#sismember-判断元素是否在集合中" class="headerlink" title="sismember 判断元素是否在集合中"></a>sismember 判断元素是否在集合中</h4><p>如果给定元素element在集合内返回1，反之返回0</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/94148d18517a44d99cd6c7716d07f9b1.png" alt="image.png"></p><h4 id="srandmember-随机从集合返回指定个数元素"><a href="#srandmember-随机从集合返回指定个数元素" class="headerlink" title="srandmember 随机从集合返回指定个数元素"></a>srandmember 随机从集合返回指定个数元素</h4><p>指定个数如果不写默认为1</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/2b386e0de6df44c685dc69e95bf4e7a2.png" alt="image.png"></p><h4 id="spop-从集合随机弹出元素"><a href="#spop-从集合随机弹出元素" class="headerlink" title="spop 从集合随机弹出元素"></a>spop 从集合随机弹出元素</h4><p>同样可以指定个数，如果不写默认为1，注意，既然是弹出，spop命令执行后,元素会从集合中删除,而srandmember不会。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/172580272c8b4413908328fad51e0537.png" alt="image.png"></p><h4 id="smembers-获取所有元素-不会弹出元素"><a href="#smembers-获取所有元素-不会弹出元素" class="headerlink" title="smembers 获取所有元素(不会弹出元素)"></a>smembers 获取所有元素(不会弹出元素)</h4><p>返回结果是无序的</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/f16f1615505b49a2aa5198a75168c4b2.png" alt="image.png"></p><h4 id="集合间操作命令"><a href="#集合间操作命令" class="headerlink" title="集合间操作命令"></a>集合间操作命令</h4><p>现在有两个集合,它们分别是set1和set2</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/8546a5e8eff348bd8c4879fbc37db67b.png" alt="image.png"></p><h4 id="sinter-求多个集合的交集"><a href="#sinter-求多个集合的交集" class="headerlink" title="sinter 求多个集合的交集"></a>sinter 求多个集合的交集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/80dd47f94b06433daa0b1f19be6a684f.png" alt="image.png"></p><h4 id="suinon-求多个集合的并集"><a href="#suinon-求多个集合的并集" class="headerlink" title="suinon 求多个集合的并集"></a>suinon 求多个集合的并集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/614e67ffe97646389a781099b6e074fd.png" alt="image.png"></p><h4 id="sdiff-求多个集合的差集"><a href="#sdiff-求多个集合的差集" class="headerlink" title="sdiff 求多个集合的差集"></a>sdiff 求多个集合的差集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4c0e783c37e64c15866bb08ccc0abbf8.png" alt="image.png"></p><h4 id="将交集、并集、差集的结果保存"><a href="#将交集、并集、差集的结果保存" class="headerlink" title="将交集、并集、差集的结果保存"></a>将交集、并集、差集的结果保存</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">suionstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">sdiffstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure><p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis提供了上面三个命令(原命令+store)将集合间交集、并集、差集的结果保存在destination key中，例如：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/450fcb6c2e2342b39925c1779a4ba369.png" alt="image.png"></p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是<strong>标签(tag)</strong>。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。</p><p>例如一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。</p><p>除此之外，集合还可以通过生成随机数进行比如抽奖活动，以及社交图谱等等。</p><h2 id="有序集合（ZSET）"><a href="#有序集合（ZSET）" class="headerlink" title="有序集合（ZSET）"></a>有序集合（ZSET）</h2><p><img src="https://zdwtop.cn/blog/fe24d4258f4b4dd99ad52a6752a840ae.png" alt="image.png"></p><p>有序集合相对于哈希、列表、集合来说会有一点点陌生,但既然叫有序集合,那么它和集合必然有着联系,<strong>它保留了集合不能有重复成员的特性,但不同的是,有序集合中的元素可以排序。</strong>但是它和列表使用索引下标作为排序依据不同的是,它<strong>给每个元素设置一个分数( score)作为排序的依据。</strong></p><p>有序集合中的元素不能重复，但是<strong>score可以重复</strong>，就和一个班里的同学学号不能重复,但是考试成绩可以相同。</p><p>有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p><h3 id="集合内操作命令-1"><a href="#集合内操作命令-1" class="headerlink" title="集合内操作命令"></a>集合内操作命令</h3><h4 id="zadd添加成员"><a href="#zadd添加成员" class="headerlink" title="zadd添加成员"></a>zadd添加成员</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/353cb7b71ca04daab3cf7fb99ceb36f6.png" alt="image.png"></p><p>返回结果代表成功添加成员的个数</p><p>要注意:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a8a349c237304f6c94f0a16f5ae3ed24.png" alt="image.png"></p><p>zadd命令还有四个选项nx、xx、ch、incr 四个选项</p><ul><li>nx: member必须不存在，才可以设置成功，用于添加。</li></ul><ul><li>xx: member必须存在，才可以设置成功,用于更新。</li></ul><ul><li>ch: 返回此次操作后,有序集合元素和分数发生变化的个数</li></ul><ul><li>incr: 对score做增加，相当于后面介绍的<code>zincrby</code></li></ul><h4 id="zcard-计算成员个数"><a href="#zcard-计算成员个数" class="headerlink" title="zcard 计算成员个数"></a>zcard 计算成员个数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/9eb0d86663fd45e6a3032c05c1870339.png" alt="image.png"></p><h4 id="zscore-计算某个成员的分数"><a href="#zscore-计算某个成员的分数" class="headerlink" title="zscore 计算某个成员的分数"></a>zscore 计算某个成员的分数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7da7b741030b4b2b9863d569198f001d.png" alt="image.png"></p><p>如果成员不存在则返回nil</p><h4 id="zrank计算成员的排名"><a href="#zrank计算成员的排名" class="headerlink" title="zrank计算成员的排名"></a>zrank计算成员的排名</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7395eb62a4fa4e669cf201799aca069e.png" alt="image.png"></p><p>zrank是从分数从低到高返回排名</p><p><code>zrevrank</code>反之很明显，排名从0开始计算。</p><h4 id="zrem-删除成员"><a href="#zrem-删除成员" class="headerlink" title="zrem 删除成员"></a>zrem 删除成员</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d4e23637dda8461abba76c303cfbfbad.png" alt="image.png"></p><p>允许一次删除多个成员。</p><p>返回结果为成功删除的个数。</p><h4 id="zincrby-增加成员的分数"><a href="#zincrby-增加成员的分数" class="headerlink" title="zincrby 增加成员的分数"></a>zincrby 增加成员的分数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/b1a0193040334a0f90ddb66bce53fe0c.png" alt="image.png"></p><h4 id="zrange和zrevrange返回指定排名范围的成员"><a href="#zrange和zrevrange返回指定排名范围的成员" class="headerlink" title="zrange和zrevrange返回指定排名范围的成员"></a>zrange和zrevrange返回指定排名范围的成员</h4><p>有序集合是按照分值排名的，zrange是从低到高返回,zrevrange反之。如果加上<br>withscores选项，同时会返回成员的分数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d2a8d64fce484b64bf95f0a886fa1f45.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a17fc90c48dd498f9539f5b834ada3bb.png" alt="image.png"></p><h4 id="zrangebyscore返回指定分数范围的成员"><a href="#zrangebyscore返回指定分数范围的成员" class="headerlink" title="zrangebyscore返回指定分数范围的成员"></a>zrangebyscore返回指定分数范围的成员</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key <span class="built_in">min</span> <span class="built_in">max</span> [withscores] [limit <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br><span class="line">zrevrangebyscore key <span class="built_in">max</span> <span class="built_in">min</span> [withscores][limit <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><p>其中<code>zrangebyscore</code>按照分数从低到高返回，<code>zrevrangebyscore</code>反之。例如下面操作从低到高返回200到221分的成员，<code>withscores</code>选项会同时返回每个成员的分数。</p><p>同时<code>min</code>和<code>max</code>还支持开区间(小括号）和闭区间(中括号)，-inf和+inf分别代表无限小和无限大:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/de92b2a82134468ab69bbb8718ccfd1f.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/92edbaef3b2c4c4c9a7ee0daac41ad0a.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/e5dc53cdbff941c9814590973ac96499.png" alt="image.png"></p><h4 id="zcount-返回指定分数范围成员个数"><a href="#zcount-返回指定分数范围成员个数" class="headerlink" title="zcount 返回指定分数范围成员个数"></a>zcount 返回指定分数范围成员个数</h4><p>zcount key min max</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/82a1a39c69bf4c8395411312fd276515.png" alt="image.png"></p><h4 id="zremrangebyrank-按升序删除指定排名内的元素"><a href="#zremrangebyrank-按升序删除指定排名内的元素" class="headerlink" title="zremrangebyrank 按升序删除指定排名内的元素"></a>zremrangebyrank 按升序删除指定排名内的元素</h4><p>zremrangebyrank key start end</p><h4 id="zremrangebyscore-删除指定分数范围的成员"><a href="#zremrangebyscore-删除指定分数范围的成员" class="headerlink" title="zremrangebyscore 删除指定分数范围的成员"></a>zremrangebyscore 删除指定分数范围的成员</h4><p>zremrangebyscore key min max</p><h3 id="集合间操作命令-1"><a href="#集合间操作命令-1" class="headerlink" title="集合间操作命令"></a>集合间操作命令</h3><h4 id="zinterstore-交集"><a href="#zinterstore-交集" class="headerlink" title="zinterstore 交集"></a>zinterstore 交集</h4><p><code>zinterstore</code><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/0e0688f60b404126895ffbbf4c6ae290.png" alt="image.png"></p><p>这个命令参数较多，下面分别进行说明</p><ul><li>destination:交集计算结果保存到这个键。</li></ul><ul><li>numkeys:需要做交集计算键的个数。</li></ul><ul><li>key [key …]:需要做交集计算的键。</li></ul><ul><li><p>weights weight</p></li><li><p>[weight …]:每个键的权重，在做交集计算时，每个键中的每个member 会将自己分数乘以这个权重,每个键的权重默认是1。</p></li><li><p>aggregate sum | min |max:计算成员交集后，分值可以按照sum(和)、min(最小值)、max(最大值)做汇总,默认值是sum。</p></li></ul><p>不太好理解，我们用一个例子来说明。（算平均分）</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/cfc3967b70cb4dcea41057c3708d8616.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/65f2bee807e1446989277c0fadff86cf.png" alt="image.png"></p><h4 id="zunionstore-并集"><a href="#zunionstore-并集" class="headerlink" title="zunionstore 并集"></a>zunionstore 并集</h4><p>该命令的所有参数和zinterstore是一致的，只不过是做并集计算，大家可以自行实验。</p><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的:按照时间、按照播放数量、按照获得的赞数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis常用数据结构&quot;&gt;&lt;a href=&quot;#Redis常用数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis常用数据结构&quot;&gt;&lt;/a&gt;Redis常用数据结构&lt;/h1&gt;&lt;p&gt;Redis提供了一些数据结构供我们往Redis中存取数据，最常用的的</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://eizo01.github.io/posts/6a343b7f.html"/>
    <id>https://eizo01.github.io/posts/6a343b7f.html</id>
    <published>2022-11-01T12:00:00.000Z</published>
    <updated>2022-11-12T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的技术全景">Redis的技术全景</h2><p>本质上就是，Redis 的知识都包括什么呢？简单来说，就是“两大维度，三大主线”</p><p><img src="https://zdwtop.cn/blog/ba2269e45c1b4a77bf097ff40de3aa8e.png" alt="image.png"></p><h3 id="两大维度">两大维度</h3><p>两大维度：<strong>应用维度、底层原理维度</strong></p><p>我们知道，缓存和集群是Redis 的两大广泛的应用场景。同时Redis 丰富的数据模型，就导致它有很多零碎的应用场景，很多很杂。而且，还有一些问题隐藏得比较深，只有特定的业务场景下（比如亿级访问压力场景）才会出现，所以同时还必须精通Redis的数据结构。</p><h3 id="Redis应用场景"><strong>Redis应用场景</strong></h3><h4 id="1-缓存">1.缓存</h4><p>缓存机制几乎在所有的大型网站都有使用，合理地使用缓存不仅可以加快数据的访问速度，而且能够有效地降低后端数据源的压力。Redis提供了键值过期时间设置,并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。可以这么说,一个合理的缓存设计能够为一个网站的稳定保驾护航。</p><p>一般MySQL数据库写的并发是600/s，读的2000/s,对于大型互联网项目的百万并发，根本扛不住，Redis的官方显示Redis能够单台达到10W+/s的并发。</p><h4 id="2-排行榜系统">2.排行榜系统</h4><p>排行榜系统几乎存在于所有的网站，例如按照热度排名的排行榜，按照发布时间的排行榜，按照各种复杂维度计算出的排行榜，Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p><h4 id="3-计数器应用">3.计数器应用</h4><p>计数器在网站中的作用至关重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据的实时性，每一次播放和浏览都要做加1的操作，如果并发量很大对于传统关系型数据的性能是一种挑战。Redis天然支持计数功能而且计数的性能也非常好,可以说是计数器系统的重要选择。</p><h4 id="4-社交网络">4.社交网络</h4><p>赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大,而且传统的关系型数据不太适合保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能。</p><h4 id="5-消息队列系统">5.消息队列系统</h4><p>消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列的功能，虽然和专业的消息队列比还不够足够强大,但是对于一般的消息队列功能基本可以满足。这个是Redis的作者参考了Kafka做的拓展。</p><h3 id="三大主线">三大主线</h3><p>三大主线：高性能、高可靠和高可扩展</p><p>高性能：包括线程模型、数据结构、持久化、网络框架；<br>高可靠：包括主从复制、哨兵机制；<br>高可扩：包括数据分片、负载均衡。</p><p>因为Redis的应用场景非常多，不同的公司有不同的玩法，但如何不掌握三高这条主线的话，你会遇到以下问题：</p><p>1、数据结构的复杂度、跨 CPU 核的访问会导致CPU飙升的问题</p><p>2、主从同步和 AOF 的内存竞争，这些会导致内存问题</p><p>3、在 SSD 上做快照的性能抖动，这些会导致存储持久化的问题</p><p>4、多实例时的异常网络丢包的问题</p><h2 id="Redis全局命令">Redis全局命令</h2><p>对于键值数据库而言，基本的数据模型是 key-value 模型，Redis 支持的 value 类型包括了 String、哈希表、列表、集合等，而Memcached支持的 value 类型仅为 String 类型。</p><p>Redis里面有16个库，但是Redis的分库功能没啥意义（默认就是0号库，尤其是集群操作的时候），我们一般都是默认使用0号库进行操作。</p><p>在了解Rediskey-value 模型之前，Redis的有一些全局命令，需要我们提前了解。</p><h4 id="keys命令"><strong>keys命令</strong></h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">keys</span> *</span><br><span class="line"><span class="built_in">keys</span> L*</span><br></pre></td></tr></table></figure><p>查看所有键(支持通配符)：</p><p><img src="HTTPs://zdwtop.cn/blog/a38baeb051bd46dab430d3037bedc48b.png" alt="image.png"></p><p>但是这个命令请慎用，因为keys命令要把所有的key-value对全部拉出去，如果生产环境的键值对特别多的话，会对Redis的性能有很大的影响，推荐使用<code>dbsize</code>。</p><p><strong>keys命令会遍历所有键，所以它的时间复杂度是o(n)，当Redis保存了大量键时线上环境禁止使用keys命令。</strong></p><h4 id="dbsize命令"><strong>dbsize命令</strong></h4><p>dbsize命令会返回当前数据库中键的总数。</p><p><img src="HTTPs://zdwtop.cn/blog/21ed59cad4e84610869308640d57718c.png" alt="image.png"></p><p>dbsize命令在计算键总数时不会遍历所有键,而是直接获取 Redis内置的键总数变量,所以dbsize命令的时间复杂度是<strong>O(1)</strong>。</p><h4 id="exists"><strong>exists</strong></h4><p>检查键是否存在，存在返回1，不存在返回0。</p><p><img src="HTTPs://zdwtop.cn/blog/706705c0c9d7418b8b72eb0be7228f85.png" alt="image.png"></p><h4 id="del"><strong>del</strong></h4><p>删除键，无论值是什么数据结构类型,del命令都可以将其删除。**返回删除键个数，删除不存在键返回0。**同时del命令可以支持删除多个键。</p><p><img src="HTTPs://zdwtop.cn/blog/2865421882494708bb0f78fd458a3a59.png" alt="image.png"></p><p><img src="HTTPs://zdwtop.cn/blog/5d304a87b9d44633893581107f0d310a.png" alt="image.png"></p><h4 id="键过期"><strong>键过期</strong></h4><h5 id="expire"><strong>expire</strong></h5><p>Redis支持对键添加过期时间,当超过过期时间后,会自动删除键，时间单位秒。</p><p>ttl命令会返回键的剩余过期时间,它有3种返回值:</p><p>大于等于0的整数:键剩余的过期时间。</p><p>-1:键没设置过期时间。</p><p>-2:键不存在</p><p>除了expire、ttl命令以外，Redis还提供了expireat、pexpire,pexpireat、pttl、persist等一系列命令。</p><h5 id="expireat-key"><strong>expireat key</strong></h5><p>timestamp: 键在秒级时间截timestamp后过期。</p><p>ttl命令和pttl都可以查询键的剩余过期时间，但是pttl精度更高可以达到毫秒级别，有3种返回值:</p><p>大于等于0的整数:键剩余的过期时间(ttl是秒，pttl是毫秒)。</p><p>-1:键没有设置过期时间。</p><p>-2:键不存在。</p><h5 id="pexpire-key"><strong>pexpire key</strong></h5><p>milliseconds:键在milliseconds毫秒后过期。</p><h5 id="pexpireat-key"><strong>pexpireat key</strong></h5><p>milliseconds-timestamp键在毫秒级时间戳timestamp后过期。</p><p><strong>在使用Redis相关过期命令时,需要注意以下几点。</strong></p><p>1)如果expire key 的键不存在,返回结果为0:</p><p>2）如果过期时间为负值,键会立即被删除，犹如使用del命令一样:</p><p>3 ) persist命令可以将键的过期时间清除:</p><p><img src="HTTPs://zdwtop.cn/blog/e288cca51dd446a19384a29adcc1faf7.png" alt="image.png"></p><p>4）对于字符串类型键，执行set命令会去掉过期时间，这个问题很容易在开发中被忽视。</p><p><img src="HTTPs://zdwtop.cn/blog/5b749a4fd43248ce9af261080058ebaf.png" alt="image.png"></p><p>5 ) Redis不支持二级数据结构(例如哈希、列表)内部元素的过期功能，不能对二级数据结构做过期时间设置。</p><h5 id="type"><strong>type</strong></h5><p>返回键的数据结构类型，例如<strong>键lijin是字符串类型，返回结果为string。键mylist是列表类型，返回结果为list，键不存在返回none</strong></p><p><img src="HTTPs://zdwtop.cn/blog/a5cf8aefd7b2414b9e1fb6ad96f24b47.png" alt="image.png"></p><h5 id="randomkey"><strong>randomkey</strong></h5><p>随机返回一个键，这个很简单，请自行实验。</p><p><img src="HTTPs://zdwtop.cn/blog/41c50a66594e42f98755f4ca70814050.png" alt="image.png"></p><p><strong>rename</strong></p><p>键重命名</p><p>但是要注意，如果在rename之前,新键已经存在，那么它的值也将被覆盖。</p><p><img src="HTTPs://zdwtop.cn/blog/ec04e5381693497b9d85040317c25d74.png" alt="image.png"></p><p>为了防止被强行rename，Redis提供了renamenx命令，确保只有newKey不存在时候才被覆盖。</p><p><img src="HTTPs://zdwtop.cn/blog/41644a5ba52048e9a4b2d8b130d211a0.png" alt="image.png"></p><p>从上面我们可以看出，由于重命名键期间会执行del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能性。</p><h3 id="键名的生产实践">键名的生产实践</h3><p>Redis没有命令空间，而且也没有对键名有强制要求。但设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用**“业务名:对象名: id : [属性]”作为键名**   (也可以不是分号)。</p><p>例如MySQL 的数据库名为mall，用户表名为order，那么对应的键可以用&quot;mall:order:1&quot;,<br>&quot;mall:order:1:name&quot;来表示，如果当前Redis 只被一个业务使用，甚至可以去掉“order:”。</p><p><img src="HTTPs://zdwtop.cn/blog/46d96dd72a2943ceba09f109f563c243.png" alt="image.png"></p><p>在能描述键含义的前提下适当减少键的长度，从而减少由于键过长的内存浪费。</p><h3 id="安装">安装</h3><p>推荐docker安装，如果喜欢window操作可以下载GitHub的人开发的exe程序，不过版本一般比较老</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的技术全景&quot;&gt;Redis的技术全景&lt;/h2&gt;
&lt;p&gt;本质上就是，Redis 的知识都包括什么呢？简单来说，就是“两大维度，三大主线”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zdwtop.cn/blog/ba2269e45c1b4a77bf09</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>连接的原理</title>
    <link href="https://eizo01.github.io/posts/a1120601.html"/>
    <id>https://eizo01.github.io/posts/a1120601.html</id>
    <published>2022-10-30T12:00:00.000Z</published>
    <updated>2023-04-16T14:00:42.696Z</updated>
    
    <content type="html"><![CDATA[<h1>两个表的亲密接触-连接的原理</h1><p>我们先创建两个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (m1 <span class="type">int</span>, n1 <span class="type">char</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (m2 <span class="type">int</span>, n2 <span class="type">char</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure><p>连接 的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把 t1 和 t2 两个表连接起来的过程如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320161856926.png" alt="image-20230320161856926"></p><p>这个过程看起来就是把 t1 表的记录和 t2 的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查 询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果 集就可以称之为 笛卡尔积 。</p><h2 id="连接过程简介">连接过程简介</h2><p>我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的 笛卡尔 积 可能是非常巨大的。比方说3个100行记录的表连接起来产生的 笛卡尔积 就有 100×100×100=1000000 行数 据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p><ul><li><p>涉及单表的条件</p></li><li><p>这种只设计单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为 搜索条件 ，比如 t1.m1 &gt; 1 是只针对 t1 表的过滤条件， t2.n2 &lt; ‘d’ 是只针对 t2 表的过滤条件。</p></li><li><p>涉及两表的条件</p><ul><li>这种过滤条件我们之前没见过，比如 t1.m1 = t2.m2 、 t1.n1 &gt; t2.n2 等，这些条件中涉及到了两个表，比方说下边这个查询语句：</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">AND</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.m1 <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">t1.m1 <span class="operator">=</span> t2.m2</span><br><span class="line">t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>首先确定第一个需要查询的表，这个表称之为 驱动表 。</li></ol><p>此处假设使用 t1 作为驱动表，那么就需 要到 t1 表中找满足 t1.m1 &gt; 1 的记录，因为表中的数据太少，我们也没在表上建立二级索引。我们肯定得全表查询</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320162234271.png" alt="image-20230320162234271"></p><p>我们可以看到， t1 表中符合 t1.m1 &gt; 1 的记录有两条。</p><ol start="2"><li>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录，所谓 匹配的 记录 ，指的是符合过滤条件的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被 称之为 被驱动表 。<ul><li>当 t1.m1 = 2 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 2 ，所以此时 t2 表相当于有了 t2.m2 = 2 、 t2.n2 &lt; ‘d’ 这两个过滤条件，然后到 t2 表中执行单表查询。</li><li>当 t1.m1 = 3 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 3 ，所以此时 t2 表相当于有了 t2.m2 = 3 、 t2.n2 &lt; ‘d’ 这两个过滤条件，然后到 t2 表中执行单表查询。</li></ul></li></ol><p>所以整个连接查询的执行过程就如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320162516886.png" alt="image-20230320162516886"></p><p>所以最后得查询结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1n1m2n2</span><br><span class="line"><span class="number">2</span>b<span class="number">2</span>b</span><br><span class="line"><span class="number">3</span>c<span class="number">3</span>c</span><br></pre></td></tr></table></figure><p>可以从这个例子中看出，我们t1只被访问一次，t2可以能被访问多次。也就是说在<strong>两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</strong></p><h3 id="内连接和外连接">内连接和外连接</h3><p>创建两个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"> number <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line"> name <span class="type">VARCHAR</span>(<span class="number">5</span>) COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line"> major <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;学生信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> score (</span><br><span class="line"> number <span class="type">INT</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line"> subject <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;科目&#x27;</span>,</span><br><span class="line"> score TINYINT COMMENT <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (number, score)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;学生成绩表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>添加数据如下图：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320163711859.png" alt="image-20230320163711859"></p><p>现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student, score <span class="keyword">WHERE</span> student.number <span class="operator">=</span> score.number;</span><br></pre></td></tr></table></figure><p><img src="HTTPs://zdwtop.cn/blog/image-20230320163355527.png" alt="image-20230320163355527"></p><p>但发现一个问题，史珍香同学也就是学号为 20220103 的同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。在成绩统计时史珍香即使没有成绩也要出现在表中。我们介绍的 连接查询 是无法 完成这样的需求的。我们稍微思考一下这个需求，其本质是想：<strong>驱动表中的记录即使在被驱动表中没有匹配的记 录，也仍然需要加入到结果集。</strong></p><p>为了解决这个问题，就有了 内连接 和 外连接 的概念：</p><p>对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。</p><p>对于 外连接 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p><p>在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p><ul><li>左外连接 选取左侧的表为驱动表。</li><li>右外连接 选取右侧的表为驱动表。</li></ul><p>注意：</p><p>WHERE 子句中的过滤条件不论是内连接还是外连接，凡是不符合 WHERE 子句中的过滤条件的记录都不会被加入最后的结果集。</p><p>ON 子句中的过滤条件对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记 录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充。</p><p>这个 ON 子句是专门**为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记 录加入结果集这个场景下提出的，**所以如果把 ON 子句放到内连接中， MySQL 会把它和 WHERE 子句一样对 待，也就是说：<strong>内连接中的WHERE子句和ON子句是等价的。</strong></p><p><font color="red"><strong>一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中，我们也一般把放到 ON 子句中的过滤条件也称之为 连接条件 。</strong></font></p><p>连接语法这里就不多讲了。</p><h2 id="连接的原理">连接的原理</h2><h3 id="嵌套循环连接（Nested-Loop-Join）">嵌套循环连接（Nested-Loop Join）</h3><p>对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取 决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连 接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</p><p>通用的两表连接过程如下图所示：</p><img src="HTTPs://zdwtop.cn/blog/image-20230320165448593.png" alt="image-20230320165448593" style="zoom:150%;"><p>如果有3个表进行连接的话，那么 步骤2 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表， 重复上边过程，也就是 步骤2 中得到的结果集中的每一条记录都需要到 t3 表中找一找有没有匹配的记录，用伪 代码表示一下这个过程就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row in t1 &#123; #此处表示遍历满足对t1单表查询结果集中的每一条记录</span><br><span class="line"> <span class="keyword">for</span> each row in t2 &#123; #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span><br><span class="line"> <span class="keyword">for</span> each row in t3 &#123; #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span><br><span class="line"> <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个过程就像是一个嵌套的循环，所以这种<font color="red"><strong>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于 对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接</strong> </font>， 这是最简单一种连接查询算法。</p><h3 id="使用索引加快连接速度">使用索引加快连接速度</h3><p>上面我们可以知道查询 t2 表其实就相当于一次单表扫描，我们可以利用索引 来加快查询速度哦。回顾一下最开始介绍的 t1 表和 t2 表进行内连接的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">AND</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查询驱动表 t1 后的结果集中有两条记录， 嵌套循环连接 算法需要对被驱动表查询2次：</p><ul><li>当 t1.m1 = 2 时，去查询一遍 t2 表，对 t2 表的查询语句相当于：<ul><li>SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; ‘d’;</li></ul></li><li>当 t1.m1 = 3 时，再去查询一遍 t2 表，此时对 t2 表的查询语句相当于：<ul><li>SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; ‘d’;</li></ul></li></ul><p>可以看到，原来的 t1.m1 = t2.m2 这个涉及两个表的过滤条件在针对 t2 表做查询时关于 t1 表的条件就已经确 定了，所以我们只需要单单优化对 t2 表的查询了，上述两个对 t2 表的查询语句中利用到的列是 m2 和 n2 列， 我们可以：</p><ul><li>在 m2 列上建立索引，因为对 m2 列的条件是等值查找，所以可能使用到 ref 的访问方法，假设使用 ref 的访问方法去执行对 t2 表的查询的话，需要回表之后再判断 t2.n2 &lt; d 这 个条件是否成立。</li></ul><blockquote><p>假设 m2 列是 t2 表的主键或者唯一二级索引列，那么使用 t2.m2 = 常数 值 这样的条件从 t2 表中查找记录的过程的代价就是常数级别的。</p><p>把在连接查询中对被驱动表使用主键 值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref 。</p></blockquote><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）">基于块的嵌套循环连接（Block Nested-Loop Join）</h3><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。那么当表中数据一多的时候，内存不可能存的到那么多数据，所以就要淘汰前面的数据。我们前边又说过，采用 嵌 套循环连接 算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不 能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大了，所以我们得想办法： <strong>尽量减少访问被驱动表的次数。</strong></p><p>我们在把被驱动表的记录加载到内存的时候，可不可以一次性和多条驱动表中 的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。</p><p>所以MySQL 里面有个join buffer 的概念， **join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集 中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的 多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。**使 用 join buffer 的过程如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320170527848.png" alt="image-20230320170527848"></p><p>最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完 成连接操作了。</p><p>这种加入了 join buffer 的嵌套循环连接算法称之为 基于块的嵌套连接 （Block Nested-Loop Join）算法。</p><p>这个 join buffer 的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为 262144字 节 （也就是 256KB ），最小可以设置为 128字节 。</p><p>驱动表的记录并不是所有列都会被放到<code> join buffe</code>r 中，只有查询列表中的列和过滤条件中 的列才会被放到 join buffer 中，所以再次提醒我们，<strong>最好不要把 * 作为查询列表</strong>，只需要把我们关心的列放到 查询列表就好了，这样还可以在 join buffer 中放置更多的记录呢哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;两个表的亲密接触-连接的原理&lt;/h1&gt;
&lt;p&gt;我们先创建两个表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="innodb" scheme="https://eizo01.github.io/tags/innodb/"/>
    
    <category term="连接" scheme="https://eizo01.github.io/tags/%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="https://eizo01.github.io/posts/484a2385.html"/>
    <id>https://eizo01.github.io/posts/484a2385.html</id>
    <published>2022-10-20T12:00:00.000Z</published>
    <updated>2023-03-16T15:22:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>MySQL中的锁</strong></h1><p>InnoDB中锁非常多，总的来说，可以如下分类：</p><p><img src="https://zdwtop.cn/blog/image-20230316215836060.png" alt></p><p>这些锁都是做什么的？</p><p>我们已经知道事务并发执行时可能带来的各种问题，最大的一个难点是：一方面要最大程度地利用数据库的并发访问，另外一方面还要确保每个用户能以一致的方式读取和修改数据，尤其是一个事务进行读取操作，另一个同时进行改动操作的情况下。</p><h2 id="1-锁并发事务问题">**1.**锁并发事务问题</h2><p>一个事务进行读取操作，另一个进行改动操作,我们前边说过，这种情况下可能发生脏读、不可重复读、幻读的问题。</p><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p><h3 id="1-1-方案一：读操作MVCC，写操作进行加锁"><strong>1.1.方案一：读操作MVCC，写操作进行加锁</strong></h3><p><strong>事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，也称之为快照读</strong>，但是往往读取的是历史版本数据。所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别（RC,RR）下都算是一致性读。</p><p>一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。</p><p>很明显，采用MVCC方式的话，<strong>读-写操作彼此并不冲突，性能更高</strong>，<strong>采用加锁方式的话，读-写操作彼此需要排队执行，影响性能</strong>。一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些情况下，要求必须采用加锁的方式执行。</p><h3 id="1-2方案二：读、写操作都采用加锁的方式"><strong>1.2方案二：读、写操作都采用加锁的方式</strong></h3><p><strong>适用场景：</strong></p><p>业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，</p><p>比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><p><strong>脏读</strong>的产生是 因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><strong>幻读问题</strong>的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加锁的方式解决幻读问题就有不太容易了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点麻烦—— 因为并不知道给谁加锁。</p><h2 id="2-锁定读（LockingReads）-LBCC"><strong>2.锁定读（LockingReads）/LBCC</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">for</span>  <span class="keyword">update</span>   <span class="comment">-- 锁定读 属于x锁</span></span><br></pre></td></tr></table></figure><p>也称当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>   lock <span class="keyword">in</span> share mode <span class="comment">-- (共享锁) S锁</span></span><br></pre></td></tr></table></figure><p>哪些是当前读呢？</p><p><strong>select lock in share mode (共享锁)、select for update (排他锁)、读操作</strong></p><p><strong>update (排他锁)、insert (排他锁/独占锁)、delete (排他锁)、写操作</strong></p><p><strong>串行化事务隔离级别</strong>都是当前读。</p><h3 id="2-1-共享锁和独占锁"><strong>2.1. 共享锁和独占锁</strong></h3><p>在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，MySQL中的锁有好几类：</p><p><strong>共享锁</strong>英文名：Shared Locks，<strong>简称S锁</strong>。在事务要读取一条记录时，需要先获取该记录的S锁。</p><p>假如事务E1首先获取了一条记录的S锁之后，事务E2接着也要访问这条记录：</p><p>如果事务E2想要再获取一个记录的S锁，那么事务E2也会获得该锁，也就意味着事务E1和E2在该记录上同时持有S锁。</p><p><strong>独占锁，<strong>也常称</strong>排他锁</strong>，英文名：Exclusive Locks，<strong>简称X锁</strong>。</p><p>在 事务要改动一条记录时，E1需要先获取该记录的X锁。</p><p>如果事务E2想要再获取一个记录的X锁，那么此操作会被阻塞，直到事务E1提交之后将S锁释放掉。</p><p>如果事务E1首先获取了一条记录的X锁之后，那么不管事务E2接着想获取该记录的S锁还是X锁都会被阻塞，直到事务E1提交。</p><p>所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的，表示一下就是这样：</p><table><thead><tr><th><strong>X</strong></th><th><strong>不兼容S</strong></th><th><strong>不兼容X</strong></th></tr></thead><tbody><tr><td><strong>S</strong></td><td><strong>兼容S</strong></td><td><strong>不兼容X</strong></td></tr></tbody></table><h3 id="2-2-锁定读的SELECT语句"><strong>2.2.锁定读的SELECT语句</strong></h3><p>MySQ有两种比较特殊的SELECT语句格式：</p><h4 id="对读取的记录加S锁：">对读取的记录加S锁：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>一个事务中开启S锁</p><p><img src="https://zdwtop.cn/blog/image-20230316224750706.png" alt="image-20230316224750706"></p><p>也就是在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT … LOCK IN SHARE MODE语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。</p><p>如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的S锁释放掉。</p><h4 id="对读取的记录加X锁：">对读取的记录加X锁：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><img src="https://zdwtop.cn/blog/image-20230316225958920.png" alt="image-20230316225958920" style="zoom: 80%;"><p>如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p><h3 id="2-3-写操作的锁"><strong>2.3. 写操作的锁</strong></h3><p>平常所用到的写操作无非是DELETE、UPDATE、INSERT这三种：</p><h5 id="DELETE："><strong>DELETE：</strong></h5><p>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取一下这条记录的X排他锁定读，然后再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p><h5 id="INSERT："><strong>INSERT：</strong></h5><p>一般情况下，新插入一条记录的操作并不加锁，InnoDB通过一种称之为隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问。当然，在一些特殊情况下INSERT操作也是会获取锁的，具体情况我们后边再说。</p><h5 id="UPDATE："><strong>UPDATE：</strong></h5><p>在对一条记录做UPDATE操作时分为三种情况：</p><ol><li><p>如果未修改该记录的键值并且被更新的列占用的存储空间在<strong>修改前后未发生变化</strong>，则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在B+树 中位置的过程看成是一个<strong>获取X锁的锁定读</strong>。</p></li><li><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在<strong>修改前后发生变化</strong>，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个<strong>获取X锁的锁定读</strong>，新插入的记录由INSERT操作提供的<strong>隐式锁进行保护</strong>。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。</p></li></ol><h2 id="3-锁的粒度"><strong>3.锁的粒度</strong></h2><p>我们前边提到的锁都是针对记录的，也可以被称之为行级锁或者行锁，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）</p><h3 id="3-1-表锁与行锁的比较"><strong>3.1.表锁与行锁的比较</strong></h3><p><strong>锁定粒度：表锁 &gt; 行锁</strong></p><p><strong>加锁效率：表锁 &gt; 行锁</strong></p><p><strong>冲突概率：表锁 &gt; 行锁</strong></p><p><strong>并发性能：表锁 &lt; 行锁</strong></p><h3 id="3-2-给表加S锁"><strong>3.2.给表加S锁</strong></h3><p><strong>如果一个事务给表加了S锁，那么：</strong></p><p>别的事务可以继续获得该表的S锁</p><p>别的事务可以继续获得该表中的某些记录的S锁</p><p>别的事务<strong>不可以继续获得该表的X锁</strong></p><p>别的事务<strong>不可以继续获得该表中的某些记录的X锁</strong></p><h3 id="3-3-给表加X锁"><strong>3.3.给表加X锁</strong></h3><p><strong>如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</strong></p><p>别的事务<strong>不可以</strong>继续获得该表的S锁</p><p>别的事务<strong>不可以</strong>继续获得该表中的某些记录的S锁</p><p>别的事务<strong>不可以</strong>继续获得该表的X锁</p><p>别的事务<strong>不可以</strong>继续获得该表中的某些记录的X锁。</p><p>为了更好的理解这个表级别的S锁和X锁和后面的意向锁，我们举一个现实生活中的例子。我们用曾经很火爆的互联网风口项目共享Office来说明加锁：</p><p>共享Office有栋大楼，楼自然有很多层。办公室都是共享的，客户可以随便选办公室办公。每层楼可以容纳客户同时办公，每当一个客户进去办公，就相当于在每层的入口处挂了一把S锁，如果很多客户进去办公，相当于每层的入口处挂了很多把S锁（类似行级别的S锁）。</p><p>有的时候楼层会进行检修，比方说换地板，换天花板，检查水电啥的，这些维修项目并不能同时开展。如果楼层针对某个项目进行检修，就不允许客户来办公，也不允许其他维修项目进行，此时相当于楼层门口会挂一把X锁（类似行级别的X锁）。</p><p>上边提到的这两种锁都是针对楼层而言的，不过有时候我们会有一些特殊的需求：</p><p><img src="https://zdwtop.cn/blog/image-20230316230243710.png" alt="image-20230316230243710"></p><p>A、有投资人要来考察Office的环境。</p><p>投资人和公司并不想影响客户进去办公，但是此时不能有楼层进行检修，所以可以在大楼门口放置一把S锁（类似表级别的S锁）。此时：</p><p>来办公的客户们看到大楼门口有S锁，可以继续进入大楼办公。</p><p>修理工看到大楼门口有S锁，则先在大楼门口等着，啥时候投资人走了，把大楼的S锁撤掉再进入大楼维修。</p><p>B、公司要和房东谈条件。</p><p>此时不允许大楼中有正在办公的楼层，也不允许对楼层进行维修。所以可以在大楼门口放置一把X锁（类似表级别的X锁）。此时：</p><p>来办公的客户们看到大楼门口有X锁，则需要在大楼门口等着，啥时候条件谈好，把大楼的X锁撤掉再进入大楼办公。</p><p>修理工看到大楼门口有X锁，则先在大楼门口等着，啥时候谈判结束，把大楼的X锁撤掉再进入大楼维修。</p><h2 id="4-意向锁"><strong>4.意向锁</strong></h2><p>但是在上面的例子这里头有两个问题：</p><p>如果我们想对大楼整体上S锁，首先需要确保大楼中的没有正在维修的楼层，如果有正在维修的楼层，需要等到维修结束才可以对大楼整体上S锁。</p><p>如果我们想对大楼整体上X锁，首先需要确保大楼中的没有办公的楼层以及正在维修的楼层，如果有办公的楼层或者正在维修的楼层，需要等到全部办公的同学都办公离开，以及维修工维修完楼层离开后才可以对大楼整体上X锁。</p><p>我们在对大楼整体上锁（表锁）时，怎么知道大楼中有没有楼层已经被上锁（行锁）了呢？</p><p>依次检查每一楼层门口有没有上锁？那这效率也太慢了吧！</p><p>于是InnoDB提出了一种<strong>意向锁</strong>（英文名：Intention Locks）：</p><p><strong>意向共享锁</strong> ，英文名：Intention Shared Lock，<strong>简称IS锁</strong>。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。</p><p><strong>意向独占锁</strong> ，英文名：Intention Exclusive Lock，<strong>简称IX锁</strong>。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</p><p>视角回到大楼和楼层上来：</p><p>​    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAQAAAH7CAYAAABbm02EAAAAAXNSR0IArs4c6QAAIABJREFUeF7s3Qn8VmP+//FPRTLSaimjSFFomSZMRMoakzI1k0IjPylKZUuUSisJbdZkRIMwWSoU2UWUJZUKiTBla1OIqf6PzzX/657zPZ37vs99f+/lLK/zePQwvt+zXNfzOv1+rve5ljI7d+7cKRwIIIAAAggggAACCCCAAAIIIBArgTIEArFqbyqLAAIIIIAAAggggAACCCCAgBEgEOBFQAABBBBAAAEEEEAAAQQQQCCGAgQCMWx0qowAAggggAACCCCAAAIIIIAAgQDvAAIIIIAAAggggAACCCCAAAIxFCAQiGGjU2UEEEAAAQQQQAABBBBAAAEECAR4BxBAAAEEEEAAAQQQQAABBBCIoQCBQAwbnSojgAACCCCAAAIIIIAAAgggQCDAO4AAAggggAACCCCAAAIIIIBADAUIBGLY6FQZAQQQQAABBBBAAAEEEEAAAQIB3gEEEEAAAQQQQAABBBBAAAEEYihAIBDDRqfKCCCAAAIIIIAAAggggAACCBAI8A4ggAACCCCAAAIIIIAAAgggEEMBAoEYNjpVRgABBBBAAAEEEEAAAQQQQIBAgHcAAQQQQAABBBBAAAEEEEAAgRgKEAjEsNGpMgIIIIAAAggggAACCCCAAAIEArwDCCCAAAIIIIAAAggggAACCMRQgEAgho1OlRFAAAEEEEAAAQQQQAABBBAgEOAdQAABBBBAAAEEEEAAAQQQQCCGAgQCMWx0qowAAggggAACCCCAAAIIIIAAgQDvAAIIIIAAAggggAACCCCAAAIxFCAQiGGjU2UEEEAAAQQQQAABBBBAAAEECAR4BxBAAAEEEEAAAQQQQAABBBCIoQCBQAwbnSojgAACCCCAAAIIIIAAAgggQCDAO4AAAggggAACCCCAAAIIIIBADAUIBGLY6FQZAQQQQAABBBBAAAEEEEAAAQIB3gEEEEAAAQQQQAABBBBAAAEEYihAIBDDRqfKCCCAAAIIIIAAAggggAACCBAI8A4ggAACCCCAAAIIIIAAAgggEEMBAoEYNjpVRgABBBBAAAEEEEAAAQQQQIBAgHcAAQQQQAABBBBAAAEEEEAAgRgKEAjEsNGpMgIIIIAAAggggAACCCCAAAIEArwDCCCAAAIIIIAAAggggAACCMRQgEAgho1OlRFAAIEoCGzdulWefvpp2bx5s/z+97+XNm3ayO67756Xqu3cuVN+++03KV++fMb3d5azUqVK0r59e9lrr73S3kefN2fOHPn666+lfv360rp1a89rPvjgA1mwYIFkcu+0Dy/FCb/++qvcfvvtouX6wx/+IJdddllWbqUoApcigAACCCCAgE8BAgGfUJyGAAIIIBAsgY0bN0q/fv1k6dKl0rlzZ7nyyiulXLlyWRVy06ZNMmTIEKlXr5507NhRDjjgAHOfHTt2yOLFi2Xq1Kny008/yU033STVq1fP6BnOcjZs2FAmTJggVapUSXuPX375RUaMGGFCgW7dukmfPn3MNVrWiRMnymmnnSbHHHOMzJw5U4YPHy723hpajBs3Tho0aCBnn3121ia2gBpMaKihhwYZ6UIXZ7k1pBk8eLBUqFAhZX0zfUZaPE5AAAEEEEAAAV8CBAK+mDgJAQQQQCBoAs6OtrPDnE05582bJ4MGDZL//Oc/5gv+tddea75qb9++3XS+//nPf5rb9u/fX8455xwpU6aM78c4y/mnP/1JxowZI3vvvXfa670CAQ0oZsyYIbfccov87ne/M+XU82wgcPPNN8v06dPlwQcflIMOOkhuu+02Ofjgg9M+K9kJGoJoeWfPni1t27aVAQMGmOe+++670qNHj6zvay+cPHmyNGvWzIQtI0eOlLlz58pZZ51l6pUuRCj1w7kBAggggAACCAiBAC8BAggggEDgBfQL9YoVK0yH3R5btmyRO+64Q7744gs5/fTTTUfe6zjssMOkatWqSev43XffmY6ujgTQzq4Od2/SpEni/NWrV5uv82vXrpWaNWuaL/x169b1beYMBPx+MdebJxshoCHFvffeK/fff790795dqlWrJqNHjzYjBPTftQOvh44uaNq0qe9yuk/UaRI6JUPvo+HC2LFjE/XOdSCgz161apUZ8aHtoeGMBgOZBC9ZV5QLEUAAAQQQiLEAgUCMG5+qI4AAAmERcHbKMy2z/QrtdZ12ru+66y7TudZDpwtcffXVJea8a8dYpwxoUKCHhg/XX3+9CQ/8HN9++61cfvnlsnLlSrPOQboh9DolQKcmfPXVV+aPrpGg0xRq1KhhRifoegk//vijLFu2TBo1aiQLFy6UadOmmU5779695ZtvvpFt27bJEUccYUYi6PoD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O+ww8/OPP/5YPvnkE/PnjTfekE2bNpmfayjQuXPnSPkQCESqOakMAukFCATSG3EGAggggAAChRYgECi0OM+Lo0Dfvn0TowLatm0r3bp1kzp16qSkWL16tUydOlVmz55tztPRAhMnTowMH4FAZJqSiiDgT4BAwJ8TZyGAAAIIIFBIAQKBQmrzrDgK3H///XL77bfLwQcfLJdccomceuqpGTG88MILcvfdd8vnn38ul112mVx44YUZXR/UkwkEgtoylAuBPAkcffTRsmPHDmHKQJ6AuS0CCCCAAAJZCNhAYOHChVK2LFP6siDkEgSSCsyaNUtuuOEGKVeunEyZMkUaN26cldaHH34o3bt3l+3bt5v7nXXWWVndJ0gXEQgEqTUoCwIFECAQKAAyj0AAAQQQQCBDAQKBDME4HQGfAqtWrZJOnTqZs4cOHSrt2rXzeaX3aTNnzpRhw4aZXz722GNSt27dUt2v2BcTCBS7BXg+AgUWIBAoMDiPQwABBBBAwIcAgYAPJE5BIAuBO++8U+677z4544wzZOTIkVncYddLrr/+ennuuefkoosukl69euXknsW6CYFAseR5LgJFEiAQKBI8j0UAAQQQQCCFAIEArwcC+RFo3769fPXVVzJq1Chp06ZNTh4yZ84cGTRokBx44IHy9NNP5+SexboJgUCx5HkuAkUSIBAoEjyPRQABBBBAgECAdwCBggosWrRIevbsKZUqVZKXX345p89u3bq1bN68We655x456qijcnrvQt6MQKCQ2jwLgQAIEAgEoBEoAgIIIIAAAi4BRgjwSiCQewG7mOBJJ50kY8eOzekD+vfvLy+99FLoFxckEMjpa8HNEAi+AIFA8NuIEiKAAAIIxE+AQCB+bU6N8y8wefJk8wX/ggsukL59++b0gRMnTpQHHnjAjEDo0aNHTu9dyJsRCBRSm2chEAABAoEANAJFQAABBBBAwCVAIMArgUDuBXRrQB0lMHjwYDn77LNz+oCnnnpKRowYYbYe1OeE9SAQCGvLUW4EshQgEMgSjssQQAABBBDIowCBQB5xuXVsBfTL/bvvvpuXef52fYJmzZqJjkQI60EgENaWo9wIZClAIJAlHJchgAACCCCQRwECgTzicuvYCjBCIH3TEwikN+IMBCIlQCAQqeakMggggAACEREgEIhIQ1KNQAmwhkD65iAQSG/EGQhE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" alt="0"></p><p>如果有客户到楼层中办公，那么他先在整栋大楼门口放一把IS锁（表级锁），然后再到楼层门口放一把S锁（行锁）。</p><p>如果有维修工到楼层中维修，那么它先在整栋大楼门口放一把IX锁（表级锁），然后再到楼层门口放一把X锁（行锁）。</p><p>之后：</p><p>如果有投资人要参观大楼，也就是想在大楼门口前放S锁（表锁）时，首先要看一下大楼门口有没有IX锁，如果有，意味着有楼层在维修，需要等到维修结束把IX锁撤掉后才可以在整栋大楼上加S锁。</p><p>如果有谈条件要占用大楼，也就是想在大楼门口前放X锁（表锁）时，首先要看一下大楼门口有没有IS锁或IX锁，如果有，意味着有楼层在办公或者维修，需要等到客户们办完公以及维修结束把IS锁和IX锁撤掉后才可以在整栋大楼上加X锁。</p><p>注意： 客户在大楼门口加IS锁时，是不关心大楼门口是否有IX锁的，维修工在大楼门口加IX锁时，是不关心大楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间大楼里有没有被占用的楼层用的，也就是在对大楼加S锁或者X锁时才会用到。</p><p><strong>总结一下</strong>：<strong>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录</strong>。就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。我们画个表来看一下<strong>表级别</strong>的各种锁的兼容性：</p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td></td><td>不兼容</td><td></td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td></td><td></td></tr><tr><td>IS</td><td>不兼容</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>组合性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>表锁</td><td>有</td><td>有</td><td>有</td><td>有</td></tr><tr><td>行锁</td><td>有</td><td></td><td>有</td><td></td></tr></tbody></table><h1><strong>InnoDB存储引擎中的锁</strong></h1><h2 id="1-表级锁"><strong>1.表级锁</strong></h2><p><strong>1.表级别的S锁、X锁、元数据锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>另外，在对某个表执行一些诸如<code>ALTER TABLE、DROP TABLE</code>这类的<strong>DDL</strong>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞，同理，<strong>某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁</strong>（英文名：Metadata Locks，简称MDL）来实现的，一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。</p><p>其实这个InnoDB存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks = 1时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：</p><p>LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。</p><p>LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。</p><p><strong>请尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句，它们并不会提供什么额外 的保护，只是会降低并发能力而已。</strong></p><p><strong>2.表级别的IS锁、IX锁</strong></p><p>当我们在对使用InnoDB存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。</p><p>IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。我们并不能手动添加意向锁，只能由InnoDB存储引擎自行添加。</p><p><strong>1.3.表级别的AUTO-INC锁</strong></p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h2 id="2-InnoDB中的行级锁">2.InnoDB中的行级锁</h2><p>– <strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</strong></p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p>不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p><p>只有执行计划真正使用了索引，才能使用行锁：<strong>即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB</strong> <strong>将使用表锁，而不是行锁。</strong></p><p>同时当我们用范围条件而不是相等条件检索数据，并请求锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。</p><p>不过即使是行锁，InnoDB里也是分成了各种类型的。换句话说即使对同一条记录加行锁，如果类型不同，起到的功效也是不同的。我们使用前面的teacher，增加一个索引，并插入几条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX  `idx_number`(`number`)</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316231101579.png" alt="image-20230316231101579"></p><p>我们来看看都有哪些常用的行锁类型。</p><p><strong>Record Locks</strong>也叫记录锁，就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP。比方说我们把number值为6的那条记录加一个记录锁的示意图如下：</p><p><img src="https://zdwtop.cn/blog/image-20230316231114641.png" alt="image-20230316231114641"></p><p>记录锁是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁；</p><h3 id="Gap-Locks-间隙锁"><strong>Gap Locks 间隙锁</strong></h3><p>我们说MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。**但是在使用加锁方案解决时有问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。**InnoDB提出了一种称之为Gap Locks的锁，官方的类型名称为：LOCK_GAP，我们也可以简称为gap锁。</p><p><strong>间隙锁实质上是对索引前后的间隙上锁，不对索引本身上锁。</strong></p><p>会话1开启一个事务，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> domain <span class="operator">=</span><span class="string">&#x27;JVM&#x27;</span> <span class="keyword">where</span> number<span class="operator">=</span><span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316231159581.png" alt="image-20230316231159581"></p><p>如图中为2~6和  6  ~ 10的记录加了gap锁，意味着不允许别的事务在这条记录前后间隙插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">value</span>(<span class="number">7</span>,<span class="string">&#x27;曾&#x27;</span>,<span class="string">&#x27;docker&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为什么不能插入？因为记录（7,‘曾’,‘docker’）要 插入的话，在索引idx_number上，刚好落在6  ~ 10之间，是有锁的，当然不允许插入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;MySQL中的锁&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;InnoDB中锁非常多，总的来说，可以如下分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zdwtop.cn/blog/image-20230316215836060.png&quot; alt&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="锁" scheme="https://eizo01.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
