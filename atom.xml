<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDW🥝</title>
  
  <subtitle>一个入行Java程序员</subtitle>
  <link href="https://eizo01.github.io/atom.xml" rel="self"/>
  
  <link href="https://eizo01.github.io/"/>
  <updated>2023-03-25T10:15:54.505Z</updated>
  <id>https://eizo01.github.io/</id>
  
  <author>
    <name>曾德威🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-23T08:19:36.529Z</published>
    <updated>2023-03-25T10:15:54.505Z</updated>
    
    <content type="html"><![CDATA[<h1>OS：线程与进程</h1><h2 id="1-线程基础知识">1.<strong>线程基础知识</strong></h2><h3 id="1-1-线程和进程"><strong>1.1 线程和进程</strong></h3><p>进程</p><ul><li><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存、管理 IO 的 。</strong></p></li><li><p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p></li><li><p>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。</p></li><li><p>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p></li></ul><hr><p>title: 进程与线程<br>mathjax: true<br>tags:</p><ul><li>JMM</li><li>并发三大特性<br>categories:</li><li>JUE<br>date: 2022-08-02 18:30:03<br>updated:<br>abbrlink: ‘0’</li></ul><hr><p><strong>线程</strong></p><ul><li>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</li></ul><h4 id="线程和进程的区别：">线程和进程的区别：</h4><ol><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>资源占用 ： 每个进程都有独立的内存空间，而多个线程共享进程的内存和资源，线程之间切换开销小，通信更方便。进程之间通信需要显式地进行**IPC **即（Inter-process Communication）。</li><li>并发量：一个进程可以包含多个线程并发执行，线程是轻量级的，因此每个进程可以同时处理多个任务，提高了整个系统的并发性能。</li><li>生命周期：进程由操作系统管理，系统会为每个进程分配一定的系统资源，并且在进程终止时回收这些资源。而线程的生命周期与其所属的进程相同，当进程结束时，进程中的所有线程也会被自动终止。</li><li>安全性：由于线程共享进程的资源，因此线程之间需要采用同步机制来避免并发访问导致的数据竞争安全问题。</li></ol><h4 id="进程间通信的方式"><strong>进程间通信的方式</strong></h4><ol><li>管道（Pipe）：管道是一种半双工的通信方式，它创建一个进程间通信的通道，但只能在父子进程或兄弟进程间使用，不适用于无亲缘关系的进程间通信。</li><li>命名管道（Named Pipe）：命名管道也是一种半双工的通信方式，它允许不同进程间通过使用一个共享的命名管道进行通信，并且可以跨越父子进程或兄弟进程的限制。</li><li>信号量（Semaphore）：信号量是一种计数器，它用来控制进程对共享资源的访问。它能够跨越不同进程并保持同步，解决了多个进程之间竞争共享资源的问题。</li><li>消息队列（Message Queue）：消息队列允许一个进程向另一个进程发送消息，并且允许非相关进程交换信息。消息队列提供的是异步的通信机制，通信双方都不需要同时在线。</li><li>共享内存（Shared Memory）：共享内存是一种最快的IPC方式，允许多个进程共享同一块物理内存区域。它需要进行额外的同步控制以避免多个进程同时修改共享内存时的数据一致性问题。</li><li>套接字（Socket）：套接字是一种可用于网络通信的通信机制，可以在不同的进程间进行通信，并且允许跨越不同的计算机系统进行通信。</li></ol><h3 id="1-2-线程的同步互斥"><strong>1.2 线程的同步互斥</strong></h3><p><strong>线程同步</strong>是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p><strong>线程互斥</strong>是**指对于共享的进程系统资源，在各单个线程访问时的排它性。**当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p><strong>四种线程同步互斥的控制方法</strong></p><ul><li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。（在一段时间内只允许一个线程访问的资源就称为临界资源）。</li><li><strong>互斥量</strong>:为协调共同对一个共享资源的单独访问而设计的。</li><li><strong>信号量</strong>:为控制一个具有有限数量用户资源而设计。</li><li><strong>事件</strong>:用来通知线程有一些事件已发生，从而启动后继任务的开始</li></ul><h3 id="1-3-上下文切换（Context-switch）"><strong>1.3 上下文切换（Context switch）</strong></h3><p>上下文切换是指CPU(中央处理单元)从一个进程或线程到另一个进程或线程的切换。</p><blockquote><p>进程是程序的一个执行实例。在Linux中，线程是轻量级进程，可以并行运行，并与父进程(即创建线程的进程)共享一个地址空间和其他资源。</p><p>上下文是CPU寄存器和程序计数器在任何时间点的内容。</p><p>寄存器是CPU内部的一小部分非常快的内存(相对于CPU外部较慢的RAM主内存)，它通过提供对常用值的快速访问来加快计算机程序的执行。</p><p>程序计数器是一种专门的寄存器，它指示CPU在其指令序列中的位置，并保存着正在执行的指令的地址或下一条要执行的指令的地址.</p></blockquote><p>上下文切换可以更详细地描述为内核(即操作系统的核心)对CPU上的进程(包括线程)执行以下活动:</p><ol><li>暂停一个进程的处理，并将该进程的CPU状态(即上下文)存储在内存中的某个地方</li><li>从内存中获取下一个进程的上下文，并在CPU的寄存器中恢复它</li><li>返回到程序计数器指示的位置(即返回到进程被中断的代码行)以恢复进程。</li></ol><p>在操作系统中，以下情况会导致进程上下文切换：</p><ol><li>进程调度：当当前运行的进程时间片耗尽或者发生某些事件时，操作系统需要根据某种调度策略将CPU分配给其他进程，此时需要进行进程上下文切换。</li><li>中断处理：当外部设备请求进程服务时，如IO操作完成、定时器到期、硬件出现故障等，会产生中断信号触发硬件中断，此时操作系统需要暂时挂起当前进程以响应中断请求，并保存当前进程上下文信息，在中断服务例程执行完毕后再恢复当前进程的执行。</li><li>系统调用：当进程需要访问操作系统提供的资源或服务时，需要通过系统调用的方式转入内核态，此时操作系统需切换进程上下文才能处理请求并返回结果给进程。</li></ol><h3 id="1-4-操作系统层面线程生命周期">1.4 操作系统层面线程生命周期</h3><p>操作系统层面的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323161126771.png" alt="image-20230323161126771"></p><ol><li><strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li><li><strong>可运行状态</strong>，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li><li>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>。</li><li><strong>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量</strong>），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，<strong>休眠状态</strong>的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li><li>线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li></ol><blockquote><p>如果线程不规范终止，就会变成“僵尸线程”（Zombie Thread）。</p><p>僵尸线程（Zombie Thread）是指一个已经完成执行，但其父线程还未调用<code>wait()</code>或<code>join()</code>等待其结束，并回收其资源的子线程。这种情况下，虽然该线程已经结束运行，但其占用的系统资源（如进程ID、堆栈等）仍未被释放，可能导致系统资源浪费和其他问题。应该及时使用<code>wait()</code>或<code>join()</code>等待子线程结束并完成资源回收。。</p><p>Java不会出现僵尸线程，但会出现孤儿线程。当一个子线程还在执行，但它的父线程已经终止或者被杀死时，这个子线程就成为孤儿线程。孤儿线程不会影响主进程或其它进程，但是它们仍然占用系统资源，可能会导致系统瓶颈和性能下降。可以使用Java中的Thread.join()方法来等待子线程结束后再退出父线程，从而避免产生孤儿线程。</p></blockquote><h3 id="查看进程线程的方法"><strong>查看进程线程的方法</strong></h3><p><strong>linux</strong></p><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p  查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p  查看某个进程（PID）的所有线程</li></ul><p><strong>Java</strong></p><ul><li>jps 命令查看所有 Java 进程</li><li>jstack  查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;OS：线程与进程&lt;/h1&gt;
&lt;h2 id=&quot;1-线程基础知识&quot;&gt;1.&lt;strong&gt;线程基础知识&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;1-1-线程和进程&quot;&gt;&lt;strong&gt;1.1 线程和进程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-01-13T12:00:00.000Z</published>
    <updated>2023-03-18T14:10:02.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ 都提供了事务相关功能） 、Saga 等等。</p><p>2PC、3PC 属于业务代码无侵入方案，都是基于 XA 规范衍生出来的实现，XA 规范是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。TCC、Saga 属于业务侵入方案，MQ 事务依赖于使用消息队列的场景，本地消息表不支持回滚。</p><p>开始介绍 2PC 和 3PC 之前，我们先来介绍一下 2PC 和 3PC 涉及到的一些角色（XA 规范的角色组成）：<br><img src="HTTP://zdwtop.cn/blog/image-20230314214742411.png" alt="分布式"><br>  ● AP（Application Program）：应用程序本身。<br>  ● RM（Resource Manager） ：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库（后文会以关系型数据库为例），一个分布式事务往往涉及到多个 RM。<strong>DB</strong><br>● TM（Transaction Manager） ：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</p><h2 id="2PC（两阶段提交协议）"><a href="#2PC（两阶段提交协议）" class="headerlink" title="2PC（两阶段提交协议）"></a>2PC（两阶段提交协议）</h2><p><img src="HTTPs://zdwtop.cn/blog/1666839398805-8d026011-316f-497a-9c11-e5a2e4a4b669.png" alt="2pc"></p><p>2PC（Two-Phase Commit）这三个字母的含义:</p><p>● 2 -&gt; 指代事务提交的 2 个阶段<br>● P-&gt; Prepare (准备阶段)<br>● C -&gt;Commit（提交阶段）</p><p>2PC 将事务的提交过程分为 2 个阶段：<strong>准备阶段</strong> 和 <strong>提交阶段</strong> 。</p><h4 id="准备阶段-Prepare"><a href="#准备阶段-Prepare" class="headerlink" title="准备阶段(Prepare)"></a><strong>准备阶段(Prepare)</strong></h4><p>准备阶段的核心是“询问”事务参与者执行本地数据库事务操作是否成功。</p><p>准备阶段的工作流程：</p><p>1、 <strong>事务协调者/管理者（后文简称 TM）</strong>： 向所有涉及到的 <strong>事务参与者（后文简称 RM）</strong> 发送消息询问：“你是否可以执行事务操作呢？”，并等待其答复。<br>2 、<strong>RM</strong> 接收到消息之后，开始执行本地数据库事务预操作比如写 redo log/undo log 日志，<strong>此时并不会提交事务 。</strong><br>3 、RM 如果执行本地数据库事务操作成功，那就回复“Yesdb”表示我已就绪，否则就回复“No”表示我未就绪。</p><h4 id="提交阶段-Commit"><a href="#提交阶段-Commit" class="headerlink" title="提交阶段(Commit)"></a><strong>提交阶段(Commit)</strong></h4><p>提交阶段的核心是“询问”事务参与者提交本地事务是否成功。</p><p>当所有事务参与者都是“就绪”状态的话：</p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以提交事务啦！”（Commit 消息）<br>2、<strong>RM</strong> 接收到 <strong>Commit 消息</strong> 后执行 <strong>提交本地数据库事务</strong> 操作，执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经提交” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>事务参与者</strong> 的 ACK 消息 之后，整个分布式事务过程正式结束。</p><p><strong>当任一事务参与者是“未就绪”状态的话：</strong></p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以执行回滚操作了！”<strong>（Rollback 消息）。</strong><br>2、<strong>RM</strong> 接收到 Rollback 消息 后执行 <strong>本地数据库事务回滚</strong> 执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经回滚” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>RM 的 ACK 消息</strong> 之后，中断事务。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下 2PC 两阶段中比较重要的一些点：</p><p>1、<strong>准备阶段</strong> 的主要目的是<strong>测试 RM</strong> 能否执行 <strong>本地数据库事务</strong> 操作（!!!注意：<strong>这一步并不会提交事务</strong>）。<br>2、<strong>提交阶段</strong> 中 <strong>TM</strong> 会根据 <strong>准备阶段 中 RM 的消息</strong>来决定是执行<strong>事务提交</strong>还是<strong>回滚操作</strong>。<br>3、提交阶段 之后一定会结束当前的分布式事务</p><h5 id="2PC-的优点："><a href="#2PC-的优点：" class="headerlink" title="2PC 的优点："></a><strong>2PC 的优点：</strong></h5><p>● 实现起来非常简单，各大主流数据库比如 MySQL、Oracle 都有自己实现。<br>● 针对的是数据强一致性。不过，仍然可能存在数据不一致的情况。</p><h5 id="2PC-存在的问题："><a href="#2PC-存在的问题：" class="headerlink" title="2PC 存在的问题："></a><strong>2PC 存在的问题：</strong></h5><p>● <strong>同步阻塞</strong> ：事务参与者会在正式提交事务之前会一直占用相关的资源。比如用户小明转账给小红，那其他事务也要操作用户小明或小红的话，就会阻塞。<br>● <strong>数据不一致</strong> ：由于网络问题或者TM宕机都有可能会造成数据不一致的情况。比如在第2阶段（提交阶段），部分网络出现问题导致部分参与者收不到 Commit/Rollback 消息的话，就会导致数据不一致。<br>● <strong>单点问题</strong> ： TM在其中也是一个很重要的角色，如果TM在准备(Prepare)阶段完成之后挂掉的话，事务参与者就会一直卡在提交(Commit)阶段。</p><h2 id="3PC（三阶段提交协议）"><a href="#3PC（三阶段提交协议）" class="headerlink" title="3PC（三阶段提交协议）"></a>3PC（三阶段提交协议）</h2><p>3PC 是人们在 2PC 的基础上做了一些优化得到的。3PC 把 2PC 中的 准备阶段(Prepare) 做了进一步细化，分为 2 个阶段：</p><p>● 准备阶段(CanCommit)<br>● 预提交阶段(PreCommit)</p><h4 id="准备阶段-CanCommit"><a href="#准备阶段-CanCommit" class="headerlink" title="准备阶段(CanCommit)"></a>准备阶段(CanCommit)</h4><p>这一步不会执行事务操作，只是向 <strong>RM 发送 准备请求</strong> ，顺便询问一些信息比如事务参与者能否执行本地数据库事务操作。RM 回复“Yes”、“No”或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有参与者发送“Abort”消息），否则进入 <strong>预提交阶段(PreCommit) 。</strong></p><h4 id="预提交阶段-PreCommit"><a href="#预提交阶段-PreCommit" class="headerlink" title="预提交阶段(PreCommit)"></a>预提交阶段(PreCommit)</h4><p><strong>TM</strong> 向所有涉及到的 RM 发送 <strong>预提交请求</strong> ，RM 回复“Yes”、“No”（最后的反悔机会）或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有事务参与者发送“abort”消息），否则进入 <strong>执行事务提交阶段</strong>（DoCommit） 。</p><p>当所有 RM 都返回“Yes”之后， RM 才会执行本地数据库事务预操作比如写 <strong>redo log/undo log</strong> 日志。</p><h4 id="执行事务提交阶段（DoCommit）"><a href="#执行事务提交阶段（DoCommit）" class="headerlink" title="执行事务提交阶段（DoCommit）"></a>执行事务提交阶段（DoCommit）</h4><p>执行事务提交（DoCommit） 阶段就开始进行真正的事务提交。</p><p>TM 向所有涉及到的 RM 发送 <strong>执行事务提交请求</strong> ，<strong>RM 收到消息后开始正式提交事务</strong>，并在完成事务提交后释放占用的资源。</p><p>如果 TM 收到所有 RM 正确提交事务的消息的话，表示事务正常完成。如果任一 RM 没有正确提交事务或者超时的话，就中断事务，TM 向所有 RM 发送“Abort”消息。RM 接收到 Abort 请求后，执行本地数据库事务回滚，后面的步骤就和 2PC 中的类似了。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>3PC 除了将2PC 中的准备阶段(Prepare) 做了进一步细化之外，还做了哪些改进？</strong></p><p>3PC 还同时在事务管理者和事务参与者中引入了 <strong>超时机制</strong> ，如果在一定时间内没有收到事务参与者的消息就默认失败，进而避免事务参与者一直阻塞占用资源。2PC 中只有事务管理者才拥有超时机制，当事务参与者长时间无法与事务协调者通讯的情况下（比如协调者挂掉了），就会导致无法释放资源阻塞的问题。</p><p>不过，3PC 并没有完美解决 2PC 的阻塞问题，引入了一些新问题比如性能糟糕，而且，依然存在数据不一致性问题。因此，3PC 的实际应用并不是很广泛，<strong>多数应用会选择通过复制状态机解决 2PC 的阻塞问题。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;p&gt;分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ </summary>
      
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论</title>
    <link href="https://eizo01.github.io/posts/41166861.html"/>
    <id>https://eizo01.github.io/posts/41166861.html</id>
    <published>2023-01-09T12:00:00.000Z</published>
    <updated>2023-03-11T14:00:04.564Z</updated>
    
    <content type="html"><![CDATA[<h1>1、CAP 理论</h1><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" alt="cap"><br>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性</strong>（Consistency） : 所有节点访问同一份最新的数据副本</li><li><strong>可用性</strong>（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性</strong>（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>插入一个小知识：网络分区<br>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p><blockquote><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。<br>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性C。<br>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</p></blockquote><p>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。<br>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。<br>这些特性将会在注册中心体现：常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos…。</p><ol><li><strong>ZooKeeper 保证的是 CP</strong>。任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li><li><strong>Eureka 保证的则是 AP</strong>。 Eureka 在设计的时候就是<strong>优先保证 A （可用性）</strong>。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。所以它不能保证数据到来就能同步所有节点，是弱一致性。</li><li><strong>Nacos 不仅支持 CP 也支持 AP</strong>。还可以作为配置中心，这是nacos提供的新特性。</li></ol><h1>2、BASE 理论</h1><p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h2 id="BASE-理论的核心思想">BASE 理论的核心思想</h2><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。<br>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。<br>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p><h2 id="基本可用">基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。<br><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h2 id="软状态">软状态</h2><p>软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h2 id="最终一致性">最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。<br><strong>分布式一致性的 3 种级别</strong>：<br><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。<br><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。<br><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。<br>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。<br>那实现最终一致性的具体方式是什么呢? 《分布式协议与算法实战》open in new window 中是这样介绍：<br><strong>读时修复</strong> :  在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。<br><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。<br><strong>异步修复 :</strong> 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</p>]]></content>
    
    
    <summary type="html">🥧详细介绍分布式领域中的理论，为分布式系统打下基础</summary>
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式理论" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="https://eizo01.github.io/posts/54cf796.html"/>
    <id>https://eizo01.github.io/posts/54cf796.html</id>
    <published>2022-11-07T12:00:00.000Z</published>
    <updated>2023-03-18T14:02:16.597Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis底层数据结构</h1><p><strong>Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构</strong>。</p><p>现在附上3.0和6.0的数据结构图</p><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>在最新的 Redis 代码6.0，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318165759154.png" alt="image-20230318165759154"></p><p><img src="https://zdwtop.cn/blog/a9c3e7dc4ac79363d8eb8eb2290a58e6.png" alt="img"></p><p>图有xiaolincoding的贡献。感谢。</p><h2 id="redis的key-value结构">redis的key-value结构</h2><p>我们还是得复习一下整个redis的key-value结构</p><p><img src="https://zdwtop.cn/blog/3c386666e4e7638a07b230ba14b400fe.png" alt="img"></p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 *<em>void * key 和 void * value 指针， <em>key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</em></em>。</li></ul><p>void * key 和 void * value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><p><img src="https://zdwtop.cn/blog/58d3987af2af868dca965193fb27c464.png" alt="img"></p><p>对象结构里包含的成员变量：</p><ul><li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li><li>encoding，标识该对象使用了哪种底层的数据结构；</li><li><strong>ptr，指向底层数据结构的指针</strong>。</li></ul><h2 id="SDS">SDS</h2><p>简单动态字符串（SDS）是Redis的字符串实现之一，它是一个动态字符串，可以自动扩展和收缩，支持O(1)时间复杂度的字符串长度获取.</p><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p><h3 id="C-语言字符串的缺陷">C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p><p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p><img src="https://zdwtop.cn/blog/bcf6bde3b647bdc343efcbc1a8f10579.png" alt="img" style="zoom:80%;"><p>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方*</strong>）</p><p>还有<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（这也是一个可以改进的地方）</strong></p><p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所有字符串操作的函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方*</strong>）。</p><p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul><p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p><h3 id="SDS-结构设计">SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><img src="https://zdwtop.cn/blog/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom:50%;"><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p><h4 id="O（1）复杂度获取字符串长度">O（1）复杂度获取字符串长度</h4><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p><p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p><h4 id="二进制安全">二进制安全</h4><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p><h4 id="不会发生缓冲区溢出">不会发生缓冲区溢出</h4><p>C 语言的字符串标准库提供的字符串操作函数，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p><p>Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p><p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p><p>SDS 扩容的规则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hisds <span class="title function_">hi_sdsMakeRoomFor</span><span class="params">(hisds s, <span class="type">size_t</span> addlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// s目前的剩余空间已足够，无需扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//获取目前s的长度</span></span><br><span class="line">    len = hi_sdslen(s);</span><br><span class="line">    sh = (<span class="type">char</span> *)s - hi_sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">//扩展之后 s 至少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    <span class="comment">//根据新长度，为s分配新空间所需要的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; HI_SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">//新长度&lt;HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则，分配长度为目前长度+1MB</span></span><br><span class="line">        newlen += HI_SDS_MAX_PREALLOC;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li><li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li></ul><h4 id="节省内存空间">节省内存空间</h4><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p><p>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p><p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><p><img src="https://zdwtop.cn/blog/image-20230318171838299.png" alt="image-20230318171838299"></p><p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li><li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li></ul><p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p>「字节对齐」的方式分配内存</p><h2 id="链表">链表</h2><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。</p><p>链表是Redis的列表实现之一，它是一个双向链表，每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针.</p><h3 id="链表结构设计">链表结构设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    struct listNode *next;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 在 listNode 结构体基础上又封装了 list 这个数据结构</span></span><br><span class="line">    typedef struct list &#123;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    unsigned <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/cadf797496816eb343a19c2451437f1e.png" alt="img"></p><h3 id="链表的优势与缺陷">链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>；</li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li></ul><p>链表的缺陷也是有的：</p><ul><li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li><li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li></ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p><h2 id="压缩列表ZipList">压缩列表<strong>ZipList</strong></h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>压缩列表是Redis的列表和哈希表实现之一，它是一个紧凑的数据结构，可以在内存中存储多个元素，每个元素可以是一个字符串或一个整数.</p><p>但是，压缩列表的缺陷也是有的：</p><ul><li>不能保存过多的元素，否则查询效率就会降低；</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li></ul><p>Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><h3 id="压缩列表结构设计">压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="https://zdwtop.cn/blog/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img"></p><p>压缩列表在表头有三个字段：</p><ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>压缩列表节点（<strong>entry</strong>）的构成如下：</p><ul><li><em><strong>prevlen</strong></em>，<strong>记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</strong></li><li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；占用1个、2个或5个字节</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318182627294.png" alt="image-20230318182627294"></p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关.</p><ul><li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li><li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节/2字节/5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。</p><h3 id="连锁更新">连锁更新</h3><p>压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p><ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p><h3 id="压缩列表的缺陷">压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题.</p><h2 id="哈希表-dict">哈希表 <strong>dict</strong></h2><p>字典是Redis的哈希表实现之一，它是一个键值对的无序集合，其中每个键都映射到一个值.</p><p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。<strong>Redis 采用了「链式哈希」来解决哈希冲突</strong></p><h3 id="哈希表结构设计">哈希表结构设计</h3><p><img src="https://zdwtop.cn/blog/image-20230318183756294.png" alt="image-20230318183756294"></p><p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p><p><img src="https://zdwtop.cn/blog/dc495ffeaa3c3d8cb2e12129b3423118.png" alt="img"></p><p>跳跃表是Redis的有序集合实现之一，它是一个有序的数据结构，其中每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针。跳跃表是一种高效的有序数据结构，可以在O(log N)时间内执行插入、删除和查找操作.</p><h3 id="rehash">rehash</h3><p>哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//两个Hash表，交替使用，用于rehash操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    …</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p><p><img src="https://zdwtop.cn/blog/2fedbc9cd4cb7236c302d695686dd478.png" alt="img"></p><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><p><img src="https://zdwtop.cn/blog/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img"></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><h3 id="渐进式-rehash">渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p><blockquote><p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p></blockquote><h3 id="rehash-触发条件">rehash 触发条件</h3><p>rehash 的触发条件跟**负载因子（load factor）**有关系。</p><p>负载因子可以通过下面这个公式计算：</p><p><img src="https://zdwtop.cn/blog/image-20230318184250548.png" alt="image-20230318184250548"></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul><h2 id="整数集合Inset">整数集合<strong>Inset</strong></h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p><p><img src="https://zdwtop.cn/blog/image-20230318184640470.png" alt="image-20230318184640470"></p><h3 id="升级扩容">升级扩容</h3><p><img src="https://zdwtop.cn/blog/image-20230318184733792.png" alt="image-20230318184733792"></p><h2 id="跳表skip-list">跳表<strong>skip list</strong></h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><p>struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</p><p>跳表结构里包含了：</p><ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li></ul><h3 id="跳表结构设计">跳表结构设计</h3><p><strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p><img src="https://zdwtop.cn/blog/image-20230318185333886.png" alt="image-20230318185333886"></p><p><img src="https://zdwtop.cn/blog/redis_skiplist_example.png" alt="Redis 核心数据结构（二） - &quot;地瓜哥&quot;博客网"></p><p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p><p><strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>其中，ZSKIPLIST_MAXLEVEL 定义的是最高的层数，Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32。</p><p>跳表的查找复杂度就是 O(logN)。</p><h3 id="为什么用跳表而不用平衡树？">为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL树、红黑树等）？</p><p>简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。平衡树每个节点包含 2 个指针,跳表平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。</li></ul><p>对象是Redis的所有数据类型的底层实现，它是一个通用的数据结构，可以表示字符串、列表、哈希表、有序集合等多种数据类型.</p><h2 id="quicklist">quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList</p><p>头尾指针-双端链表 节点是ziplist</p><p><img src="https://zdwtop.cn/blog/image-20230318190615928.png" alt="image-20230318190615928"></p><p><img src="https://zdwtop.cn/blog/image-20230318190619375.png" alt="image-20230318190619375"></p><p><img src="https://zdwtop.cn/blog/f46cbe347f65ded522f1cc3fd8dba549.png" alt="img"></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h2 id="listpack">listpack</h2><p>Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p><strong>在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p><h3 id="listpack-结构设计">listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构</p><p><img src="https://zdwtop.cn/blog/4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img"></p><p>stpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis底层数据结构&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Key和Value的数据结构组织</title>
    <link href="https://eizo01.github.io/posts/1cc613d0.html"/>
    <id>https://eizo01.github.io/posts/1cc613d0.html</id>
    <published>2022-11-05T12:00:00.000Z</published>
    <updated>2023-03-18T14:04:30.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的Key和Value的数据结构组织"><a href="#Redis的Key和Value的数据结构组织" class="headerlink" title="Redis的Key和Value的数据结构组织"></a>Redis的Key和Value的数据结构组织</h2><h3 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p><img src="HTTPs://zdwtop.cn/blog/1eb5ca015a3b4389ad4ede842d98df1f.png" alt="image.png"></p><p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。</p><p>哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对：我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p><p>但当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在<br>的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p><p><img src="HTTPs://zdwtop.cn/blog/f2a1f73d63f1428cad1324a7b67283b4.png" alt="image.png"></p><p>Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</p><p>当然如果这个数组一直不变，那么hash冲突会变很多，这个时候检索效率会大打折扣，所以Redis就需要把数组进行扩容（一般是扩大到原来的两倍），但是问题来了，扩容后每个hash桶的数据会分散到不同的位置，这里设计到元素的移动，必定会阻塞IO，所以这个ReHash过程会导致很多请求阻塞。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免这个问题，Redis 采用了渐进式 rehash。</p><p>首先、Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash。</p><p>1、给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍</p><p>2、把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中</p><p>3、释放哈希表 1 的空间</p><p>在上面的第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。</p><p><img src="HTTPs://zdwtop.cn/blog/2406a8206e944d449b03f1f390bedf0d.png" alt="image.png"></p><p>在Redis 开始执行 rehash，Redis仍然正常处理客户端请求，但是要加入一个额外的处理：</p><p>处理第1个请求时，把哈希表 1中的第1个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>处理第2个请求时，把哈希表 1中的第2个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>如此循环，直到把所有的索引位置的数据都拷贝到哈希表 2 中。</p><p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><p>所以这里基本上也可以确保根据key找value的操作在O（1）左右。</p><p>不过这里要注意，如果Redis中有海量的key值的话，这个Rehash过程会很长很长，虽然采用渐进式Rehash，但在Rehash的过程中还是会导致请求有不小的卡顿。并且像一些统计命令也会非常卡顿：比如keys</p><p>按照Redis的配置每个实例能存储的最大<em>的key的数量</em>为2的32次方,即2.5亿，但是尽量把key的数量控制在千万以下，这样就可以避免Rehash导致的卡顿问题，如果数量确实比较多，建议采用分区hash存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;a href=&quot;#Redis的Key和Value的数据结构组织&quot; class=&quot;headerlink&quot; title=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;/a&gt;Redis的Key和Value的数据结构</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的Buffer Pool</title>
    <link href="https://eizo01.github.io/posts/1eb869e1.html"/>
    <id>https://eizo01.github.io/posts/1eb869e1.html</id>
    <published>2022-11-05T12:00:00.000Z</published>
    <updated>2023-03-25T10:11:16.213Z</updated>
    
    <content type="html"><![CDATA[<h1>调节磁盘和CPU的矛盾-InnoDB的Buffer Pool</h1><h2 id="为什么要有-Buffer-Pool？">为什么要有 Buffer Pool？</h2><p>对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚 簇索引和二级索引），还是各种系统数据，都是以 页 的形式存放在 表空间 中的，而所谓的 表空间 只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。</p><p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>所以 InnoDB 存储引擎在处 理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说<font color="red"><strong>即使我们 只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</strong></font></p><p>将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 缓存 起来，这样将来有 请求再次访问该页面时，就可以省去磁盘 IO 的开销了。</p><h2 id="Buffer-Pool的大小？">Buffer Pool的大小？</h2><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> ，最小值为 5M (当小于该值时会自动设置成 5M )。</p><p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p><h2 id="Buffer-Pool内部组成">Buffer Pool内部组成</h2><p>为了更好的管理这些在 Buffer Pool 中的缓存页，设计 InnoDB 的大叔为每一个缓存页都创建了一些所谓的 控制信息 ，这些控制信息 包括该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息。</p><blockquote><p>在MySQL的缓冲池中，LSN是一个用于跟踪日志序列号（Log Sequence Number）的值。在InnoDB引擎中，每个页面都有一个LSN值，它指示了最近一次修改页面时对应的日志序列号。</p><p>在进行事务提交和回滚时，数据库使用LSN来保证数据的一致性和完整性。此外，LSN还在崩溃恢复过程中扮演重要的角色，它用于确定哪些日志需要被应用到数据库中以进行数据恢复。</p></blockquote><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102320659.png" alt="image-20230323102320659"></p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102429464.png" alt="image-20230323102429464"></p><p>每一个控制块都对应一个缓存页，那在分配 足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的那点儿内存空间就被称为 碎片 了。</p><h2 id="如何管理-Buffer-Pool？">如何管理 Buffer Pool？</h2><h3 id="如何管理空闲页？-Free-链表">如何管理空闲页？-Free 链表</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p><p>那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。</p><p>所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p><p>刚刚完成初始化的 Buffer Pool 中 所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到 free链表 中，假设该 Buffer Pool 中 可容纳的缓存页数量为 n ，那增加了 free链表 的效果图就是这样的</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323102820147.png" alt="image-20230323102820147"></p><blockquote><p>链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里，每个基节点只占用40字节大小。MySQL中许多不同的链表，它们的基节点和free链表的基节点的内存分配方式是一样一样的，都是 单独申请的一块40字节大小的内存空间，并不包含在为Buffer Pool申请的一大片连续内存空间之内。</p></blockquote><p>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 free链表 中 取一个空闲的缓存页，并且把该缓存页对应的 控制块 的信息填上（就是该页所在的表空间、页号之类的信 息），然后把该缓存页对应的 free链表 节点从链表中移除，表示该缓存页已经被使用了</p><h3 id="缓存页的哈希处理">缓存页的哈希处理</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到 Buffer Pool 中，如果该页已经 在 Buffer Pool 中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在 Buffer Pool 中呢？难 不成需要依次遍历 Buffer Pool 中各个缓存页么？一个 Buffer Pool 中的缓存页这么多都遍历完岂不是要累死？</p><p>我们其实是根据 表空间号 + 页号 来定位一个页的，也就相当于 表空间号 + 页号 是一个 key ， 缓存页 就是对应的 value ，怎么通过一个 key 来快速找着一个 value 呢？如果学过数据结构，我们会非常熟悉会用哈希表来处理。</p><p><strong>所以我们可以用 表空间号 + 页号 作为 key ， 缓存页 作为 value 创建一个哈希表，在需要访问某个页的数据 时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没 有，那就从 free链表 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</strong></p><h3 id="如何管理脏页？-flush链表">如何管理脏页？-flush链表</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p><p>凡是修改过的缓存页对 应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的， 所以也叫 flush链表 。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323103506265.png" alt="image-20230323103506265"></p><p>有了flush链表，每次修改缓存页后，我们并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步。</p><h3 id="如何提高缓存命中率？-LRU链表的管理">如何提高缓存命中率？-LRU链表的管理</h3><p>设立 Buffer Pool 的初衷，就是想减少和磁盘的 IO 交互，最好每次在访问某个页的时候它都已经被缓存到 Buffer Pool 中了。假设我们一共访问了 n 次页，那么被访问的页已经 在缓存中的次数除以 n 就是所谓的 <strong>缓存命中率</strong> ，我们的期望就是让 缓存命中率 越高越好～</p><p>从这个角度出发， 回想一下我们的微信聊天列表，排在前边的都是最近很频繁使用的，排在后边的自然就是最近很少使用的，假如 列表能容纳下的联系人有限，你是会把最近很频繁使用的留下还是最近很少使用的留下呢？废话，当然是留下最 近很频繁使用的了</p><p><strong>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</strong></p><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p><h4 id="简单LRU">简单LRU</h4><p>简单的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul><p>比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。</p><p>如果该页不在 Buffer Pool 中，在把该页从磁盘加载到 Buffer Pool 中的缓存页时，就把该缓存页对应的 控制块 作为节点塞到链表的头部。</p><p>如果该页已经缓存在 Buffer Pool 中，则直接把该页对应的 控制块 移动到 LRU链表 的头部。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230323110557851.png" alt="image-20230323110557851"></p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul><p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效；</li><li>Buffer Pool 污染；</li></ul><h4 id="划分区域的LRU链表">划分区域的LRU链表</h4><ul><li><p><strong>预读</strong></p><p>InnoDB 提供了一个看起来比较贴心的服务—— 预读 （英文名： read ahead ）。所谓 预读 ，就是 InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 Buffer Pool 中。根据触发方式的不同， 预读又可以细分为下边两种：</p><ul><li><p>线性预读</p><p>MySQL提供了一个系统变量 <code>innodb_read_ahead_threshold </code>默认是 56，如果顺序访问了某个区 （ extent ）的页面超过这个系统变量的值，就会触发一次异步读取**下一个区中全部的页面到 Buffer Pool 的请求，注意 异步 读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常 执行。**线性预读也有一定的缺点，比如可能会占用大量的内存资源，导致系统性能下降，或者使得数据库长时间无法对某些数据进行修改操作。</p></li><li><p>随机预读</p><p>当使用InnoDB存储引擎时，在进行扫描操作（例如SELECT、UPDATE、DELETE等）时，**MySQL会随机读取数据页到内存中。这种优化策略可以避免在扫描操作时将所有数据都一次性读入内存，从而避免了缓存命中率低下的问题。**因此每个数据页只有被访问一次的机会，导致线性预读的数据页在内存中暂留时间更长。</p><p>默认不开启，通过调整配置参数（例如innodb_random_read.ahead_ratio）可以设置适当的预读阈值来平衡内存占用和系统性能。随机预读的效果一般优于线性预读，因为它更适合 InnoDB 引擎的 B+ 树索引，在查询条件缺失时可以将多个值集中进行扫描，提高查询效率。</p></li></ul></li></ul><p>预读 本来是个好事儿，如果预读到 Buffer Pool 中的页成功的被使用到，那就可以极大的提高语句执 行的效率。可是如果用不到呢？这些预读的页都会放到 LRU 链表的头部，但是如果此时 Buffer Pool 的 容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 LRU链表 尾部的一些缓存页会很快的 被淘汰掉，也就是所谓的 <strong>劣币驱逐良币 ，会大大降低缓存命中率。</strong></p><ul><li><strong>情况二：需要扫描全表的查询语句–Buffer Pool 污染</strong></li></ul><p>​意味着将访问到该表所在的所有页！假设这个表中记录非常多的话，那该表会占用特 别多的 页 ，当需要访问这些页时，会把它们统统都加载到 Buffer Pool 中，相当于 Buffer Pool 的东西全部换一遍，原本在查询的页，也被替换出去了，也需要再次查询，<strong>又得执行一次从磁盘加载到 Buffer Pool 的操作。而这种全表扫描的语句执行的频率也不高，每次执行都要把 Buffer Pool 中的缓存页换一次血，这 严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。</strong></p><p>总结一下上边说的可能降低 Buffer Pool 的两种情况：</p><ul><li>加载到 Buffer Pool 中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到 Buffer Pool 时，可能会把那些使用频率非常高的页从 Buffer Pool 中淘汰掉。</li></ul><p>因为有这两种情况的存在，InnoDB 把这个 LRU链表 按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 热数据 ，或者称 young区域 。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 冷数据 ，或者称 old区域 。</li></ul><p><img src="HTTPs://zdwtop.cn/blog/image-20230323114021086.png" alt="image-20230323114021086"></p><p>我们是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某 些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。</p><p>默认情况下，InnoDB的old和young区域的比例为8:2。</p><p>有了这个被划分成 young 和 old 区域的 LRU 链表之后， InnoDB 就可以针对我们上边提到的两种可能 降低缓存命中率的情况进行优化了：</p><ul><li>针对预读的页面可能不进行后续访情况的优化</li></ul><p><font color="red"><strong>当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应 的控制块会被放到old区域的头部。</strong></font>这样针对预读到 Buffer Pool 却不进行后续访问的页面就会被逐渐从 old 区域逐出，而不会影响 young 区域中被使用比较频繁的缓存页。</p><ul><li>针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化</li></ul><p>在对某个处在 old 区域的缓存页进行第一次访问时就在它对应的控制块中 记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被 从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量<code> innodb_old_blocks_time</code> 控制的默认值是 1000 ，它的单位是毫秒.</p><p><strong>也就意味着对于从磁盘上被加载到 LRU 链表的 old 区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于 1s （很明显在一次 全表扫描的过程中，多次访问一个页面中的时间不会超过 1s ），那么该页是不会被加入到 young 区域的</strong></p><p>综上所述，正是因为将 LRU 链表划分为 young 和 old 区域这两个部分，又添加了 <code>innodb_old_blocks_time</code> 这个 系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全 表扫描的页面都只会被放到 old 区域，而不影响 young 区域中的缓存页。</p><h4 id="进一步优化LRU链表">进一步优化LRU链表</h4><p>对于 young 区域的缓存页来说，我们每次访问一个缓存页就要把它移 动到 LRU链表 的头部，这样开销太大啦，毕竟在 young 区域的缓存页都是热点数据，也就是可能被经常访问的。</p><p>为了防止lru节点被频繁操作，规定了<strong>只有被访问的缓存页位于 young 区域的 1/4 的后边，才会被移动到 LRU链表 头部，这样就 可以降低调整 LRU链表 的频率，从而提升性能（也就是说如果某个缓存页对应的节点在 young 区域的 1/4 中， 再次访问该缓存页时也不会将其移动到 LRU 链表头部）</strong></p><p>这些操作都是为了<font color="red"><strong>尽量高效的提高 Buffer Pool 的缓存命中率</strong></font></p><h2 id="刷新脏页到磁盘">刷新脏页到磁盘</h2><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：</p><ul><li><p><strong>从 LRU链表 的冷数据中刷新一部分页面到磁盘。</strong></p><p>后台线程会定时从 LRU链表 尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称 之为 <strong>BUF_FLUSH_LRU</strong> 。</p></li><li><p><strong>从 flush链表 中刷新一部分页面到磁盘。</strong></p><p>后台线程也会定时从 flush链表 中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 <strong>BUF_FLUSH_LIST</strong> 。</p></li></ul><p>在 MySQL InnoDB 存储引擎中，后台专门的线程负责将脏数据（即未写入磁盘的数据）刷新到磁盘上。这个过程被称为 Checkpoint。</p><p>Checkpoint：定期地将缓冲池中的所有脏页刷新到磁盘上，以避免在系统发生故障时丢失重要的数据。这个过程是由InnoDB自动完成的，其频率由<code>innodb_checkpoint_interval</code>参数控制。</p><p>在 Checkpoint 过程中，一般会有两种刷新路径：</p><ul><li><strong>Master thread 写路径</strong></li></ul><p>Master thread 是负责 <strong>LRU List</strong> 管理、缓存池大小控制以及周期性地触发 Checkpoint 的线程。Master thread 在执行 Checkpoint 的过程中，首先会将脏数据写回到 redo log 里面。然后将 checkpoint 信息写到 redo log 文件头部，并强制进行一次 log flush。在这个过程中，InnoDB 引擎使用 async IO 模型，因此不会阻塞主要的用户线程请求。</p><ul><li><strong>Background page cleaner 刷路径</strong></li></ul><p>Background page cleaner 是另一个单独的线程，它的主要作用就是异步执行 <strong>Flush</strong> 操作（**即将脏页刷新到磁盘）。**每当 Master thread 执行一次 Checkpoint 时，都会通知 Background page cleaner 执行 Flush操作。在 Flush 过程中，Background page cleaner 也是采用 async IO 模型，也不会阻塞用户线程请求。</p><h2 id="总的来说，Master-thread-写路径是负责管理车站进出口道闸机器人的、影响依赖性比较大的逻辑，而-Background-page-cleaner-刷路径则是负责执行脏页刷新的工作，两者各自发挥其所长，协同完成数据库运作。">总的来说，<strong>Master thread 写路径是负责管理车站进出口道闸机器人的、影响依赖性比较大的逻辑，而 Background page cleaner 刷路径则是负责执行脏页刷新的工作，两者各自发挥其所长，协同完成数据库运作。</strong></h2><h1>补充-后台线程</h1><p>在 MySQL 中，不同的后台线程执行的刷新或清理操作的时间间隔是不同的。一些常见的后台线程及其执行周期如下：</p><ol><li>刷新线程：刷新缓冲池中的被修改过的数据到磁盘。默认情况下，每个事务提交后都会将日志缓冲区中的日志写入磁盘。可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数的值来控制刷新日志的时间。（即 0-每秒/1-每次提交/2-整个事务提交后）。</li><li>LRU 刷新线程：根据 InnoDB 缓冲池使用率和空闲状态，定期将最近最少使用的数据刷回磁盘，保证缓冲池中始终有可用的空间供新读取的数据使用，默认情况下，LRU 刷新线程每秒刷新一次。</li><li>检查点执行线程：使用“脏页”机制（InnoDB 中指暂未写入磁盘的修改数据页），定期执行检查点来将所有脏页持久化到磁盘上。检查点执行线程的执行周期由内部算法来决定。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;调节磁盘和CPU的矛盾-InnoDB的Buffer Pool&lt;/h1&gt;
&lt;h2 id=&quot;为什么要有-Buffer-Pool？&quot;&gt;为什么要有 Buffer Pool？&lt;/h2&gt;
&lt;p&gt;对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚 簇索引</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="innodb" scheme="https://eizo01.github.io/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级数据结构</title>
    <link href="https://eizo01.github.io/posts/c9e7ec61.html"/>
    <id>https://eizo01.github.io/posts/c9e7ec61.html</id>
    <published>2022-11-03T12:00:00.000Z</published>
    <updated>2023-03-18T14:08:50.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis高级数据结构"><a href="#Redis高级数据结构" class="headerlink" title="Redis高级数据结构"></a>Redis高级数据结构</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>现代计算机用二进制(位)作为信息的基础单位，1个字节等于8位，例如“big”字符串是由3个字节组成，但实际在计算机存储时将其用二进制表示,“big”分别对应的ASCII码分别是98、105、103，对应的二进制分别是01100010、01101001和 01100111。</p><p><img src="https://zdwtop.cn/blog/bitmap.png" alt="img"></p><p>许多开发语言都提供了操作位的功能，合理地使用位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据结构”可以实现对位的操作。把数据结构加上引号主要因为:</p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h4 id="setbit-设置值"><a href="#setbit-设置值" class="headerlink" title="setbit 设置值"></a>setbit 设置值</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key <span class="built_in">offset</span> value</span><br></pre></td></tr></table></figure><p>设置键的第 offset 个位的值(从0算起)。</p><p>假设现在有20个用户，userid=0,2,4,6,8的用户对网站进行了访问，存储键名为日期。</p><p><img src="HTTPs://zdwtop.cn/blog/faf895f88aa940ea854dba440b8030e7.png" alt="image.png"></p><h4 id="getbit-获取值"><a href="#getbit-获取值" class="headerlink" title="getbit 获取值"></a>getbit 获取值</h4><p><code>getbit key offset</code></p><p>获取键的第 offset位的值(从0开始算)，比如<strong>获取userid=8的用户是否在2022（年/这天）访问过,返回0说明没有访问过:</strong></p><p>当然offset是不存在的，也会返回0。</p><p><img src="HTTPs://zdwtop.cn/blog/a32b45af412f4ab6a0345447cd7c4ea7.png" alt="image.png"></p><h4 id="bitcount-获取Bitmaps指定范围值为1的个数"><a href="#bitcount-获取Bitmaps指定范围值为1的个数" class="headerlink" title="bitcount 获取Bitmaps指定范围值为1的个数"></a>bitcount 获取Bitmaps指定范围值为1的个数</h4><p><code>bitcount [start] [end]</code></p><p>下面操作计算26号和27号这天的独立访问用户数量</p><p><strong>[start]和[end]代表起始和结束字节数</strong></p><p><img src="HTTPs://zdwtop.cn/blog/6f10ab793dfa4e4bb9cc297344544f17.png" alt="image.png"></p><h4 id="bitop-Bitmaps-间的运算"><a href="#bitop-Bitmaps-间的运算" class="headerlink" title="bitop Bitmaps 间的运算"></a>bitop Bitmaps 间的运算</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">  <span class="keyword">AND</span> 与运算 <span class="operator">&amp;</span></span><br><span class="line">  <span class="keyword">OR</span> 或运算 <span class="operator">|</span></span><br><span class="line">  XOR 异或 <span class="operator">^</span></span><br><span class="line">  <span class="keyword">NOT</span> 取反 <span class="operator">~</span></span><br><span class="line"># <span class="keyword">result</span> 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，<span class="keyword">not</span>运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [<span class="keyword">result</span>] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定<span class="keyword">value</span>(<span class="number">0</span><span class="operator">/</span><span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [<span class="keyword">value</span>]</span><br></pre></td></tr></table></figure><p>bitop是一个复合操作，它可以做多个Bitmaps 的 and(交集)or(并集)not(非)xor(异或）操作并将结果保存在destkey中。</p><h4 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h4><p>-计算Bitmaps中第一个值为targetBit 的偏移量</p><p><code>bitpos key targetBit [start] [end]</code></p><p>除此之外，bitops有两个选项[start]和[end]，分别代表起始字节和结束字节。</p><p><img src="HTTPs://zdwtop.cn/blog/6cc67c513009442a9ecf29beed3188af.png" alt="image.png"></p><h4 id="Bitmaps优势"><a href="#Bitmaps优势" class="headerlink" title="Bitmaps优势"></a>Bitmaps优势</h4><p>假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和 Bitmaps分别存储活跃用户，很明显，假如用户id是Long型，64位，则集合类型占据的空间为64位x50 000 000= 400MB，而Bitmaps则需要1位×100 000 000=12.5MB，可见Bitmaps能节省很多的内存空间。</p><h5 id="面试题和场景"><a href="#面试题和场景" class="headerlink" title="面试题和场景"></a>面试题和场景</h5><p>1、目前有10亿数量的自然数，乱序排列，需要对其排序。限制条件-在32位机器上面完成，内存限制为 2G。如何完成？</p><p>2、如何快速在亿级黑名单中快速定位URL地址是否在黑名单中？(每条URL平均64字节)</p><p>3、需要进行用户登陆行为分析，来确定用户的活跃情况？</p><p>4、网络爬虫-如何判断URL是否被爬过？</p><p>5、快速定位用户属性（黑名单、白名单等）</p><p>6、数据存储在磁盘中，如何避免大量的无效IO？</p><h5 id="传统数据结构的不足"><a href="#传统数据结构的不足" class="headerlink" title="传统数据结构的不足"></a>传统数据结构的不足</h5><p>当然有人会想，我直接将网页URL存入数据库进行查找不就好了，或者建立一个哈希表进行查找不就OK了。</p><p>当数据量小的时候，这么思考是对的，</p><p>确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，举个例子如果一个1000万HashMap，Key=String（长度不超过16字符，且重复性极小），Value=Integer，会占据多少空间呢？1.2个G。实际上，1000万个int型，只需要40M左右空间，占比3%，1000万个Integer，需要161M左右空间，占比13.3%。可见一旦你的值很多例如上亿的时候，那HashMap 占据的内存大小就变得很可观了。</p><p>但如果整个网页黑名单系统包含100亿个网页URL，在数据库查找是很费时的，并且如果每个URL空间为64B，那么需要内存为640GB，一般的服务器很难达到这个需求。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><p><strong>1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。<br>这种算法由一个二进制数组和一个 Hash 算法组成。</strong></p><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>实际上，布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等，Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数，Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。</p><p><img src="https://zdwtop.cn/blog/801f60ff2d28436faaaab3007dd7d893.png" alt="image.png"></p><h3 id="布隆过滤器的误判问题"><a href="#布隆过滤器的误判问题" class="headerlink" title="布隆过滤器的误判问题"></a>布隆过滤器的误判问题</h3><p>Ø通过hash计算在数组上不一定在集合</p><p>Ø本质是hash冲突</p><p>Ø通过hash计算不在数组的一定不在集合（误判）</p><p><img src="https://zdwtop.cn/blog/d31bbeaf5a8742d2b15ce65bbc5a4537.png" alt="image.png"></p><p><strong>优化方案</strong></p><p>增大数组(预估适合值)</p><p>增加hash函数</p><p><img src="HTTPs://zdwtop.cn/blog/84b1457186f44856b6ad56561ba64229.png" alt="image.png"></p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>HyperLogLog并不是一种新的数据结构(实际类型为字符串类型)，而是一种基数算法,通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p><p>如果你负责开发维护一个大型的网站，有一天产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？</p><p>如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p><p>但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一 ID 来标识。</p><p>一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。</p><p>百万级用户访问网站</p><p><img src="HTTPs://zdwtop.cn/blog/494d8e7c3cbc464db90935208fa20d44.png" alt="image.png"></p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>HyperLogLog提供了3个命令: pfadd、pfcount、pfmerge。</p><h4 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h4><p><code>pfadd key element [element …]</code></p><p>pfadd用于向HyperLogLog 添加元素,如果添加成功返回1:</p><p>pfadd u-9-30 u1 u2 u3 u4 u5 u6 u7 u8</p><p><img src="HTTPs://zdwtop.cn/blog/c6de0b04ae7b43e69528a24301d7920b.png" alt="image.png"></p><h4 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h4><p><code>pfcount key [key …]</code></p><p>pfcount用于计算一个或多个HyperLogLog的独立总数，例如u-9-30 的独立总数为8:</p><p><img src="HTTPs://zdwtop.cn/blog/a86c5c198cef4717864fd2794eaf3624.png" alt="image.png"></p><p>如果此时向插入一些用户，用户并且有重复</p><p><img src="HTTPs://zdwtop.cn/blog/689ddb0df4164a98bb7d078e45af9fda.png" alt="image.png"></p><p>如果我们继续往里面插入数据，比如插入100万条用户记录。内存增加非常少，但是pfcount 的统计结果会出现误差。</p><h4 id="pfmerge"><a href="#pfmerge" class="headerlink" title="pfmerge"></a>pfmerge</h4><p><code>pfmerge destkey sourcekey [sourcekey ... ]</code></p><p>pfmerge可以求出多个HyperLogLog的并集并赋值给destkey，请自行测试。</p><p>可以看到，HyperLogLog内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是100%的正确，其中一定存在误差率。前面说过，Redis官方给出的数字是0.81%的失误率。</p><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>HyperLogLog基于概率论中伯努利试验并结合了极大似然估算方法，并做了分桶优化。</p><p>实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:</p><p>举个例子来理解HyperLogLog<br>算法，有一天李瑾老师和马老师玩打赌的游戏。</p><p>规则如下: 抛硬币的游戏，每次抛的硬币可能正面，可能反面，没回合一直抛，直到每当抛到正面回合结束。</p><p>然后我跟马老师说，抛到正面最长的回合用到了7次，你来猜一猜，我用到了多少个回合做到的？</p><p><img src="https://zdwtop.cn/blog/b908ff160cdd4eed858e76b248fd880e.png" alt="image.png"></p><p>进行了n次实验，比如上图：</p><p>第一次试验: 抛了3次才出现正面，此时 k=3，n=1</p><p>第二次试验: 抛了2次才出现正面，此时 k=2，n=2</p><p>第三次试验: 抛了4次才出现正面，此时 k=4，n=3</p><p>…………</p><p>第n 次试验：抛了7次才出现正面，此时我们估算，k=7</p><p>马老师说大概你抛了128个回合。这个是怎么算的。</p><p>k是每回合抛到1所用的次数，我们已知的是最大的k值，可以用kmax表示。由于每次抛硬币的结果只有0和1两种情况，因此，能够推测出kmax在任意回合出现的概率 ，并由kmax结合极大似然估算的方法推测出n的次数n =<br>2^(k_max) 。概率学把这种问题叫做伯努利实验。</p><p>但是问题是，这种本身就是概率的问题，我跟马老师说，我只用到12次，并且有视频为证。</p><p>所以这种预估方法存在较大误差，为了改善误差情况，HLL中引入分桶平均的概念。</p><p>同样举抛硬币的例子，如果只有一组抛硬币实验，显然根据公式推导得到的实验次数的估计误差较大；如果100个组同时进行抛硬币实验，受运气影响的概率就很低了，每组分别进行多次抛硬币实验，并上报各自实验过程中抛到正面的抛掷次数的最大值，就能根据100组的平均值预估整体的实验次数了。</p><p>分桶平均的基本原理是将统计数据划分为m个桶，每个桶分别统计各自的kmax,并能得到各自的基数预估值，最终对这些基数预估值求平均得到整体的基数估计值。LLC中使用几何平均数预估整体的基数值，但是当统计数据量较小时误差较大；HLL在LLC基础上做了改进，<strong>采用调和平均数过滤掉不健康的统计值</strong>。</p><p>什么叫调和平均数呢？举个例子</p><p>求平均工资：A的是1000/月，B的30000/月。采用平均数的方式就是：<br>(1000 + 30000) / 2 = 15500</p><p>采用调和平均数的方式就是：<br>2/(1/1000 + 1/30000) ≈ 1935.484</p><p>可见调和平均数比平均数的好处就是不容易受到大的数值的影响，比平均数的效果是要更好的。</p><h4 id="结合Redis的实现理解原理"><a href="#结合Redis的实现理解原理" class="headerlink" title="结合Redis的实现理解原理"></a>结合Redis的实现理解原理</h4><p>现在我们和前面的业务场景进行挂钩：统计网页每天的 UV 数据。</p><h4 id="1-转为比特串"><a href="#1-转为比特串" class="headerlink" title="1.转为比特串"></a><strong>1.转为比特串</strong></h4><p>通过hash函数，将数据转为二进制的比特串，例如输入5，便转为：101。为什么要这样转化呢？</p><p>是因为要和抛硬币对应上，比特串中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 10010000，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。</p><p>那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。</p><h4 id="2-分桶"><a href="#2-分桶" class="headerlink" title="2.分桶"></a><strong>2.分桶</strong></h4><p>分桶就是分多少轮。抽象到计算机存储中去，就是存储的是一个以单位是比特(bit)，长度为 L 的大数组 S ，将 S 平均分为 m 组，注意这个 m 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：</p><p>比如有4个桶的话，那么可以截取低2位作为分桶的依据。</p><p>比如</p><p>10010000   进入0号桶</p><p>10010001   进入1号桶</p><p>10010010   进入2号桶</p><p>10010011   进入3号桶</p><h5 id="Redis-中的-HyperLogLog-实现"><a href="#Redis-中的-HyperLogLog-实现" class="headerlink" title="Redis 中的 HyperLogLog 实现"></a>Redis 中的 HyperLogLog 实现</h5><p><strong>pfadd</strong></p><p><img src="HTTPs://zdwtop.cn/blog/116ef8fb48584cc5910184aaf50092a1.png" alt="image.png"></p><p>当我们执行这个操作时，lijin这个字符串就会被转化成64个bit的二进制比特串。</p><p>0010….0001  64位</p><p>然后在Redis中要分到16384个桶中（为什么是这么多桶：第一降低误判，第二，用到了14位二进制：2的14次方=16384）</p><p>怎么分？根据得到的比特串的后14位来做判断即可。</p><p><img src="https://zdwtop.cn/blog/bd71287e85294b14b95e3fcb82243fab.png" alt="image.png"></p><p>根据上述的规则，我们知道这个数据要分到 1号桶，同时从左往右（低位到高位）计算第1个出现的1的位置，这里是第4位，那么就往这个1号桶插入4的数据（转成二进制）</p><p>如果有第二个数据来了，按照上述的规则进行计算。</p><p>那么问题来了，如果分到桶的数据有重复了（这里比大小，大的替换小的）：</p><p>规则如下，比大小（比出现位置的大小），比如有个数据是最高位才出现1，那么这个位置算出来就是50，50比4大，则进行替换。1号桶的数据就变成了50（二进制是110010）</p><p>所以这里可以看到，每个桶的数据一般情况下6位存储即可。</p><p>所以我们这里可以推算一下一个key的HyperLogLog只占据多少的存储。</p><p>16384*6 /8/1024=12k。并且这里最多可以存储多少数据，因为是64位吗，所以就是2的64次方的数据，这个存储的数据非常非常大的，一般用户用long来定义，最大值也只有这么多。</p><p><strong>pfcount</strong></p><p>进行统计的时候，就是把16384桶，把每个桶的值拿出来，比如取出是 n,那么访问次数就是2的n次方。</p><p><img src="https://zdwtop.cn/blog/37ea459470614e8fad06c5eab8a009ca.png" alt="image.png"></p><p>然后把每个桶的值做调和平均数，就可以算出一个算法值。</p><p>同时，在具体的算法实现上，HLL还有一个分阶段偏差修正算法。我们就不做更深入的了解了。</p><p><img src="https://zdwtop.cn/blog/50bed8f5a0394a93aa8033ee9f847672.png" alt="image.png"></p><p>const和m都是Redis里面根据数据做的调和平均数。</p><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="滴滴叫车"><a href="#滴滴叫车" class="headerlink" title="滴滴叫车"></a>滴滴叫车</h4><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p><p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure><p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p><p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>Stream 消息队列操作命令：</p><ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XLEN ：查询消息长度；</li><li>XREAD：用于读取消息，可以按 ID 读取数据；</li><li>XDEL ： 根据消息 ID 删除消息；</li><li>DEL ：删除整个 Stream；</li><li>XRANGE ：读取区间消息</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING 和 XACK：<ul><li>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li><li>XACK 命令用于向消息队列确认消息处理已完成；</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis高级数据结构&quot;&gt;&lt;a href=&quot;#Redis高级数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis高级数据结构&quot;&gt;&lt;/a&gt;Redis高级数据结构&lt;/h2&gt;&lt;h3 id=&quot;Bitmaps&quot;&gt;&lt;a href=&quot;#Bitmaps&quot; c</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用数据结构</title>
    <link href="https://eizo01.github.io/posts/a765d482.html"/>
    <id>https://eizo01.github.io/posts/a765d482.html</id>
    <published>2022-11-02T12:00:00.000Z</published>
    <updated>2023-03-17T14:20:13.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h1><p>Redis提供了一些数据结构供我们往Redis中存取数据，最常用的的有5种，<strong>字符串（String）、哈希(Hash)、列表（list）、集合（set）、有序集合（ZSET）</strong>。</p><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p>字符串类型是Redis最基础的数据结构。首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的，所以字符串类型能为其他四种数据结构的学习奠定基础。字符串类型的值实际可以是字符串(简单的字符串、复杂的字符串(例如JSON、XML))、数字(整数、浮点数)，甚至是二进制(图片、音频、视频)，但是<strong>值最大不能超过512MB</strong>。</p><p>（虽然Redis是C写的，C里面有字符串&#x3c;本质使用char数组来实现&gt;，但是处于种种考虑，Redis还是自己实现了字符串类型）</p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="set-设置值"><a href="#set-设置值" class="headerlink" title="set 设置值"></a>set 设置值</h4><p><code>set key value</code><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/1dab86326fa249cd9d1ab118b48e9c6a.png" alt="image.png"></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emos:3&gt;set name zdw</span><br><span class="line"></span><br><span class="line">&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">emos:3&gt;get name</span><br><span class="line"></span><br><span class="line">&quot;zdw&quot;</span><br></pre></td></tr></table></figure><p>set命令有几个选项:</p><ul><li>ex seconds: 为键设置秒级过期时间。</li></ul><ul><li>px milliseconds: 为键设置毫秒级过期时间。</li></ul><ul><li>nx: 键必须不存在,才可以设置成功，用于添加（分布式锁常用）。</li></ul><ul><li>xx: 与nx相反,键必须存在，才可以设置成功,用于更新。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 设置过期时间</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> name zdw ex <span class="number">10</span></span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl name</span><br><span class="line">&quot;5&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl name</span><br><span class="line">&quot;4&quot;</span><br><span class="line">#设置毫秒数</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> name zdw px <span class="number">100</span></span><br><span class="line">&quot;OK</span><br></pre></td></tr></table></figure><p><strong>从执行效果上看，ex参数和expire命令基本一样。还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了set 方法修改了它，它的过期时间会消失。</strong></p><p>而nx和xx执行效果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#键必须不存在,才可以设置成功</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> nx<span class="operator">-</span>name</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> nx<span class="operator">-</span>name zdw nx</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"># 设置xx 键必须存在才能设置</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw xx</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw nx</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> xx<span class="operator">-</span>name zdw xx</span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure><p>除了set选项，Redis 还提供了setex和 setnx两个命令:</p><p><code>setex key seconds value</code></p><p><code>setnx key value</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 键必须不存在 setnx成功,返回结果为<span class="number">1</span>。setnx失败,返回结果为<span class="number">0</span>，</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setnx zdw01 zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setnx zdw01 zdw</span><br><span class="line">&quot;0&quot;</span><br><span class="line">#设置key过期时间</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setex zdw <span class="number">10</span> zdw</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl zdw</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>ttl zdw</span><br><span class="line">&quot;4&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>setex和 setnx的作用和ex和nx选项是一样的。也就是，setex为键设置秒级过期时间，setnx设置时键必须不存在,才可以设置成功。</strong></p><p>有什么应用场景吗?以setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。当然分布式锁不是只有一个命令就OK了，其中还有很多的东西要注意，我们后面会用单独的分析来讲述基于Redis的分布式锁。</p><h4 id="get-获取值"><a href="#get-获取值" class="headerlink" title="get 获取值"></a>get 获取值</h4><p>如果要获取的键不存在,则返回nil(空):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> zdw01</span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> zdw02</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="mset-批量设置值"><a href="#mset-批量设置值" class="headerlink" title="mset 批量设置值"></a>mset 批量设置值</h4><p>通过mset命令一次性设置4个键值对</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>mset a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span> d <span class="number">4</span></span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure><h4 id="mget-批量获取值"><a href="#mget-批量获取值" class="headerlink" title="mget 批量获取值"></a>mget 批量获取值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>mget a a1 b c c1 d</span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">2</span>) <span class="keyword">null</span></span><br><span class="line"><span class="number">3</span>) &quot;2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;3&quot;</span><br><span class="line"><span class="number">5</span>) <span class="keyword">null</span></span><br><span class="line"><span class="number">6</span>) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>批量获取了键a、b、c、d的值:</p><p>如果有些键不存在,那么它的值为nil(空)，结果是按照传入键的顺序返回。</p><p>批量操作命令可以有效提高效率，假如没有mget这样的命令，要执行n次get命令具体耗时如下:</p><p><strong>n次 get时间=n次网络时间+n次命令时间</strong></p><p>使用mget命令后，要执行n次get命令操作具体耗时如下:</p><p><strong>n次get时间=1次网络时间+n次命令时间</strong></p><p>Redis可以支撑每秒数万的读写操作，但是这指的是<strong>Redis服务端的处理能力</strong>，对于客户端来说，<strong>一次命令除了命令时间还是有网络时间，假设网络时间为1毫秒，命令时间为0.1毫秒(按照每秒处理1万条命令算)，那么执行1000次 get命令需要1.1秒(1000<em>1+1000</em>0.1=1100ms)，1次mget命令的需要0.101秒(1<em>1+1000</em>0.1=101ms)。</strong></p><h4 id="Incr-数字运算"><a href="#Incr-数字运算" class="headerlink" title="Incr 数字运算"></a>Incr 数字运算</h4><p>incr命令用于对值做自增操作,返回结果分为三种情况：</p><ul><li>值不是整数,返回错误。</li></ul><ul><li>值是整数，返回自增后的结果。</li></ul><ul><li>键不存在，按照值为0自增,返回结果为1。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 键不存在，按照值为<span class="number">0</span>自增,返回结果为<span class="number">1</span>。</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">exists</span> incr<span class="operator">-</span>key</span><br><span class="line">&quot;0&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr incr<span class="operator">-</span>key</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr incr<span class="operator">-</span>key</span><br><span class="line">&quot;2&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> hello zdw</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"># 值不是整数,返回错误。</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>incr hello</span><br><span class="line">&quot;ERR value is not an integer or out of range&quot;</span><br></pre></td></tr></table></figure><p>除了incr命令，Redis提供了<code>decr</code>(自减)、 <code>incrby</code>(自增指定数字)、<code>decrby</code>(自减指定数字)、<code>incrbyfloat</code>（自增浮点数)，具体效果请大家自行尝试。</p><h4 id="append追加指令"><a href="#append追加指令" class="headerlink" title="append追加指令"></a>append追加指令</h4><p>append可以向字符串尾部追加值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello </span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>append hello good</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello </span><br><span class="line">&quot;zdwgood&quot;</span><br></pre></td></tr></table></figure><h4 id="strlen-字符串长度"><a href="#strlen-字符串长度" class="headerlink" title="strlen 字符串长度"></a>strlen 字符串长度</h4><p>返回字符串长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>strlen hello</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">set</span> k1 &quot;中文&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>strlen k1</span><br><span class="line">&quot;6&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> k1</span><br><span class="line">&quot;中文&quot;</span><br></pre></td></tr></table></figure><p>注意：每个中文占3个字节</p><h4 id="getset-设置并返回原值"><a href="#getset-设置并返回原值" class="headerlink" title="getset 设置并返回原值"></a>getset 设置并返回原值</h4><p>客户端测试不出来，在linux测试出来</p><p>getset和set一样会设置值,但是不同的是，它同时会返回键原来的值</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d568dc6e0a6c4adeae13d8f63a8fd0d8.png" alt="image.png"></p><h4 id="setrange-设置指定位置的字符"><a href="#setrange-设置指定位置的字符" class="headerlink" title="setrange 设置指定位置的字符"></a>setrange 设置指定位置的字符</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgood&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>setrange hello <span class="number">4</span> d</span><br><span class="line">&quot;7&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgdod&quot;</span><br></pre></td></tr></table></figure><p>下标从0开始计算。</p><h4 id="getrange-截取字符串"><a href="#getrange-截取字符串" class="headerlink" title="getrange 截取字符串"></a>getrange 截取字符串</h4><p>getrange 截取字符串中的一部分，形成一个子串，需要指明开始和结束的偏移量，截取的范围是个闭区间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span><span class="keyword">get</span> hello</span><br><span class="line">&quot;zdwgood&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>getrange hello <span class="number">0</span> <span class="number">2</span></span><br><span class="line">&quot;zdw&quot;</span><br></pre></td></tr></table></figure><h4 id="命令的时间复杂度"><a href="#命令的时间复杂度" class="headerlink" title="命令的时间复杂度"></a>命令的时间复杂度</h4><p>字符串这些命令中，除了del 、mset、 mget支持多个键的批量操作，时间复杂度和键的个数相关，为O(n)，getrange和字符串长度相关，也是O(n)，其余的命令基本上都是O(1)的时间复杂度，在速度上还是非常快的。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>字符串类型的使用场景很广泛：</p><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL作为存储层，绝大部分请求的数据都是从Redis中获取。由于Redis具有支撑高并发的特性,所以缓存通常能起到加速读写和降低后端压力的作用。</p><p><strong>计数</strong></p><p>使用Redis 作为计数的基础工具，它可以实现快速计数、查询缓存的功能,同时数据可以异步落地到其他数据源。</p><p><strong>共享Session</strong></p><p>一个分布式Web服务将用户的Session信息（例如用户登录信息)保存在各自服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器上，用户刷新一次访问可能会发现需要重新登录，这个问题是用户无法容忍的。</p><p>为了解决这个问题,可以使用Redis将用户的Session进行集中管理,，在这种模式下只要保证Redis是高可用和扩展性的,每次用户更新或者查询登录信息都直接从Redis中集中获取。</p><p><strong>限速</strong></p><p>比如，很多应用出于安全的考虑,会在每次进行登录时,让用户输入手机验证码,从而确定是否是用户本人。但是为了短信接口不被频繁访问,会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。一些网站限制一个IP地址不能在一秒钟之内方问超过n次也可以采用类似的思路。</p><h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h2><p>Java里提供了HashMap，Redis中也有类似的数据结构，就是哈希类型。但是要注意，哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值。</p><h3 id="操作命令-1"><a href="#操作命令-1" class="headerlink" title="操作命令"></a>操作命令</h3><p>基本上，哈希的操作命令和字符串的操作命令很类似，很多命令在字符串类型的命令前面加上了h字母，代表是操作哈希类型，同时还要指明要操作的field的值。</p><h4 id="hset设值"><a href="#hset设值" class="headerlink" title="hset设值"></a>hset设值</h4><p>hset user:1 name lijin</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zdw</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果设置成功会返回1，反之会返回0。此外Redis提供了hsetnx命令，它们的关系就像set和setnx命令一样,只不过作用域由键变为field。</p><h4 id="hget取值"><a href="#hget取值" class="headerlink" title="hget取值"></a>hget取值</h4><p>hget user:1 name</p><p>如果键或field不存在，会返回nil。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">1</span> name </span><br><span class="line">&quot;zdw&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">1</span> name1</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hget <span class="keyword">user</span>:<span class="number">2</span> name1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="hdel删除field"><a href="#hdel删除field" class="headerlink" title="hdel删除field"></a>hdel删除field</h4><p>hdel会删除一个或多个field，返回结果为成功删除field的个数。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/45ed460d37c04b31bbd5122cd964a0e3.png" alt="image.png"></p><h4 id="hlen计算field个数"><a href="#hlen计算field个数" class="headerlink" title="hlen计算field个数"></a>hlen计算field个数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hlen <span class="keyword">user</span>:<span class="number">1</span> </span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name zzz</span><br><span class="line">&quot;0&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hset <span class="keyword">user</span>:<span class="number">1</span> name1 zdw</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>hlen <span class="keyword">user</span>:<span class="number">1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="hmset批量设值"><a href="#hmset批量设值" class="headerlink" title="hmset批量设值"></a>hmset批量设值</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/dbad743d5eed4f7eb98c39e345ba2687.png" alt="image.png"></p><h4 id="hmget批量取值"><a href="#hmget批量取值" class="headerlink" title="hmget批量取值"></a>hmget批量取值</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/04c34b6e61004b32835ff377a05a5586.png" alt="image.png"></p><h4 id="hexists判断field是否存在"><a href="#hexists判断field是否存在" class="headerlink" title="hexists判断field是否存在"></a>hexists判断field是否存在</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7a182a0b69dc43c7a76f2119eca3910e.png" alt="image.png"></p><p>若存在返回1，不存在返回0</p><h4 id="hkeys获取所有field"><a href="#hkeys获取所有field" class="headerlink" title="hkeys获取所有field"></a>hkeys获取所有field</h4><p>它返回指定哈希键所有的field</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7f84f9381fcf48a0ac43af16dbea6b6c.png" alt="image.png"></p><h4 id="hvals获取所有value"><a href="#hvals获取所有value" class="headerlink" title="hvals获取所有value"></a>hvals获取所有value</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d4e3825c1bd446da9973b971834c37be.png" alt="image.png"></p><h4 id="hgetall获取所有field与value"><a href="#hgetall获取所有field与value" class="headerlink" title="hgetall获取所有field与value"></a>hgetall获取所有field与value</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/338a05689b304021aa9b1cd6b601ffd9.png" alt="image.png"></p><p>在使用hgetall时，如果哈希元素个数比较多，会存在阻塞Redis的可能。如果只需要获取部分field，可以使用hmget，如果一定要获取全部field-value，可以使用hscan命令，该命令会渐进式遍历哈希类型，hscan将在后面的章节介绍。</p><h4 id="hincrby增加"><a href="#hincrby增加" class="headerlink" title="hincrby增加"></a>hincrby增加</h4><p>hincrby和 hincrbyfloat，就像incrby和incrbyfloat命令一样，但是它们的作用域是filed。</p><h4 id="hstrlen-计算value的字符串长度"><a href="#hstrlen-计算value的字符串长度" class="headerlink" title="hstrlen 计算value的字符串长度"></a>hstrlen 计算value的字符串长度</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4c52aa4d0f0c4841afa87011982c2151.png" alt="image.png"></p><h4 id="命令的时间复杂度-1"><a href="#命令的时间复杂度-1" class="headerlink" title="命令的时间复杂度"></a>命令的时间复杂度</h4><p>哈希类型的操作命令中，hdel,hmget,hmset的时间复杂度和命令所带的field的个数相关O(k)，hkeys,hgetall,hvals和存储的field的总数相关，O(N)。其余的命令时间复杂度都是O(1)。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>从前面的操作可以看出，String和Hash的操作非常类似，那为什么要弄一个hash出来存储。</p><p>哈希类型比较适宜存放对象类型的数据，我们可以比较下，如果数据库中表记录user为：</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zdw</td><td>18</td></tr><tr><td>2</td><td>msb</td><td>20</td></tr></tbody></table></div><p><strong>1、使用String类型</strong></p><p>需要一条条去插入获取。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">1</span>:name zdw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">1</span>:age  <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">2</span>:name msb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">2</span>:age  <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>优点：简单直观，每个键对应一个值</strong></p><p><strong>缺点：键数过多，占用内存多，用户信息过于分散，不用于生产环境</strong></p><p><strong>2、将对象序列化存入redis</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="keyword">user</span>:<span class="number">1</span> serialize(<span class="keyword">user</span>Info);</span><br></pre></td></tr></table></figure><p><strong>优点：编程简单，若使用序列化合理内存使用率高</strong></p><p><strong>缺点：序列化与反序列化有一定开销，更新属性时需要把userInfo全取出来进行反序列化，更新后再序列化到redis</strong></p><p><strong>3、使用hash类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hmset <span class="keyword">user</span>:<span class="number">1</span> name zdw age <span class="number">18</span></span><br><span class="line"></span><br><span class="line">hmset <span class="keyword">user</span>:<span class="number">2</span> name msb age <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>优点：简单直观，使用合理可减少内存空间消耗</strong></p><p><strong>缺点：要控制内部编码格式，不恰当的格式会消耗更多内存</strong></p><h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>列表( list)类型是用来存储多个有序的字符串，a、b、c、c、b四个元素从左到右组成了一个有序的列表,列表中的每个字符串称为元素(element)，一个列表最多可以存储(2^32-1)个元素(<em>4294967295</em>)。</p><p><img src="https://zdwtop.cn/blog/b2c5e0d8bd6243e59b0c32aa5caa49f1.png" alt="image.png"></p><p>在Redis 中，可以对列表两端插入( push)和弹出(pop)，还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p><p><strong>列表类型有两个特点:</strong></p><p>第一、列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</p><p>第二、列表中的元素可以是重复的。</p><h3 id="操作命令-2"><a href="#操作命令-2" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="lrange-获取指定范围内的元素列表（不会删除元素）"><a href="#lrange-获取指定范围内的元素列表（不会删除元素）" class="headerlink" title="lrange 获取指定范围内的元素列表（不会删除元素）"></a>lrange 获取指定范围内的元素列表（不会删除元素）</h4><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lrange</span> key start end</span><br></pre></td></tr></table></figure><p>索引下标特点：从左到右为0到N-1</p><p><code>lrange 0 -1</code>命令可以从左到右获取列表的所有元素</p><h4 id="rpush-向右插入"><a href="#rpush-向右插入" class="headerlink" title="rpush 向右插入"></a>rpush 向右插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist a</span><br><span class="line">&quot;1&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist b</span><br><span class="line">&quot;2&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist c</span><br><span class="line">&quot;3&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>rpush demolist d</span><br><span class="line">&quot;4&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange demolist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;c&quot;</span><br><span class="line"><span class="number">4</span>) &quot;d&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/33e03ce96b3248ceaac60ccb4fc0b1d8.png" alt="image.png"></p><h4 id="lpush-向左插入"><a href="#lpush-向左插入" class="headerlink" title="lpush 向左插入"></a>lpush 向左插入</h4><p><img src="https://zdwtop.cn/blog/302233f9f0284e46ae26930ac8be1cd2.png" alt="image.png"></p><p><img src="https://zdwtop.cn/blog/abba1d7c8aea4e42a83ca17476c4b9cd.png" alt="image.png"></p><h4 id="linsert-在某个元素前或后插入新元素"><a href="#linsert-在某个元素前或后插入新元素" class="headerlink" title="linsert 在某个元素前或后插入新元素"></a>linsert 在某个元素前或后插入新元素</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE<span class="operator">|</span>AFTER pivot <span class="keyword">value</span></span><br><span class="line"># a之后查个g</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>LINSERT list before a g</span><br><span class="line">&quot;5&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;g&quot;</span><br><span class="line"><span class="number">2</span>) &quot;a&quot;</span><br><span class="line"><span class="number">3</span>) &quot;b&quot;</span><br><span class="line"><span class="number">4</span>) &quot;c&quot;</span><br><span class="line"><span class="number">5</span>) &quot;d&quot;</span><br><span class="line"># a之后插个f</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>LINSERT list after a f</span><br><span class="line">&quot;6&quot;</span><br><span class="line">emos:<span class="number">3</span><span class="operator">&gt;</span>lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;g&quot;</span><br><span class="line"><span class="number">2</span>) &quot;a&quot;</span><br><span class="line"><span class="number">3</span>) &quot;f&quot;</span><br><span class="line"><span class="number">4</span>) &quot;b&quot;</span><br><span class="line"><span class="number">5</span>) &quot;c&quot;</span><br><span class="line"><span class="number">6</span>) &quot;d&quot;</span><br></pre></td></tr></table></figure><h4 id="lpop-从列表左侧弹出（会删除元素）"><a href="#lpop-从列表左侧弹出（会删除元素）" class="headerlink" title="lpop 从列表左侧弹出（会删除元素）"></a>lpop 从列表左侧弹出（会删除元素）</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/cf3b7a2f1d85434689734dea9d467c0f.png" alt="image.png">r</p><p>请注意，弹出来元素就没了。</p><h4 id="rpop-从列表右侧弹出"><a href="#rpop-从列表右侧弹出" class="headerlink" title="rpop 从列表右侧弹出"></a>rpop 从列表右侧弹出</h4><p>rpop将会把列表最右侧的元素d弹出。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/6f55895f739b4a32a1e1c8fde0649031.png" alt="image.png"></p><h4 id="lrem-对指定元素进行删除"><a href="#lrem-对指定元素进行删除" class="headerlink" title="lrem 对指定元素进行删除"></a>lrem 对指定元素进行删除</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/e533d9a779074c3286d81031ca408450.png" alt="image.png"></p><p>lrem命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况：</p><ul><li>count&gt;0，从左到右,删除最多count个元素。</li></ul><ul><li>count&#x3c;0，从右到左,删除最多count绝对值个元素。</li></ul><ul><li>count=0，删除所有。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/ad2833b4c011453f91928891e8a0e036.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/584b9986d80c46668f3fda91c466e340.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/ba19aa483a884537a687051f80967ebb.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/0480e571bc1e44f79b2e80b376ec288e.png" alt="image.png"></p><p>返回值是实际删除元素的个数。</p><h4 id="ltirm-按照索引范围修剪列表"><a href="#ltirm-按照索引范围修剪列表" class="headerlink" title="ltirm 按照索引范围修剪列表"></a>ltirm 按照索引范围修剪列表</h4><p>例如想保留列表中第0个到第1个元素</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/8e52841e88f34a05888da5df0a8a4121.png" alt="image.png">ls</p><h4 id="lset修改指定索引下标的元素"><a href="#lset修改指定索引下标的元素" class="headerlink" title="lset修改指定索引下标的元素"></a>lset修改指定索引下标的元素</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/663c682ce56444e382fc3f1b4da4253c.png" alt="image.png"></p><h4 id="lindex-获取列表指定索引下标的元素"><a href="#lindex-获取列表指定索引下标的元素" class="headerlink" title="lindex 获取列表指定索引下标的元素"></a>lindex 获取列表指定索引下标的元素</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/f0b6ab8eca224305bcd97a4916c33947.png" alt="image.png">l</p><h4 id="llen-获取列表长度"><a href="#llen-获取列表长度" class="headerlink" title="llen 获取列表长度"></a>llen 获取列表长度</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/31f34b4b3ec24f2e89d42b958dc3f343.png" alt="image.png"></p><h4 id="blpop和brpop阻塞式弹出元素"><a href="#blpop和brpop阻塞式弹出元素" class="headerlink" title="blpop和brpop阻塞式弹出元素"></a>blpop和brpop阻塞式弹出元素</h4><p>blpop和brpop是lpop和rpop的阻塞版本，除此之外还支持多个列表类型，也支持设定阻塞时间，单位秒，如果阻塞时间为0，表示一直阻塞下去。我们以brpop为例说明。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a83e89040af7495da20b56ef826e6520.png" alt="image.png"></p><p>A客户端阻塞了（因为没有元素就会阻塞）</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/c11fe0ec650c401cbd69500d99805f85.png" alt="image.png"></p><p>A客户端一直处于阻塞状态。此时我们从另一个客户端B执行</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/c4c83e7fe2ac4f6385ac04b1ecbcf231.png" alt="image.png"></p><p>A客户端则输出</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4b2c7c7b95da4190ab6c772075faec7c.png" alt="image.png"></p><p>注意：brpop后面如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>列表类型可以用于比如：</p><p>消息队列，Redis 的 lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素,多个客户端保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表,因为列表不但是有序的,同时支持按照索引范围获取元素。</p><p><strong>实现其他数据结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpush <span class="operator">+</span>lpop <span class="operator">=</span>Stack（栈)</span><br><span class="line"></span><br><span class="line">lpush <span class="operator">+</span> rpop <span class="operator">=</span>Queue(队列)</span><br><span class="line"></span><br><span class="line">lpsh <span class="operator">+</span> ltrim <span class="operator">=</span>Capped Collection（有限集合)</span><br><span class="line"></span><br><span class="line">lpush <span class="operator">+</span> brpop<span class="operator">=</span>Message Queue(消息队列)</span><br></pre></td></tr></table></figure><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p><img src="https://zdwtop.cn/blog/4b28f3a2aa6b4d4f9c5dd09317508102.png" alt="image.png"></p><p>集合( set）类型也是用来保存多个的字符串元素,但和列表类型不一样的是，<strong>集合中不允许有重复元素,并且集合中的元素是无序的,不能通过索引下标获取元素。</strong></p><p>一个集合最多可以存储2的32次方-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取<strong>交集、并集、差集</strong>，合理地使用好集合类型,能在实际开发中解决很多实际问题。</p><h3 id="集合内操作命令"><a href="#集合内操作命令" class="headerlink" title="集合内操作命令"></a>集合内操作命令</h3><h4 id="sadd-添加元素"><a href="#sadd-添加元素" class="headerlink" title="sadd 添加元素"></a>sadd 添加元素</h4><p>允许添加多个，返回结果为添加成功的元素个数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d94f1e8871054f6dad9dad1d245d3dfb.png" alt="image.png"></p><h4 id="srem-删除元素"><a href="#srem-删除元素" class="headerlink" title="srem 删除元素"></a>srem 删除元素</h4><p>允许删除多个，返回结果为成功删除元素个数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/fdcc39ccdf4c4ca1bb26003e65d40ec7.png" alt="image.png"></p><h4 id="scard-计算元素个数"><a href="#scard-计算元素个数" class="headerlink" title="scard 计算元素个数"></a>scard 计算元素个数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/292819f68b294180ad037dc590e8c562.png" alt="image.png"></p><h4 id="sismember-判断元素是否在集合中"><a href="#sismember-判断元素是否在集合中" class="headerlink" title="sismember 判断元素是否在集合中"></a>sismember 判断元素是否在集合中</h4><p>如果给定元素element在集合内返回1，反之返回0</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/94148d18517a44d99cd6c7716d07f9b1.png" alt="image.png"></p><h4 id="srandmember-随机从集合返回指定个数元素"><a href="#srandmember-随机从集合返回指定个数元素" class="headerlink" title="srandmember 随机从集合返回指定个数元素"></a>srandmember 随机从集合返回指定个数元素</h4><p>指定个数如果不写默认为1</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/2b386e0de6df44c685dc69e95bf4e7a2.png" alt="image.png"></p><h4 id="spop-从集合随机弹出元素"><a href="#spop-从集合随机弹出元素" class="headerlink" title="spop 从集合随机弹出元素"></a>spop 从集合随机弹出元素</h4><p>同样可以指定个数，如果不写默认为1，注意，既然是弹出，spop命令执行后,元素会从集合中删除,而srandmember不会。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/172580272c8b4413908328fad51e0537.png" alt="image.png"></p><h4 id="smembers-获取所有元素-不会弹出元素"><a href="#smembers-获取所有元素-不会弹出元素" class="headerlink" title="smembers 获取所有元素(不会弹出元素)"></a>smembers 获取所有元素(不会弹出元素)</h4><p>返回结果是无序的</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/f16f1615505b49a2aa5198a75168c4b2.png" alt="image.png"></p><h4 id="集合间操作命令"><a href="#集合间操作命令" class="headerlink" title="集合间操作命令"></a>集合间操作命令</h4><p>现在有两个集合,它们分别是set1和set2</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/8546a5e8eff348bd8c4879fbc37db67b.png" alt="image.png"></p><h4 id="sinter-求多个集合的交集"><a href="#sinter-求多个集合的交集" class="headerlink" title="sinter 求多个集合的交集"></a>sinter 求多个集合的交集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/80dd47f94b06433daa0b1f19be6a684f.png" alt="image.png"></p><h4 id="suinon-求多个集合的并集"><a href="#suinon-求多个集合的并集" class="headerlink" title="suinon 求多个集合的并集"></a>suinon 求多个集合的并集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/614e67ffe97646389a781099b6e074fd.png" alt="image.png"></p><h4 id="sdiff-求多个集合的差集"><a href="#sdiff-求多个集合的差集" class="headerlink" title="sdiff 求多个集合的差集"></a>sdiff 求多个集合的差集</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/4c0e783c37e64c15866bb08ccc0abbf8.png" alt="image.png"></p><h4 id="将交集、并集、差集的结果保存"><a href="#将交集、并集、差集的结果保存" class="headerlink" title="将交集、并集、差集的结果保存"></a>将交集、并集、差集的结果保存</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">suionstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">sdiffstore destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure><p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis提供了上面三个命令(原命令+store)将集合间交集、并集、差集的结果保存在destination key中，例如：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/450fcb6c2e2342b39925c1779a4ba369.png" alt="image.png"></p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是<strong>标签(tag)</strong>。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。</p><p>例如一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。</p><p>除此之外，集合还可以通过生成随机数进行比如抽奖活动，以及社交图谱等等。</p><h2 id="有序集合（ZSET）"><a href="#有序集合（ZSET）" class="headerlink" title="有序集合（ZSET）"></a>有序集合（ZSET）</h2><p><img src="https://zdwtop.cn/blog/fe24d4258f4b4dd99ad52a6752a840ae.png" alt="image.png"></p><p>有序集合相对于哈希、列表、集合来说会有一点点陌生,但既然叫有序集合,那么它和集合必然有着联系,<strong>它保留了集合不能有重复成员的特性,但不同的是,有序集合中的元素可以排序。</strong>但是它和列表使用索引下标作为排序依据不同的是,它<strong>给每个元素设置一个分数( score)作为排序的依据。</strong></p><p>有序集合中的元素不能重复，但是<strong>score可以重复</strong>，就和一个班里的同学学号不能重复,但是考试成绩可以相同。</p><p>有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p><h3 id="集合内操作命令-1"><a href="#集合内操作命令-1" class="headerlink" title="集合内操作命令"></a>集合内操作命令</h3><h4 id="zadd添加成员"><a href="#zadd添加成员" class="headerlink" title="zadd添加成员"></a>zadd添加成员</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/353cb7b71ca04daab3cf7fb99ceb36f6.png" alt="image.png"></p><p>返回结果代表成功添加成员的个数</p><p>要注意:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a8a349c237304f6c94f0a16f5ae3ed24.png" alt="image.png"></p><p>zadd命令还有四个选项nx、xx、ch、incr 四个选项</p><ul><li>nx: member必须不存在，才可以设置成功，用于添加。</li></ul><ul><li>xx: member必须存在，才可以设置成功,用于更新。</li></ul><ul><li>ch: 返回此次操作后,有序集合元素和分数发生变化的个数</li></ul><ul><li>incr: 对score做增加，相当于后面介绍的<code>zincrby</code></li></ul><h4 id="zcard-计算成员个数"><a href="#zcard-计算成员个数" class="headerlink" title="zcard 计算成员个数"></a>zcard 计算成员个数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/9eb0d86663fd45e6a3032c05c1870339.png" alt="image.png"></p><h4 id="zscore-计算某个成员的分数"><a href="#zscore-计算某个成员的分数" class="headerlink" title="zscore 计算某个成员的分数"></a>zscore 计算某个成员的分数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7da7b741030b4b2b9863d569198f001d.png" alt="image.png"></p><p>如果成员不存在则返回nil</p><h4 id="zrank计算成员的排名"><a href="#zrank计算成员的排名" class="headerlink" title="zrank计算成员的排名"></a>zrank计算成员的排名</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/7395eb62a4fa4e669cf201799aca069e.png" alt="image.png"></p><p>zrank是从分数从低到高返回排名</p><p><code>zrevrank</code>反之很明显，排名从0开始计算。</p><h4 id="zrem-删除成员"><a href="#zrem-删除成员" class="headerlink" title="zrem 删除成员"></a>zrem 删除成员</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d4e23637dda8461abba76c303cfbfbad.png" alt="image.png"></p><p>允许一次删除多个成员。</p><p>返回结果为成功删除的个数。</p><h4 id="zincrby-增加成员的分数"><a href="#zincrby-增加成员的分数" class="headerlink" title="zincrby 增加成员的分数"></a>zincrby 增加成员的分数</h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/b1a0193040334a0f90ddb66bce53fe0c.png" alt="image.png"></p><h4 id="zrange和zrevrange返回指定排名范围的成员"><a href="#zrange和zrevrange返回指定排名范围的成员" class="headerlink" title="zrange和zrevrange返回指定排名范围的成员"></a>zrange和zrevrange返回指定排名范围的成员</h4><p>有序集合是按照分值排名的，zrange是从低到高返回,zrevrange反之。如果加上<br>withscores选项，同时会返回成员的分数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/d2a8d64fce484b64bf95f0a886fa1f45.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/a17fc90c48dd498f9539f5b834ada3bb.png" alt="image.png"></p><h4 id="zrangebyscore返回指定分数范围的成员"><a href="#zrangebyscore返回指定分数范围的成员" class="headerlink" title="zrangebyscore返回指定分数范围的成员"></a>zrangebyscore返回指定分数范围的成员</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key <span class="built_in">min</span> <span class="built_in">max</span> [withscores] [limit <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br><span class="line">zrevrangebyscore key <span class="built_in">max</span> <span class="built_in">min</span> [withscores][limit <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><p>其中<code>zrangebyscore</code>按照分数从低到高返回，<code>zrevrangebyscore</code>反之。例如下面操作从低到高返回200到221分的成员，<code>withscores</code>选项会同时返回每个成员的分数。</p><p>同时<code>min</code>和<code>max</code>还支持开区间(小括号）和闭区间(中括号)，-inf和+inf分别代表无限小和无限大:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/de92b2a82134468ab69bbb8718ccfd1f.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/92edbaef3b2c4c4c9a7ee0daac41ad0a.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/e5dc53cdbff941c9814590973ac96499.png" alt="image.png"></p><h4 id="zcount-返回指定分数范围成员个数"><a href="#zcount-返回指定分数范围成员个数" class="headerlink" title="zcount 返回指定分数范围成员个数"></a>zcount 返回指定分数范围成员个数</h4><p>zcount key min max</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/82a1a39c69bf4c8395411312fd276515.png" alt="image.png"></p><h4 id="zremrangebyrank-按升序删除指定排名内的元素"><a href="#zremrangebyrank-按升序删除指定排名内的元素" class="headerlink" title="zremrangebyrank 按升序删除指定排名内的元素"></a>zremrangebyrank 按升序删除指定排名内的元素</h4><p>zremrangebyrank key start end</p><h4 id="zremrangebyscore-删除指定分数范围的成员"><a href="#zremrangebyscore-删除指定分数范围的成员" class="headerlink" title="zremrangebyscore 删除指定分数范围的成员"></a>zremrangebyscore 删除指定分数范围的成员</h4><p>zremrangebyscore key min max</p><h3 id="集合间操作命令-1"><a href="#集合间操作命令-1" class="headerlink" title="集合间操作命令"></a>集合间操作命令</h3><h4 id="zinterstore-交集"><a href="#zinterstore-交集" class="headerlink" title="zinterstore 交集"></a>zinterstore 交集</h4><p><code>zinterstore</code><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/0e0688f60b404126895ffbbf4c6ae290.png" alt="image.png"></p><p>这个命令参数较多，下面分别进行说明</p><ul><li>destination:交集计算结果保存到这个键。</li></ul><ul><li>numkeys:需要做交集计算键的个数。</li></ul><ul><li>key [key …]:需要做交集计算的键。</li></ul><ul><li><p>weights weight</p></li><li><p>[weight …]:每个键的权重，在做交集计算时，每个键中的每个member 会将自己分数乘以这个权重,每个键的权重默认是1。</p></li><li><p>aggregate sum | min |max:计算成员交集后，分值可以按照sum(和)、min(最小值)、max(最大值)做汇总,默认值是sum。</p></li></ul><p>不太好理解，我们用一个例子来说明。（算平均分）</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/cfc3967b70cb4dcea41057c3708d8616.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1663252342001/65f2bee807e1446989277c0fadff86cf.png" alt="image.png"></p><h4 id="zunionstore-并集"><a href="#zunionstore-并集" class="headerlink" title="zunionstore 并集"></a>zunionstore 并集</h4><p>该命令的所有参数和zinterstore是一致的，只不过是做并集计算，大家可以自行实验。</p><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的:按照时间、按照播放数量、按照获得的赞数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis常用数据结构&quot;&gt;&lt;a href=&quot;#Redis常用数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis常用数据结构&quot;&gt;&lt;/a&gt;Redis常用数据结构&lt;/h1&gt;&lt;p&gt;Redis提供了一些数据结构供我们往Redis中存取数据，最常用的的</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://eizo01.github.io/posts/6a343b7f.html"/>
    <id>https://eizo01.github.io/posts/6a343b7f.html</id>
    <published>2022-11-01T12:00:00.000Z</published>
    <updated>2022-11-12T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的技术全景"><a href="#Redis的技术全景" class="headerlink" title="Redis的技术全景"></a>Redis的技术全景</h2><p>本质上就是，Redis 的知识都包括什么呢？简单来说，就是“两大维度，三大主线”</p><p><img src="https://zdwtop.cn/blog/ba2269e45c1b4a77bf097ff40de3aa8e.png" alt="image.png"></p><h3 id="两大维度"><a href="#两大维度" class="headerlink" title="两大维度"></a>两大维度</h3><p>两大维度：<strong>应用维度、底层原理维度</strong></p><p>我们知道，缓存和集群是Redis 的两大广泛的应用场景。同时Redis 丰富的数据模型，就导致它有很多零碎的应用场景，很多很杂。而且，还有一些问题隐藏得比较深，只有特定的业务场景下（比如亿级访问压力场景）才会出现，所以同时还必须精通Redis的数据结构。</p><h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a><strong>Redis应用场景</strong></h3><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h4><p>缓存机制几乎在所有的大型网站都有使用，合理地使用缓存不仅可以加快数据的访问速度，而且能够有效地降低后端数据源的压力。Redis提供了键值过期时间设置,并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。可以这么说,一个合理的缓存设计能够为一个网站的稳定保驾护航。</p><p>一般MySQL数据库写的并发是600/s，读的2000/s,对于大型互联网项目的百万并发，根本扛不住，Redis的官方显示Redis能够单台达到10W+/s的并发。</p><h4 id="2-排行榜系统"><a href="#2-排行榜系统" class="headerlink" title="2.排行榜系统"></a>2.排行榜系统</h4><p>排行榜系统几乎存在于所有的网站，例如按照热度排名的排行榜，按照发布时间的排行榜，按照各种复杂维度计算出的排行榜，Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p><h4 id="3-计数器应用"><a href="#3-计数器应用" class="headerlink" title="3.计数器应用"></a>3.计数器应用</h4><p>计数器在网站中的作用至关重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据的实时性，每一次播放和浏览都要做加1的操作，如果并发量很大对于传统关系型数据的性能是一种挑战。Redis天然支持计数功能而且计数的性能也非常好,可以说是计数器系统的重要选择。</p><h4 id="4-社交网络"><a href="#4-社交网络" class="headerlink" title="4.社交网络"></a>4.社交网络</h4><p>赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大,而且传统的关系型数据不太适合保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能。</p><h4 id="5-消息队列系统"><a href="#5-消息队列系统" class="headerlink" title="5.消息队列系统"></a>5.消息队列系统</h4><p>消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列的功能，虽然和专业的消息队列比还不够足够强大,但是对于一般的消息队列功能基本可以满足。这个是Redis的作者参考了Kafka做的拓展。</p><h3 id="三大主线"><a href="#三大主线" class="headerlink" title="三大主线"></a>三大主线</h3><p>三大主线：高性能、高可靠和高可扩展</p><p>高性能：包括线程模型、数据结构、持久化、网络框架；<br>高可靠：包括主从复制、哨兵机制；<br>高可扩：包括数据分片、负载均衡。</p><p>因为Redis的应用场景非常多，不同的公司有不同的玩法，但如何不掌握三高这条主线的话，你会遇到以下问题：</p><p>1、数据结构的复杂度、跨 CPU 核的访问会导致CPU飙升的问题</p><p>2、主从同步和 AOF 的内存竞争，这些会导致内存问题</p><p>3、在 SSD 上做快照的性能抖动，这些会导致存储持久化的问题</p><p>4、多实例时的异常网络丢包的问题</p><h2 id="Redis全局命令"><a href="#Redis全局命令" class="headerlink" title="Redis全局命令"></a>Redis全局命令</h2><p>对于键值数据库而言，基本的数据模型是 key-value 模型，Redis 支持的 value 类型包括了 String、哈希表、列表、集合等，而Memcached支持的 value 类型仅为 String 类型。</p><p>Redis里面有16个库，但是Redis的分库功能没啥意义（默认就是0号库，尤其是集群操作的时候），我们一般都是默认使用0号库进行操作。</p><p>在了解Rediskey-value 模型之前，Redis的有一些全局命令，需要我们提前了解。</p><h4 id="keys命令"><a href="#keys命令" class="headerlink" title="keys命令"></a><strong>keys命令</strong></h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">keys</span> *</span><br><span class="line"><span class="built_in">keys</span> L*</span><br></pre></td></tr></table></figure><p>查看所有键(支持通配符)：</p><p><img src="HTTPs://zdwtop.cn/blog/a38baeb051bd46dab430d3037bedc48b.png" alt="image.png"></p><p>但是这个命令请慎用，因为keys命令要把所有的key-value对全部拉出去，如果生产环境的键值对特别多的话，会对Redis的性能有很大的影响，推荐使用<code>dbsize</code>。</p><p><strong>keys命令会遍历所有键，所以它的时间复杂度是o(n)，当Redis保存了大量键时线上环境禁止使用keys命令。</strong></p><h4 id="dbsize命令"><a href="#dbsize命令" class="headerlink" title="dbsize命令"></a><strong>dbsize命令</strong></h4><p>dbsize命令会返回当前数据库中键的总数。</p><p><img src="HTTPs://zdwtop.cn/blog/21ed59cad4e84610869308640d57718c.png" alt="image.png"></p><p>dbsize命令在计算键总数时不会遍历所有键,而是直接获取 Redis内置的键总数变量,所以dbsize命令的时间复杂度是<strong>O(1)</strong>。</p><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a><strong>exists</strong></h4><p>检查键是否存在，存在返回1，不存在返回0。</p><p><img src="HTTPs://zdwtop.cn/blog/706705c0c9d7418b8b72eb0be7228f85.png" alt="image.png"></p><h4 id="del"><a href="#del" class="headerlink" title="del"></a><strong>del</strong></h4><p>删除键，无论值是什么数据结构类型,del命令都可以将其删除。<strong>返回删除键个数，删除不存在键返回0。</strong>同时del命令可以支持删除多个键。</p><p><img src="HTTPs://zdwtop.cn/blog/2865421882494708bb0f78fd458a3a59.png" alt="image.png"></p><p><img src="HTTPs://zdwtop.cn/blog/5d304a87b9d44633893581107f0d310a.png" alt="image.png"></p><h4 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a><strong>键过期</strong></h4><h5 id="expire"><a href="#expire" class="headerlink" title="expire"></a><strong>expire</strong></h5><p>Redis支持对键添加过期时间,当超过过期时间后,会自动删除键，时间单位秒。</p><p>ttl命令会返回键的剩余过期时间,它有3种返回值:</p><p>大于等于0的整数:键剩余的过期时间。</p><p>-1:键没设置过期时间。</p><p>-2:键不存在</p><p>除了expire、ttl命令以外，Redis还提供了expireat、pexpire,pexpireat、pttl、persist等一系列命令。</p><h5 id="expireat-key"><a href="#expireat-key" class="headerlink" title="expireat key"></a><strong>expireat key</strong></h5><p>timestamp: 键在秒级时间截timestamp后过期。</p><p>ttl命令和pttl都可以查询键的剩余过期时间，但是pttl精度更高可以达到毫秒级别，有3种返回值:</p><p>大于等于0的整数:键剩余的过期时间(ttl是秒，pttl是毫秒)。</p><p>-1:键没有设置过期时间。</p><p>-2:键不存在。</p><h5 id="pexpire-key"><a href="#pexpire-key" class="headerlink" title="pexpire key"></a><strong>pexpire key</strong></h5><p>milliseconds:键在milliseconds毫秒后过期。</p><h5 id="pexpireat-key"><a href="#pexpireat-key" class="headerlink" title="pexpireat key"></a><strong>pexpireat key</strong></h5><p>milliseconds-timestamp键在毫秒级时间戳timestamp后过期。</p><p><strong>在使用Redis相关过期命令时,需要注意以下几点。</strong></p><p>1)如果expire key 的键不存在,返回结果为0:</p><p>2）如果过期时间为负值,键会立即被删除，犹如使用del命令一样:</p><p>3 ) persist命令可以将键的过期时间清除:</p><p><img src="HTTPs://zdwtop.cn/blog/e288cca51dd446a19384a29adcc1faf7.png" alt="image.png"></p><p>4）对于字符串类型键，执行set命令会去掉过期时间，这个问题很容易在开发中被忽视。</p><p><img src="HTTPs://zdwtop.cn/blog/5b749a4fd43248ce9af261080058ebaf.png" alt="image.png"></p><p>5 ) Redis不支持二级数据结构(例如哈希、列表)内部元素的过期功能，不能对二级数据结构做过期时间设置。</p><h5 id="type"><a href="#type" class="headerlink" title="type"></a><strong>type</strong></h5><p>返回键的数据结构类型，例如<strong>键lijin是字符串类型，返回结果为string。键mylist是列表类型，返回结果为list，键不存在返回none</strong></p><p><img src="HTTPs://zdwtop.cn/blog/a5cf8aefd7b2414b9e1fb6ad96f24b47.png" alt="image.png"></p><h5 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a><strong>randomkey</strong></h5><p>随机返回一个键，这个很简单，请自行实验。</p><p><img src="HTTPs://zdwtop.cn/blog/41c50a66594e42f98755f4ca70814050.png" alt="image.png"></p><p><strong>rename</strong></p><p>键重命名</p><p>但是要注意，如果在rename之前,新键已经存在，那么它的值也将被覆盖。</p><p><img src="HTTPs://zdwtop.cn/blog/ec04e5381693497b9d85040317c25d74.png" alt="image.png"></p><p>为了防止被强行rename，Redis提供了renamenx命令，确保只有newKey不存在时候才被覆盖。</p><p><img src="HTTPs://zdwtop.cn/blog/41644a5ba52048e9a4b2d8b130d211a0.png" alt="image.png"></p><p>从上面我们可以看出，由于重命名键期间会执行del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能性。</p><h3 id="键名的生产实践"><a href="#键名的生产实践" class="headerlink" title="键名的生产实践"></a>键名的生产实践</h3><p>Redis没有命令空间，而且也没有对键名有强制要求。但设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用<strong>“业务名:对象名: id : [属性]”作为键名</strong>   (也可以不是分号)。</p><p>例如MySQL 的数据库名为mall，用户表名为order，那么对应的键可以用”mall:order:1”,<br>“mall:order:1:name”来表示，如果当前Redis 只被一个业务使用，甚至可以去掉“order:”。</p><p><img src="HTTPs://zdwtop.cn/blog/46d96dd72a2943ceba09f109f563c243.png" alt="image.png"></p><p>在能描述键含义的前提下适当减少键的长度，从而减少由于键过长的内存浪费。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>推荐docker安装，如果喜欢window操作可以下载GitHub的人开发的exe程序，不过版本一般比较老</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的技术全景&quot;&gt;&lt;a href=&quot;#Redis的技术全景&quot; class=&quot;headerlink&quot; title=&quot;Redis的技术全景&quot;&gt;&lt;/a&gt;Redis的技术全景&lt;/h2&gt;&lt;p&gt;本质上就是，Redis 的知识都包括什么呢？简单来说，就是“两大维度，三大主</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>连接的原理</title>
    <link href="https://eizo01.github.io/posts/a1120601.html"/>
    <id>https://eizo01.github.io/posts/a1120601.html</id>
    <published>2022-10-30T12:00:00.000Z</published>
    <updated>2023-03-25T10:11:16.218Z</updated>
    
    <content type="html"><![CDATA[<h1>两个表的亲密接触-连接的原理</h1><p>我们先创建两个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (m1 <span class="type">int</span>, n1 <span class="type">char</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (m2 <span class="type">int</span>, n2 <span class="type">char</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure><p>连接 的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把 t1 和 t2 两个表连接起来的过程如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320161856926.png" alt="image-20230320161856926"></p><p>这个过程看起来就是把 t1 表的记录和 t2 的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查 询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果 集就可以称之为 笛卡尔积 。</p><h2 id="连接过程简介">连接过程简介</h2><p>我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的 笛卡尔 积 可能是非常巨大的。比方说3个100行记录的表连接起来产生的 笛卡尔积 就有 100×100×100=1000000 行数 据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p><ul><li><p>涉及单表的条件</p></li><li><p>这种只设计单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为 搜索条件 ，比如 t1.m1 &gt; 1 是只针对 t1 表的过滤条件， t2.n2 &lt; ‘d’ 是只针对 t2 表的过滤条件。</p></li><li><p>涉及两表的条件</p><ul><li>这种过滤条件我们之前没见过，比如 t1.m1 = t2.m2 、 t1.n1 &gt; t2.n2 等，这些条件中涉及到了两个表，比方说下边这个查询语句：</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">AND</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.m1 <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">t1.m1 <span class="operator">=</span> t2.m2</span><br><span class="line">t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>首先确定第一个需要查询的表，这个表称之为 驱动表 。</li></ol><p>此处假设使用 t1 作为驱动表，那么就需 要到 t1 表中找满足 t1.m1 &gt; 1 的记录，因为表中的数据太少，我们也没在表上建立二级索引。我们肯定得全表查询</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320162234271.png" alt="image-20230320162234271"></p><p>我们可以看到， t1 表中符合 t1.m1 &gt; 1 的记录有两条。</p><ol start="2"><li>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录，所谓 匹配的 记录 ，指的是符合过滤条件的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被 称之为 被驱动表 。<ul><li>当 t1.m1 = 2 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 2 ，所以此时 t2 表相当于有了 t2.m2 = 2 、 t2.n2 &lt; ‘d’ 这两个过滤条件，然后到 t2 表中执行单表查询。</li><li>当 t1.m1 = 3 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 3 ，所以此时 t2 表相当于有了 t2.m2 = 3 、 t2.n2 &lt; ‘d’ 这两个过滤条件，然后到 t2 表中执行单表查询。</li></ul></li></ol><p>所以整个连接查询的执行过程就如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320162516886.png" alt="image-20230320162516886"></p><p>所以最后得查询结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1n1m2n2</span><br><span class="line"><span class="number">2</span>b<span class="number">2</span>b</span><br><span class="line"><span class="number">3</span>c<span class="number">3</span>c</span><br></pre></td></tr></table></figure><p>可以从这个例子中看出，我们t1只被访问一次，t2可以能被访问多次。也就是说在<strong>两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</strong></p><h3 id="内连接和外连接">内连接和外连接</h3><p>创建两个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"> number <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line"> name <span class="type">VARCHAR</span>(<span class="number">5</span>) COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line"> major <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;学生信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> score (</span><br><span class="line"> number <span class="type">INT</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line"> subject <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;科目&#x27;</span>,</span><br><span class="line"> score TINYINT COMMENT <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (number, score)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;学生成绩表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>添加数据如下图：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320163711859.png" alt="image-20230320163711859"></p><p>现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student, score <span class="keyword">WHERE</span> student.number <span class="operator">=</span> score.number;</span><br></pre></td></tr></table></figure><p><img src="HTTPs://zdwtop.cn/blog/image-20230320163355527.png" alt="image-20230320163355527"></p><p>但发现一个问题，史珍香同学也就是学号为 20220103 的同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。在成绩统计时史珍香即使没有成绩也要出现在表中。我们介绍的 连接查询 是无法 完成这样的需求的。我们稍微思考一下这个需求，其本质是想：<strong>驱动表中的记录即使在被驱动表中没有匹配的记 录，也仍然需要加入到结果集。</strong></p><p>为了解决这个问题，就有了 内连接 和 外连接 的概念：</p><p>对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。</p><p>对于 外连接 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p><p>在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p><ul><li>左外连接 选取左侧的表为驱动表。</li><li>右外连接 选取右侧的表为驱动表。</li></ul><p>注意：</p><p>WHERE 子句中的过滤条件不论是内连接还是外连接，凡是不符合 WHERE 子句中的过滤条件的记录都不会被加入最后的结果集。</p><p>ON 子句中的过滤条件对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记 录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充。</p><p>这个 ON 子句是专门**为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记 录加入结果集这个场景下提出的，**所以如果把 ON 子句放到内连接中， MySQL 会把它和 WHERE 子句一样对 待，也就是说：<strong>内连接中的WHERE子句和ON子句是等价的。</strong></p><p><font color="red"><strong>一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中，我们也一般把放到 ON 子句中的过滤条件也称之为 连接条件 。</strong></font></p><p>连接语法这里就不多讲了。</p><h2 id="连接的原理">连接的原理</h2><h3 id="嵌套循环连接（Nested-Loop-Join）">嵌套循环连接（Nested-Loop Join）</h3><p>对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取 决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连 接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</p><p>通用的两表连接过程如下图所示：</p><img src="HTTPs://zdwtop.cn/blog/image-20230320165448593.png" alt="image-20230320165448593" style="zoom:150%;"><p>如果有3个表进行连接的话，那么 步骤2 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表， 重复上边过程，也就是 步骤2 中得到的结果集中的每一条记录都需要到 t3 表中找一找有没有匹配的记录，用伪 代码表示一下这个过程就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row in t1 &#123; #此处表示遍历满足对t1单表查询结果集中的每一条记录</span><br><span class="line"> <span class="keyword">for</span> each row in t2 &#123; #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span><br><span class="line"> <span class="keyword">for</span> each row in t3 &#123; #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span><br><span class="line"> <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个过程就像是一个嵌套的循环，所以这种<font color="red"><strong>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于 对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接</strong> </font>， 这是最简单一种连接查询算法。</p><h3 id="使用索引加快连接速度">使用索引加快连接速度</h3><p>上面我们可以知道查询 t2 表其实就相当于一次单表扫描，我们可以利用索引 来加快查询速度哦。回顾一下最开始介绍的 t1 表和 t2 表进行内连接的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">AND</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查询驱动表 t1 后的结果集中有两条记录， 嵌套循环连接 算法需要对被驱动表查询2次：</p><ul><li>当 t1.m1 = 2 时，去查询一遍 t2 表，对 t2 表的查询语句相当于：<ul><li>SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; ‘d’;</li></ul></li><li>当 t1.m1 = 3 时，再去查询一遍 t2 表，此时对 t2 表的查询语句相当于：<ul><li>SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; ‘d’;</li></ul></li></ul><p>可以看到，原来的 t1.m1 = t2.m2 这个涉及两个表的过滤条件在针对 t2 表做查询时关于 t1 表的条件就已经确 定了，所以我们只需要单单优化对 t2 表的查询了，上述两个对 t2 表的查询语句中利用到的列是 m2 和 n2 列， 我们可以：</p><ul><li>在 m2 列上建立索引，因为对 m2 列的条件是等值查找，所以可能使用到 ref 的访问方法，假设使用 ref 的访问方法去执行对 t2 表的查询的话，需要回表之后再判断 t2.n2 &lt; d 这 个条件是否成立。</li></ul><blockquote><p>假设 m2 列是 t2 表的主键或者唯一二级索引列，那么使用 t2.m2 = 常数 值 这样的条件从 t2 表中查找记录的过程的代价就是常数级别的。</p><p>把在连接查询中对被驱动表使用主键 值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref 。</p></blockquote><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）">基于块的嵌套循环连接（Block Nested-Loop Join）</h3><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。那么当表中数据一多的时候，内存不可能存的到那么多数据，所以就要淘汰前面的数据。我们前边又说过，采用 嵌 套循环连接 算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不 能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大了，所以我们得想办法： <strong>尽量减少访问被驱动表的次数。</strong></p><p>我们在把被驱动表的记录加载到内存的时候，可不可以一次性和多条驱动表中 的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。</p><p>所以MySQL 里面有个join buffer 的概念， **join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集 中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的 多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。**使 用 join buffer 的过程如下图所示：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230320170527848.png" alt="image-20230320170527848"></p><p>最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完 成连接操作了。</p><p>这种加入了 join buffer 的嵌套循环连接算法称之为 基于块的嵌套连接 （Block Nested-Loop Join）算法。</p><p>这个 join buffer 的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为 262144字 节 （也就是 256KB ），最小可以设置为 128字节 。</p><p>驱动表的记录并不是所有列都会被放到<code> join buffe</code>r 中，只有查询列表中的列和过滤条件中 的列才会被放到 join buffer 中，所以再次提醒我们，<strong>最好不要把 * 作为查询列表</strong>，只需要把我们关心的列放到 查询列表就好了，这样还可以在 join buffer 中放置更多的记录呢哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;两个表的亲密接触-连接的原理&lt;/h1&gt;
&lt;p&gt;我们先创建两个表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="innodb" scheme="https://eizo01.github.io/tags/innodb/"/>
    
    <category term="连接" scheme="https://eizo01.github.io/tags/%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="https://eizo01.github.io/posts/484a2385.html"/>
    <id>https://eizo01.github.io/posts/484a2385.html</id>
    <published>2022-10-20T12:00:00.000Z</published>
    <updated>2023-03-16T15:22:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>MySQL中的锁</strong></h1><p>InnoDB中锁非常多，总的来说，可以如下分类：</p><p><img src="https://zdwtop.cn/blog/image-20230316215836060.png" alt></p><p>这些锁都是做什么的？</p><p>我们已经知道事务并发执行时可能带来的各种问题，最大的一个难点是：一方面要最大程度地利用数据库的并发访问，另外一方面还要确保每个用户能以一致的方式读取和修改数据，尤其是一个事务进行读取操作，另一个同时进行改动操作的情况下。</p><h2 id="1-锁并发事务问题">**1.**锁并发事务问题</h2><p>一个事务进行读取操作，另一个进行改动操作,我们前边说过，这种情况下可能发生脏读、不可重复读、幻读的问题。</p><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p><h3 id="1-1-方案一：读操作MVCC，写操作进行加锁"><strong>1.1.方案一：读操作MVCC，写操作进行加锁</strong></h3><p><strong>事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，也称之为快照读</strong>，但是往往读取的是历史版本数据。所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别（RC,RR）下都算是一致性读。</p><p>一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。</p><p>很明显，采用MVCC方式的话，<strong>读-写操作彼此并不冲突，性能更高</strong>，<strong>采用加锁方式的话，读-写操作彼此需要排队执行，影响性能</strong>。一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些情况下，要求必须采用加锁的方式执行。</p><h3 id="1-2方案二：读、写操作都采用加锁的方式"><strong>1.2方案二：读、写操作都采用加锁的方式</strong></h3><p><strong>适用场景：</strong></p><p>业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，</p><p>比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p><p><strong>脏读</strong>的产生是 因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><strong>幻读问题</strong>的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加锁的方式解决幻读问题就有不太容易了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点麻烦—— 因为并不知道给谁加锁。</p><h2 id="2-锁定读（LockingReads）-LBCC"><strong>2.锁定读（LockingReads）/LBCC</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">for</span>  <span class="keyword">update</span>   <span class="comment">-- 锁定读 属于x锁</span></span><br></pre></td></tr></table></figure><p>也称当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>   lock <span class="keyword">in</span> share mode <span class="comment">-- (共享锁) S锁</span></span><br></pre></td></tr></table></figure><p>哪些是当前读呢？</p><p><strong>select lock in share mode (共享锁)、select for update (排他锁)、读操作</strong></p><p><strong>update (排他锁)、insert (排他锁/独占锁)、delete (排他锁)、写操作</strong></p><p><strong>串行化事务隔离级别</strong>都是当前读。</p><h3 id="2-1-共享锁和独占锁"><strong>2.1. 共享锁和独占锁</strong></h3><p>在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，MySQL中的锁有好几类：</p><p><strong>共享锁</strong>英文名：Shared Locks，<strong>简称S锁</strong>。在事务要读取一条记录时，需要先获取该记录的S锁。</p><p>假如事务E1首先获取了一条记录的S锁之后，事务E2接着也要访问这条记录：</p><p>如果事务E2想要再获取一个记录的S锁，那么事务E2也会获得该锁，也就意味着事务E1和E2在该记录上同时持有S锁。</p><p><strong>独占锁，<strong>也常称</strong>排他锁</strong>，英文名：Exclusive Locks，<strong>简称X锁</strong>。</p><p>在 事务要改动一条记录时，E1需要先获取该记录的X锁。</p><p>如果事务E2想要再获取一个记录的X锁，那么此操作会被阻塞，直到事务E1提交之后将S锁释放掉。</p><p>如果事务E1首先获取了一条记录的X锁之后，那么不管事务E2接着想获取该记录的S锁还是X锁都会被阻塞，直到事务E1提交。</p><p>所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的，表示一下就是这样：</p><table><thead><tr><th><strong>X</strong></th><th><strong>不兼容S</strong></th><th><strong>不兼容X</strong></th></tr></thead><tbody><tr><td><strong>S</strong></td><td><strong>兼容S</strong></td><td><strong>不兼容X</strong></td></tr></tbody></table><h3 id="2-2-锁定读的SELECT语句"><strong>2.2.锁定读的SELECT语句</strong></h3><p>MySQ有两种比较特殊的SELECT语句格式：</p><h4 id="对读取的记录加S锁：">对读取的记录加S锁：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>一个事务中开启S锁</p><p><img src="https://zdwtop.cn/blog/image-20230316224750706.png" alt="image-20230316224750706"></p><p>也就是在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT … LOCK IN SHARE MODE语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。</p><p>如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的S锁释放掉。</p><h4 id="对读取的记录加X锁：">对读取的记录加X锁：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><img src="https://zdwtop.cn/blog/image-20230316225958920.png" alt="image-20230316225958920" style="zoom: 80%;"><p>如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p><h3 id="2-3-写操作的锁"><strong>2.3. 写操作的锁</strong></h3><p>平常所用到的写操作无非是DELETE、UPDATE、INSERT这三种：</p><h5 id="DELETE："><strong>DELETE：</strong></h5><p>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取一下这条记录的X排他锁定读，然后再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p><h5 id="INSERT："><strong>INSERT：</strong></h5><p>一般情况下，新插入一条记录的操作并不加锁，InnoDB通过一种称之为隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问。当然，在一些特殊情况下INSERT操作也是会获取锁的，具体情况我们后边再说。</p><h5 id="UPDATE："><strong>UPDATE：</strong></h5><p>在对一条记录做UPDATE操作时分为三种情况：</p><ol><li><p>如果未修改该记录的键值并且被更新的列占用的存储空间在<strong>修改前后未发生变化</strong>，则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在B+树 中位置的过程看成是一个<strong>获取X锁的锁定读</strong>。</p></li><li><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在<strong>修改前后发生变化</strong>，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个<strong>获取X锁的锁定读</strong>，新插入的记录由INSERT操作提供的<strong>隐式锁进行保护</strong>。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。</p></li></ol><h2 id="3-锁的粒度"><strong>3.锁的粒度</strong></h2><p>我们前边提到的锁都是针对记录的，也可以被称之为行级锁或者行锁，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）</p><h3 id="3-1-表锁与行锁的比较"><strong>3.1.表锁与行锁的比较</strong></h3><p><strong>锁定粒度：表锁 &gt; 行锁</strong></p><p><strong>加锁效率：表锁 &gt; 行锁</strong></p><p><strong>冲突概率：表锁 &gt; 行锁</strong></p><p><strong>并发性能：表锁 &lt; 行锁</strong></p><h3 id="3-2-给表加S锁"><strong>3.2.给表加S锁</strong></h3><p><strong>如果一个事务给表加了S锁，那么：</strong></p><p>别的事务可以继续获得该表的S锁</p><p>别的事务可以继续获得该表中的某些记录的S锁</p><p>别的事务<strong>不可以继续获得该表的X锁</strong></p><p>别的事务<strong>不可以继续获得该表中的某些记录的X锁</strong></p><h3 id="3-3-给表加X锁"><strong>3.3.给表加X锁</strong></h3><p><strong>如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</strong></p><p>别的事务<strong>不可以</strong>继续获得该表的S锁</p><p>别的事务<strong>不可以</strong>继续获得该表中的某些记录的S锁</p><p>别的事务<strong>不可以</strong>继续获得该表的X锁</p><p>别的事务<strong>不可以</strong>继续获得该表中的某些记录的X锁。</p><p>为了更好的理解这个表级别的S锁和X锁和后面的意向锁，我们举一个现实生活中的例子。我们用曾经很火爆的互联网风口项目共享Office来说明加锁：</p><p>共享Office有栋大楼，楼自然有很多层。办公室都是共享的，客户可以随便选办公室办公。每层楼可以容纳客户同时办公，每当一个客户进去办公，就相当于在每层的入口处挂了一把S锁，如果很多客户进去办公，相当于每层的入口处挂了很多把S锁（类似行级别的S锁）。</p><p>有的时候楼层会进行检修，比方说换地板，换天花板，检查水电啥的，这些维修项目并不能同时开展。如果楼层针对某个项目进行检修，就不允许客户来办公，也不允许其他维修项目进行，此时相当于楼层门口会挂一把X锁（类似行级别的X锁）。</p><p>上边提到的这两种锁都是针对楼层而言的，不过有时候我们会有一些特殊的需求：</p><p><img src="https://zdwtop.cn/blog/image-20230316230243710.png" alt="image-20230316230243710"></p><p>A、有投资人要来考察Office的环境。</p><p>投资人和公司并不想影响客户进去办公，但是此时不能有楼层进行检修，所以可以在大楼门口放置一把S锁（类似表级别的S锁）。此时：</p><p>来办公的客户们看到大楼门口有S锁，可以继续进入大楼办公。</p><p>修理工看到大楼门口有S锁，则先在大楼门口等着，啥时候投资人走了，把大楼的S锁撤掉再进入大楼维修。</p><p>B、公司要和房东谈条件。</p><p>此时不允许大楼中有正在办公的楼层，也不允许对楼层进行维修。所以可以在大楼门口放置一把X锁（类似表级别的X锁）。此时：</p><p>来办公的客户们看到大楼门口有X锁，则需要在大楼门口等着，啥时候条件谈好，把大楼的X锁撤掉再进入大楼办公。</p><p>修理工看到大楼门口有X锁，则先在大楼门口等着，啥时候谈判结束，把大楼的X锁撤掉再进入大楼维修。</p><h2 id="4-意向锁"><strong>4.意向锁</strong></h2><p>但是在上面的例子这里头有两个问题：</p><p>如果我们想对大楼整体上S锁，首先需要确保大楼中的没有正在维修的楼层，如果有正在维修的楼层，需要等到维修结束才可以对大楼整体上S锁。</p><p>如果我们想对大楼整体上X锁，首先需要确保大楼中的没有办公的楼层以及正在维修的楼层，如果有办公的楼层或者正在维修的楼层，需要等到全部办公的同学都办公离开，以及维修工维修完楼层离开后才可以对大楼整体上X锁。</p><p>我们在对大楼整体上锁（表锁）时，怎么知道大楼中有没有楼层已经被上锁（行锁）了呢？</p><p>依次检查每一楼层门口有没有上锁？那这效率也太慢了吧！</p><p>于是InnoDB提出了一种<strong>意向锁</strong>（英文名：Intention Locks）：</p><p><strong>意向共享锁</strong> ，英文名：Intention Shared Lock，<strong>简称IS锁</strong>。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。</p><p><strong>意向独占锁</strong> ，英文名：Intention Exclusive Lock，<strong>简称IX锁</strong>。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</p><p>视角回到大楼和楼层上来：</p><p>​    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAQAAAH7CAYAAABbm02EAAAAAXNSR0IArs4c6QAAIABJREFUeF7s3Qn8VmP+//FPRTLSaimjSFFomSZMRMoakzI1k0IjPylKZUuUSisJbdZkRIMwWSoU2UWUJZUKiTBla1OIqf6PzzX/657zPZ37vs99f+/lLK/zePQwvt+zXNfzOv1+rve5ljI7d+7cKRwIIIAAAggggAACCCCAAAIIIBArgTIEArFqbyqLAAIIIIAAAggggAACCCCAgBEgEOBFQAABBBBAAAEEEEAAAQQQQCCGAgQCMWx0qowAAggggAACCCCAAAIIIIAAgQDvAAIIIIAAAggggAACCCCAAAIxFCAQiGGjU2UEEEAAAQQQQAABBBBAAAEECAR4BxBAAAEEEEAAAQQQQAABBBCIoQCBQAwbnSojgAACCCCAAAIIIIAAAgggQCDAO4AAAggggAACCCCAAAIIIIBADAUIBGLY6FQZAQQQQAABBBBAAAEEEEAAAQIB3gEEEEAAAQQQQAABBBBAAAEEYihAIBDDRqfKCCCAAAIIIIAAAggggAACCBAI8A4ggAACCCCAAAIIIIAAAgggEEMBAoEYNjpVRgABBBBAAAEEEEAAAQQQQIBAgHcAAQQQQAABBBBAAAEEEEAAgRgKEAjEsNGpMgIIIIAAAggggAACCCCAAAIEArwDCCCAAAIIIIAAAggggAACCMRQgEAgho1OlRFAAAEEEEAAAQQQQAABBBAgEOAdQAABBBBAAAEEEEAAAQQQQCCGAgQCMWx0qowAAggggAACCCCAAAIIIIAAgQDvAAIIIIAAAggggAACCCCAAAIxFCAQiGGjU2UEEEAAAQQQQAABBBBAAAEECAR4BxBAAAEEEEAAAQQQQAABBBCIoQCBQAwbnSojgAACCCCAAAIIIIAAAgggQCDAO4AAAggggAACCCCAAAIIIIBADAUIBGLY6FQZAQQQQAABBBBAAAEEEEAAAQIB3gEEEEAAAQQQQAABBBBAAAEEYihAIBDDRqfKCCCAAAIIIIAAAggggAACCBAI8A4ggAACCCCAAAIIIIAAAgggEEMBAoEYNjpVRgABBBBAAAEEEEAAAQQQQIBAgHcAAQQQQAABBBBAAAEEEEAAgRgKEAjEsNGpMgIIIIAAAggggAACCCCAAAIEArwDCCCAAAIIIIAAAggggAACCMRQgEAgho1OlRFAAIEoCGzdulWefvpp2bx5s/z+97+XNm3ayO67756Xqu3cuVN+++03KV++fMb3d5azUqVK0r59e9lrr73S3kefN2fOHPn666+lfv360rp1a89rPvjgA1mwYIFkcu+0Dy/FCb/++qvcfvvtouX6wx/+IJdddllWbqUoApcigAACCCCAgE8BAgGfUJyGAAIIIBAsgY0bN0q/fv1k6dKl0rlzZ7nyyiulXLlyWRVy06ZNMmTIEKlXr5507NhRDjjgAHOfHTt2yOLFi2Xq1Kny008/yU033STVq1fP6BnOcjZs2FAmTJggVapUSXuPX375RUaMGGFCgW7dukmfPn3MNVrWiRMnymmnnSbHHHOMzJw5U4YPHy723hpajBs3Tho0aCBnn3121ia2gBpMaKihhwYZ6UIXZ7k1pBk8eLBUqFAhZX0zfUZaPE5AAAEEEEAAAV8CBAK+mDgJAQQQQCBoAs6OtrPDnE05582bJ4MGDZL//Oc/5gv+tddea75qb9++3XS+//nPf5rb9u/fX8455xwpU6aM78c4y/mnP/1JxowZI3vvvXfa670CAQ0oZsyYIbfccov87ne/M+XU82wgcPPNN8v06dPlwQcflIMOOkhuu+02Ofjgg9M+K9kJGoJoeWfPni1t27aVAQMGmOe+++670qNHj6zvay+cPHmyNGvWzIQtI0eOlLlz58pZZ51l6pUuRCj1w7kBAggggAACCAiBAC8BAggggEDgBfQL9YoVK0yH3R5btmyRO+64Q7744gs5/fTTTUfe6zjssMOkatWqSev43XffmY6ujgTQzq4Od2/SpEni/NWrV5uv82vXrpWaNWuaL/x169b1beYMBPx+MdebJxshoCHFvffeK/fff790795dqlWrJqNHjzYjBPTftQOvh44uaNq0qe9yuk/UaRI6JUPvo+HC2LFjE/XOdSCgz161apUZ8aHtoeGMBgOZBC9ZV5QLEUAAAQQQiLEAgUCMG5+qI4AAAmERcHbKMy2z/QrtdZ12ru+66y7TudZDpwtcffXVJea8a8dYpwxoUKCHhg/XX3+9CQ/8HN9++61cfvnlsnLlSrPOQboh9DolQKcmfPXVV+aPrpGg0xRq1KhhRifoegk//vijLFu2TBo1aiQLFy6UadOmmU5779695ZtvvpFt27bJEUccYUYi6PoD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O+ww8/OPP/5YPvnkE/PnjTfekE2bNpmfayjQuXPnSPkQCESqOakMAukFCATSG3EGAggggAAChRYgECi0OM+Lo0Dfvn0TowLatm0r3bp1kzp16qSkWL16tUydOlVmz55tztPRAhMnTowMH4FAZJqSiiDgT4BAwJ8TZyGAAAIIIFBIAQKBQmrzrDgK3H///XL77bfLwQcfLJdccomceuqpGTG88MILcvfdd8vnn38ul112mVx44YUZXR/UkwkEgtoylAuBPAkcffTRsmPHDmHKQJ6AuS0CCCCAAAJZCNhAYOHChVK2LFP6siDkEgSSCsyaNUtuuOEGKVeunEyZMkUaN26cldaHH34o3bt3l+3bt5v7nXXWWVndJ0gXEQgEqTUoCwIFECAQKAAyj0AAAQQQQCBDAQKBDME4HQGfAqtWrZJOnTqZs4cOHSrt2rXzeaX3aTNnzpRhw4aZXz722GNSt27dUt2v2BcTCBS7BXg+AgUWIBAoMDiPQwABBBBAwIcAgYAPJE5BIAuBO++8U+677z4544wzZOTIkVncYddLrr/+ennuuefkoosukl69euXknsW6CYFAseR5LgJFEiAQKBI8j0UAAQQQQCCFAIEArwcC+RFo3769fPXVVzJq1Chp06ZNTh4yZ84cGTRokBx44IHy9NNP5+SexboJgUCx5HkuAkUSIBAoEjyPRQABBBBAgECAdwCBggosWrRIevbsKZUqVZKXX345p89u3bq1bN68We655x456qijcnrvQt6MQKCQ2jwLgQAIEAgEoBEoAgIIIIAAAi4BRgjwSiCQewG7mOBJJ50kY8eOzekD+vfvLy+99FLoFxckEMjpa8HNEAi+AIFA8NuIEiKAAAIIxE+AQCB+bU6N8y8wefJk8wX/ggsukL59++b0gRMnTpQHHnjAjEDo0aNHTu9dyJsRCBRSm2chEAABAoEANAJFQAABBBBAwCVAIMArgUDuBXRrQB0lMHjwYDn77LNz+oCnnnpKRowYYbYe1OeE9SAQCGvLUW4EshQgEMgSjssQQAABBBDIowCBQB5xuXVsBfTL/bvvvpuXef52fYJmzZqJjkQI60EgENaWo9wIZClAIJAlHJchgAACCCCQRwECgTzicuvYCjBCIH3TEwikN+IMBCIlQCAQqeakMggggAACEREgEIhIQ1KNQAmwhkD65iAQSG/EGQhE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" alt="0"></p><p>如果有客户到楼层中办公，那么他先在整栋大楼门口放一把IS锁（表级锁），然后再到楼层门口放一把S锁（行锁）。</p><p>如果有维修工到楼层中维修，那么它先在整栋大楼门口放一把IX锁（表级锁），然后再到楼层门口放一把X锁（行锁）。</p><p>之后：</p><p>如果有投资人要参观大楼，也就是想在大楼门口前放S锁（表锁）时，首先要看一下大楼门口有没有IX锁，如果有，意味着有楼层在维修，需要等到维修结束把IX锁撤掉后才可以在整栋大楼上加S锁。</p><p>如果有谈条件要占用大楼，也就是想在大楼门口前放X锁（表锁）时，首先要看一下大楼门口有没有IS锁或IX锁，如果有，意味着有楼层在办公或者维修，需要等到客户们办完公以及维修结束把IS锁和IX锁撤掉后才可以在整栋大楼上加X锁。</p><p>注意： 客户在大楼门口加IS锁时，是不关心大楼门口是否有IX锁的，维修工在大楼门口加IX锁时，是不关心大楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间大楼里有没有被占用的楼层用的，也就是在对大楼加S锁或者X锁时才会用到。</p><p><strong>总结一下</strong>：<strong>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录</strong>。就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。我们画个表来看一下<strong>表级别</strong>的各种锁的兼容性：</p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td></td><td>不兼容</td><td></td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td></td><td></td></tr><tr><td>IS</td><td>不兼容</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>组合性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>表锁</td><td>有</td><td>有</td><td>有</td><td>有</td></tr><tr><td>行锁</td><td>有</td><td></td><td>有</td><td></td></tr></tbody></table><h1><strong>InnoDB存储引擎中的锁</strong></h1><h2 id="1-表级锁"><strong>1.表级锁</strong></h2><p><strong>1.表级别的S锁、X锁、元数据锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>另外，在对某个表执行一些诸如<code>ALTER TABLE、DROP TABLE</code>这类的<strong>DDL</strong>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞，同理，<strong>某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁</strong>（英文名：Metadata Locks，简称MDL）来实现的，一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。</p><p>其实这个InnoDB存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks = 1时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：</p><p>LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。</p><p>LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。</p><p><strong>请尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句，它们并不会提供什么额外 的保护，只是会降低并发能力而已。</strong></p><p><strong>2.表级别的IS锁、IX锁</strong></p><p>当我们在对使用InnoDB存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。</p><p>IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。我们并不能手动添加意向锁，只能由InnoDB存储引擎自行添加。</p><p><strong>1.3.表级别的AUTO-INC锁</strong></p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h2 id="2-InnoDB中的行级锁">2.InnoDB中的行级锁</h2><p>– <strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</strong></p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p>不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p><p>只有执行计划真正使用了索引，才能使用行锁：<strong>即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB</strong> <strong>将使用表锁，而不是行锁。</strong></p><p>同时当我们用范围条件而不是相等条件检索数据，并请求锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。</p><p>不过即使是行锁，InnoDB里也是分成了各种类型的。换句话说即使对同一条记录加行锁，如果类型不同，起到的功效也是不同的。我们使用前面的teacher，增加一个索引，并插入几条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX  `idx_number`(`number`)</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316231101579.png" alt="image-20230316231101579"></p><p>我们来看看都有哪些常用的行锁类型。</p><p><strong>Record Locks</strong>也叫记录锁，就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP。比方说我们把number值为6的那条记录加一个记录锁的示意图如下：</p><p><img src="https://zdwtop.cn/blog/image-20230316231114641.png" alt="image-20230316231114641"></p><p>记录锁是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁；</p><h3 id="Gap-Locks-间隙锁"><strong>Gap Locks 间隙锁</strong></h3><p>我们说MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。**但是在使用加锁方案解决时有问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。**InnoDB提出了一种称之为Gap Locks的锁，官方的类型名称为：LOCK_GAP，我们也可以简称为gap锁。</p><p><strong>间隙锁实质上是对索引前后的间隙上锁，不对索引本身上锁。</strong></p><p>会话1开启一个事务，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> domain <span class="operator">=</span><span class="string">&#x27;JVM&#x27;</span> <span class="keyword">where</span> number<span class="operator">=</span><span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316231159581.png" alt="image-20230316231159581"></p><p>如图中为2~6和  6  ~ 10的记录加了gap锁，意味着不允许别的事务在这条记录前后间隙插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">value</span>(<span class="number">7</span>,<span class="string">&#x27;曾&#x27;</span>,<span class="string">&#x27;docker&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为什么不能插入？因为记录（7,‘曾’,‘docker’）要 插入的话，在索引idx_number上，刚好落在6  ~ 10之间，是有锁的，当然不允许插入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;MySQL中的锁&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;InnoDB中锁非常多，总的来说，可以如下分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zdwtop.cn/blog/image-20230316215836060.png&quot; alt&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="锁" scheme="https://eizo01.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MVCC多并发版本控制</title>
    <link href="https://eizo01.github.io/posts/484a2385.html"/>
    <id>https://eizo01.github.io/posts/484a2385.html</id>
    <published>2022-10-16T12:00:00.000Z</published>
    <updated>2023-03-16T15:21:20.389Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>MVCC多并发版本控制</strong></h1><p>前提知识：rowid：没有主键的时候自动创建。trx_id是事务ID；</p><p>全称Multi-Version Concurrency Control，即<strong>多版本并发控制</strong>，<strong>主要是为了提高数据库的并发性能</strong>。</p><p>同一行数据平时发生读写请求时，会上锁阻塞住。但MVCC用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。</p><p>**这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。**那它到底是怎么做到读—写不用加锁的，快照读和当前读是指什么？我们会在锁文章里学习到。</p><h2 id="1-MVCC原理"><strong>1.MVCC原理</strong></h2><h3 id="1-1-复习事务隔离级别–❤️"><strong>1.1.复习事务隔离级别–❤️</strong></h3><p><img src="https://zdwtop.cn/blog/image-20230316174006249.png" alt="image-20230316174006249"></p><p>MySQL在REPEATABLE READ隔离级别下，是可以很大程度避免幻读问题的发生的（<strong>好像解决了，但是又没完全解决</strong>），MySQL是怎么做到的？</p><p>那么就要拿出MVCC中的<strong>ReadView</strong>和<strong>ReadView</strong>了，可以说它解决了事务大部分的问题，而且不用加锁减少性能。重点解决的是RC RR</p><h3 id="1-2-版本链"><strong>1.2.版本链</strong></h3><p><strong>必须要知道的概念（每个版本链针对的一条数据）：</strong></p><p><font color="\#87CEFA"><strong>我们知道，对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</strong></font></p><p><font color="\#87CEFA"><strong>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</strong></font></p><p><font color="\#87CEFA"><strong>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</strong></font></p><p>（row_id并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含row_id列）</p><blockquote><p>补充点：undo日志：为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。<strong>一般每对一条记录做一次改动，就对应着一条undo日志</strong>，但在某些更新记录的操作中，也可能会对应着2条undo日志。一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的undo日志，这些undo日志会被从0开始编号，也就是说根据生成的顺序分别被称为第0号undo日志、第1号undo日志、…、第n号undo日志等，这个编号也被称之为undo no。</p></blockquote><p>为了说明这个问题，我们创建一个演示表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teacher (</span><br><span class="line">number <span class="type">INT</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">domain <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：(1,李瑾,jvm系列)</p><p><img src="https://zdwtop.cn/blog/image-20230316175208518.png" alt="image-20230316175208518"></p><p>假设之后两个事务id分别为80、120的事务对这条记录进行UPDATE操作，操作流程如下：</p><p><img src="https://zdwtop.cn/blog/image-20230316175306968.png" alt="image-20230316175306968"></p><p><strong>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性</strong>（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p><img src="https://zdwtop.cn/blog/image-20230316175348409.png" alt="image-20230316175348409"></p><p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。<strong>于是可以利用这个记录的版本链来控制并发事务访问相同记录的行为，那么这种机制就被称之为多版本并发控制(Mulit-Version Concurrency Control MVCC)。</strong></p><h3 id="1-3-ReadView"><strong>1.3.ReadView</strong></h3><p>这个ReadView中主要包含4个比较重要的内容：</p><p><strong>m_ids：<strong>表示在生成ReadView时当前系统中</strong>活跃的读写事务的事务id列表</strong>。</p><p><strong>min_trx_id：<strong>表示在生成ReadView时当前系统中</strong>活跃的读写事务中最小的事务id</strong>，也就是<strong>m_ids中的最小值。</strong></p><p><strong>max_trx_id：<strong>表示生成ReadView时系统中应该分</strong>配给下一个事务的id值</strong>。</p><blockquote><p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。</p><p>比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p></blockquote><p>**creator_trx_id：**表示生成该ReadView的事务的事务id</p><p><strong>必须要知道的概念（作用于SQL查询语句）</strong></p><p>对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，<strong>由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了</strong>（<strong>所以就会出现脏读、不可重复读、幻读</strong>）。</p><p><img src="https://zdwtop.cn/blog/image-20230316180356855.png" alt="image-20230316180356855"></p><p>对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，<strong>InnoDB使用加锁的方式来访问记录</strong>（<strong>也就是所有的事务都是串行的，当然不会出现脏读、不可重复读、幻读</strong>）。</p><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。</p><p>核心问题就是：READ COMMITTED和REPEATABLE READ隔离级别在不可重复读和幻读上的区别是从哪里来的，其实结合前面的知识(<font color="\#87CEFA"> <strong>幻读是关注数据的新加，不可重复读是关注数据的修改。</strong> </font>)，这两种隔离级别关键<strong>是需要判断一下版本链中的哪个版本是当前事务可见的</strong>。<strong>为此，InnoDB提出了一个ReadView的概念（作用于SQL查询语句）</strong></p><h3 id="1-4-READ-COMMITTED-已提交读"><strong>1.4.READ COMMITTED</strong> 已提交读</h3><h4 id="脏读问题的解决"><strong>脏读问题的解决</strong></h4><p><font color="\#87CEFA">-<strong>版本链 + ReadView 解决了脏读</strong></font></p><p>READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><p>在MySQL中，<strong>READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。</strong></p><p>我们还是以表teacher 为例，假设现在表teacher 中只有一条由事务id为60的事务插入的一条记录，接下来看一下READ COMMITTED和REPEATABLE READ所谓的生成ReadView的时机不同到底不同在哪里。</p><p>READ COMMITTED —— <strong>每次读取数据前都生成一个ReadView</strong>：</p><p>比方说现在系统里有两个事务id分别为80、120的事务在执行：<code>Transaction 80</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;马&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;连&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此时，表teacher 中number为1的记录得到的版本链表如下所示：</p><p><img src="https://zdwtop.cn/blog/image-20230316192715661.png" alt="image-20230316192715661"></p><p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p><p><img src="https://zdwtop.cn/blog/image-20230316192725857.png" alt="image-20230316192725857#"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">SELECE <span class="number">1</span>：Transaction <span class="number">80</span>、<span class="number">120</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br></pre></td></tr></table></figure><p>第1次select的时间点 如下图：</p><p><img src="https://zdwtop.cn/blog/image-20230316192815200.png" alt="image-20230316192815200"></p><p>这个SELECE1的执行过程如下：在执行SELECT语句时会先生成一个ReadView：</p><p><strong>ReadView的m_ids列表的内容就是[80, 120]，min_trx_id为80，max_trx_id为121，creator_trx_id为0。</strong></p><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’<strong>连</strong>’，该版本的trx_id值为80，在m_ids列表内，所以不符合可见性要求（trx_id属性值在ReadView的min_trx_id和max_trx_id之间说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问），根据roll_pointer跳到下一个版本。下一个版本的列name的内容是’<strong>马</strong>’，该版本的trx_id值也为80，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。下一个版本的列name的内容是’<strong>李瑾</strong>’，该版本的trx_id值为60，小于ReadView中的min_trx_id值，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’<strong>李瑾</strong>’的记录。</p><p><strong>所以有了这种机制，就不会发生脏读问题！因为会去判断活跃版本，必须是不在活跃版本的才能用，不可能读到没有 commit的记录。</strong></p><p><img src="https://zdwtop.cn/blog/image-20230316193754497.png" alt="image-20230316193754497"></p><h4 id="不可重复读问题没有解决"><strong>不可重复读问题没有解决</strong></h4><p>然后，我们把事务id为80的事务提交一下，然后再到事务id为120的事务中更新一下表teacher 中number为1的记录：</p><p><img src="https://zdwtop.cn/blog/image-20230316193954862.png" alt="image-20230316193954862"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transaction <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">更新了一些别的表的记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;严&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;晁&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此刻，表teacher 中number为1的记录的版本链就长这样：</p><p><img src="https://zdwtop.cn/blog/image-20230316211601448.png" alt="image-20230316211601448"></p><p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number为1的记录，如下：</p><p>使用READ COMMITTED隔离级别的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">SELECE1：Transaction <span class="number">80</span>、<span class="number">120</span>均未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br><span class="line"></span><br><span class="line">SELECE2：Transaction <span class="number">80</span>提交，Transaction <span class="number">120</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;连&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**第2次select的时间点 如下图：**就是事务80已经提交了，120还没提交</p><img src="https://zdwtop.cn/blog/image-20230316211638296.png" alt="image-20230316211638296" style="zoom:50%;"><p>SELECT * FROM teacher WHERE number = 1;</p><p>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView信息如下：</p><p>活跃id ：m_ids列表的内容就是[120]（事务id为80的那个事务已经提交了，所以再次生成快照时就没有它了），<strong>min_trx_id为120，max_trx_id为121</strong>，<strong>creator_trx_id为0。</strong></p><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’<strong>晁</strong>’，该版本的trx_id值为120，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。下一个版本的列name的内容是’<strong>严</strong>’，该版本的trx_id值为120，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。下一个版本的列name的内容是’<strong>连</strong>’，该版本的trx_id值为80，小于ReadView中的<code>min_trx_id</code>值120，所以这个版本是符合要求的，<strong>最后返回给用户的版本就是这条列name为’连’的记录。</strong></p><p>如果之后事务id为120的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表teacher 中number值为1的记录时，得到的结果就是’<strong>晁</strong>’了，具体流程我们就不分析了。</p><p>所以版本链+ReadView就解决了脏读，但RC隔离级别上会出现不可重复读问题。</p><p>就是上面那个事务有两个语句查询同一个语句，我们分别查出来有两个数据结果不一致，因为两次select都生成了不同的Readview，而第二次的readview时，事务80已经提交不再活跃了，但我们身初在120这个事务时就能查询80事务所修改的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">SELECE1：Transaction <span class="number">80</span>、<span class="number">120</span>均未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br><span class="line"></span><br><span class="line">SELECE2：Transaction <span class="number">80</span>提交，Transaction <span class="number">120</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;连&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316212052828.png" alt="image-20230316212052828"></p><p><strong>总结：RC隔离级别的事务在每次查询开始时都会生成独立的readview</strong></p><h3 id="1-5-REPEATABLE-READ-可重复读"><strong>1.5.REPEATABLE READ</strong> 可重复读</h3><h4 id="解决不可重复读问题"><strong>解决不可重复读问题</strong></h4><p>已经在版本链 + ReadView的情况下已经可以解决脏读了，解RR的隔离级别来解决不可重复读。</p><p><font color="\#87CEFA"><strong>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</strong></font></p><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>比方说现在系统里有两个事务id分别为80、120的事务在执行：Transaction 80</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;马&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;连&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表teacher 中number为1的记录得到的版本链表如下所示：</p><p><img src="https://zdwtop.cn/blog/image-20230316213612435.png" alt="image-20230316213612435"></p><p>假设现在有一个使用REPEATABLE READ隔离级别的事务开始执行：</p><img src="https://zdwtop.cn/blog/image-20230316213622378.png" alt="image-20230316213622378" style="zoom:50%;"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECE1：Transaction <span class="number">80</span>、<span class="number">120</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br></pre></td></tr></table></figure><p>这个SELECE1的执行过程如下：在执行SELECT语句时会先生成一个ReadView：</p><p>ReadView的m_ids列表的内容就是[80, 120]，min_trx_id为80，max_trx_id为121，creator_trx_id为0。</p><p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’<strong>连</strong>’，该版本的trx_id值为80，在m_ids列表内，所以不符合可见性要求（trx_id属性值在ReadView的min_trx_id和max_trx_id之间说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；</p><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问），根据roll_pointer跳到下一个版本。下一个版本的列name的内容是’<strong>马</strong>’，该版本的trx_id值也为80，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。下一个版本的列name的内容是’<strong>李瑾</strong>’，该版本的trx_id值为60，小于ReadView中的min_trx_id值，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’<strong>李瑾</strong>’的记录。</p><p>之后，我们把事务id为80的事务提交一下，然后再到事务id为120的事务中更新一下表teacher 中number为1的记录：</p><p><img src="https://zdwtop.cn/blog/image-20230316213856999.png" alt="image-20230316213856999"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction120</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">#更新了一些别的表的记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;严&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> teacher  <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;晁&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316211601448.png" alt="image-20230316211601448"></p><p>然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个number为1的记录，如下：</p><p>使用READ COMMITTED隔离级别的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECE1：Transaction <span class="number">80</span>、<span class="number">120</span>均未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECE2：Transaction <span class="number">80</span>提交，Transaction <span class="number">120</span>未提交</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;李瑾&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个SELECE2的执行过程如下：</p><p>因为当前事务的隔离级别为REPEATABLE READ，而之前在执行SELECE1时已经生成过ReadView了，所以此时<strong>直接复用之前的ReadView</strong>，之前的ReadView的m_ids列表的内容就是[80, 120]，min_trx_id为80，max_trx_id为121，creator_trx_id为0。</p><p><strong>根据前面的分析，返回的值还是’李瑾’。</strong></p><p><strong>也就是说两次SELECT查询得到的结果是重复的，记录的列name值都是’李瑾’，这就是可重复读的含义。</strong></p><p><img src="https://zdwtop.cn/blog/image-20230316170549681.png" alt="image-20230316170549681"></p><p><strong>总结一下就是：</strong></p><p><strong>ReadView中的比较规则(前两条)</strong></p><ol><li><p>如果被访问版本的<code>trx_id</code>属性值与ReadView中的<code>creator_trx_id</code>值相同，<strong>trx_id = creator_trx_id</strong>意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>属性值小于ReadView中的<code>min_trx_id</code>值，<strong>trx_id &lt; min_trx_id 表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</strong></p></li></ol><h3 id="1-6-MVCC下的幻读解决和幻读现象"><strong>1.6.MVCC下的幻读解决和幻读现象</strong></h3><p>目前只有串行化和RR可重复读解决了幻读，而RR是解决了大部分的幻读。</p><p>前面我们已经知道了，REPEATABLE READ隔离级别下MVCC可以解决不可重复读问题，那么幻读呢？MVCC是怎么解决的？幻读是一个事务<strong>按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，而这个记录来自另一个事务添加的新记录</strong>。我们可以想想，在REPEATABLE READ隔离级别下的事务T1先根据某个搜索条件读取到多条记录，然后事务T2插入一条符合相应搜索条件的记录并提交，然后事务T1再根据相同搜索条件执行查询。结果会是什么？</p><p>按照<strong>ReadView中的比较规则(后两条)：</strong></p><ol start="3"><li><p>如果被访问版本的<code>trx_id</code>属性值大于或等于ReadView中的<code>max_trx_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>属性值在ReadView的<code>min_trx_id</code>和<code>max_trx_id</code>之间(min_trx_id &lt; trx_id &lt; max_trx_id)，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，<strong>说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</strong></p></li></ol><p>不管事务T2比事务T1是否先开启，事务T1都是看不到T2的提交的。请自行按照上面介绍的版本链、ReadView以及判断可见性的规则来分析一下。但是，在REPEATABLE READ隔离级别下InnoDB中的MVCC 可以很大程度地避免幻读现象，而不是完全禁止幻读。怎么回事呢？我们来看下面的情况：</p><p><img src="https://zdwtop.cn/blog/image-20230316215033903.png" alt="image-20230316215033903"></p><p>我们首先在<strong>事务T1</strong>中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> number <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>很明显，这个时候是找不到number = 30的记录的。我们在<strong>事务T2</strong>中，执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;豹&#x27;</span>,<span class="string">&#x27;数据湖&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316215108427.png" alt="image-20230316215108427"></p><p>通过执行insert into teacher values(30,‘豹’,‘数据湖’);，我们往表中插入了一条number = 30的记录。<strong>此时回到事务T1</strong>，执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> domain<span class="operator">=</span><span class="string">&#x27;RocketMQ&#x27;</span> <span class="keyword">where</span> number<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> number <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316215130551.png" alt="image-20230316215130551"></p><p>怎么回事？事务T1很明显出现了幻读现象。在REPEATABLE READ隔离级别下，<strong>T1第一次执行普通的SELECT 语句时生成了一个ReadView（但是版本链没有），之后T2向teacher 表中新插入一条记录并提交，然后T1也进行了一个update语句。ReadView并不能阻止T1执行UPDATE 或者DELETE 语句来改动这个新插入的记录，但是这样一来，这条新记录的trx_id隐藏列的值就变成了T1的事务id。</strong></p><p><img src="https://zdwtop.cn/blog/image-20230316215158396.png" alt="image-20230316215158396"></p><p>之后T1再使用普通的SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。因为这个特殊现象的存在，我们也可以认为MVCC 并不能完全禁止幻读（<strong>就是第一次读如果是空的情况，且在自己事务中进行了该条数据的修改</strong>）。</p><h3 id="1-7-MVCC小结"><strong>1.7.MVCC小结</strong></h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了，从而基本上可以避免幻读现象（<strong>就是第一次读如果ReadView是空的情况中的某些情况则避免不了</strong>）。</p><p>另外，所谓的MVCC只是在我们进行普通的SEELCT查询时才生效，截止到目前我们所见的所有SELECT语句都算是普通的查询，至于什么是个不普通的查询，后面马上就会讲到（锁定读）。准备开启我们的锁章节了嘛</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;MVCC多并发版本控制&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;前提知识：rowid：没有主键的时候自动创建。trx_id是事务ID；&lt;/p&gt;
&lt;p&gt;全称Multi-Version Concurrency Control，即&lt;strong&gt;多版本并发控制&lt;/st</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="事务" scheme="https://eizo01.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务和隔离级别</title>
    <link href="https://eizo01.github.io/posts/46b84e39.html"/>
    <id>https://eizo01.github.io/posts/46b84e39.html</id>
    <published>2022-10-16T12:00:00.000Z</published>
    <updated>2023-03-18T14:02:16.593Z</updated>
    
    <content type="html"><![CDATA[<h1>MySQL事务和隔离级别</h1><h1><strong>1.为什么需要事务</strong></h1><p><strong>事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事务），要不全部成功，要不全部不成功。</strong></p><p>经典的转账例子：A 给B 要划钱，A 的账户-1000元， B 的账户就要+1000元，这两个update 语句必须作为一个整体来执行，不然A 扣钱了，B 没有加钱这种情况就是错误的。那么事务就可以保证A 、B 账户的变动要么全部一起发生，要么全部一起不发生。</p><h1><strong>2.事务特性</strong></h1><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为<strong>ACID</strong>特性。</p><ul><li><p><strong>原子性（atomicity）</strong></p></li><li><p><strong>一致性（consistency）</strong></p></li><li><p><strong>隔离性（isolation）</strong></p></li><li><p><strong>持久性（durability）</strong></p></li></ul><h3 id="2-1-原子性（atomicity）"><strong>2.1.原子性（atomicity）</strong></h3><p>**一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不能只执行其中的一部分操作。**比如：</p><p>连老师借给李老师1000元：</p><p>1.连老师工资卡扣除1000元</p><p>2.李老师工资卡增加1000元</p><p>整个事务的操作要么全部成功，要么全部失败，不能出现连老师工资卡扣除，但是李老师工资卡不增加的情况。如果原子性不能保证，就会很自然的出现一致性问题。</p><h3 id="2-2-一致性（consistency）"><strong>2.2.一致性（consistency）</strong></h3><p><strong>一致性是指事务将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。</strong></p><p>连老师借给李老师1000元：</p><p>1.连老师工资卡扣除1000元</p><p>2.李老师工资卡增加1000元</p><p>扣除的钱（-500） 与增加的钱（500） 相加应该为0，或者说连老师和李老师的账户的钱加起来，前后应该不变。</p><h3 id="2-3-隔离性（isolation）"><strong>2.3.隔离性（isolation）</strong></h3><p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p><strong>如果隔离性不能保证，会导致什么问题？</strong></p><p>连老师借给李老师生活费，借了两次，每次都是1000，连老师的卡里开始有10000，李老师的卡里开始有500，从理论上，借完后，连老师的卡里有8000，李老师的卡里应该有2500。</p><p>我们将连老师向李老师同时进行的两次转账操作分别称为T1和T2，在现实世界中T1和T2是应该没有关系的，可以先执行完T1，再执行T2，或者先执行完T2，再执行T1，结果都是一样的。</p><p>但是很不幸，真实的数据库中T1和T2的操作可能交替执行的，执行顺序就有可能是：</p><p><img src="https://zdwtop.cn/blog/image-20230316164908989.png" alt="image-20230316164908989"></p><p>如果按照上图中的执行顺序来进行两次转账的话，最终我们看到，连老师的账户里还剩9000元钱，相当于只扣了1000元钱，但是李老师的账户里却成了2500元钱，多了1000元，这银行岂不是要亏死了？</p><p>所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以原子性的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为隔离性。</p><h3 id="2-4-持久性（durability）"><strong>2.4.持久性（durability）</strong></h3><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。</p><h1><strong>3.事务并发引发的问题</strong></h1><p>我们知道MySQL是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（Session）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。</p><p>在上面我们说过事务有一个称之为隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后， 其他事务才可以继续访问这个数据，这样的话并发事务的执行就变成了串行化执行。当然串行化可以保证事务，但是串行化执行性能影响太大，</p><p><strong>我们既想保持事务的一定的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，当我们舍弃隔离性的时候</strong>，可能会带来什么样的数据问题呢？</p><h3 id="3-1-脏读"><strong>3.1.脏读</strong></h3><p>当一个事务读取到了外一个事务修改但未提交的数据，被称为脏读。</p><p><img src="https://zdwtop.cn/blog/image-20230316170126044.png" alt="image-20230316170126044"></p><ol><li><p>在事务A执⾏过程中，事务A对数据资源进⾏了修改，事务B读取了事务A修改后的数据。</p></li><li><p>由于某些原因，事务A并没有完成提交，发⽣了RollBack操作，则事务B读取的数据就是脏数据。</p></li></ol><p><font color="\#87CEFA"><strong>这种读取到另⼀个事务未提交的数据的现象就是脏读(Dirty Read).</strong></font></p><h3 id="3-2-不可重复读"><strong>3.2.不可重复读</strong></h3><p>当事务内相同的记录被检索两次，且两次得到的结果不同时，此现象称为不可重复读。</p><p><img src="https://zdwtop.cn/blog/image-20230316170549681.png" alt="image-20230316170549681"></p><p>事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不⼀致。</p><h3 id="3-3-幻读"><strong>3.3.幻读</strong></h3><p>在事务执行过程中，另一个事务将新记录添加到正在读取的事务中时，会发生幻读。</p><p><img src="https://zdwtop.cn/blog/image-20230316170757089.png" alt="image-20230316170757089"></p><p>事务B前后两次读取同⼀个范围的数据，在事务B两次读取的过程中事务A<strong>新增了数据</strong>，导致事务B后⼀次读取到前⼀次查询没有看到的⾏。</p><p><font color="\#87CEFA"><strong>幻读和不可重复读有些类似，但是幻读重点强调了读取到了之前读取没有获取到的记录。</strong></font></p><p><font color="\#87CEFA"> <strong>幻读是关注数据的新加，不可重复读是关注数据的修改。</strong> </font></p><h1><strong>4.SQL标准中的四种隔离级别</strong></h1><p>我们上边介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题也有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><p><code>脏读 &gt; 不可重复读 &gt; 幻读</code></p><p>我们上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。有一帮人（并不是设计MySQL的大叔们）制定了一个所谓的SQL标准，在标准中设立了4个隔离级别：</p><p><strong>READ UNCOMMITTED：未提交读。</strong></p><p><strong>READ COMMITTED：已提交读。</strong></p><p><strong>REPEATABLE READ：可重复读。</strong></p><p><strong>SERIALIZABLE：可串行化。</strong></p><img src="https://zdwtop.cn/blog/image-20230316171114737.png" alt="image-20230316171114737" style="zoom:80%;"><p>SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><p>也就是说：</p><p><strong>RU 未提交读  - READ UNCOMMITTED隔离级别下，可能发生脏读、不可重复读和幻读问题。</strong></p><p>**RC 已提交读- READ COMMITTED隔离级别下，可能发生不可重复读和幻读问题，但是不可以发生脏读问题。 **</p><p><strong>（默认）REPEATABLE READ隔离级别下，可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。  RR 解决了大部分的幻读问题，但没有完全解决 可重复读。</strong></p><p><strong>SERIALIZABLE隔离级别下，各种问题都不可以发生。</strong></p><h1><strong>5.MySQL中的隔离级别</strong></h1><p>本文中所讨论的MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在<code>REPEATABLE READ(默认)</code>隔离级别下，是可以禁止幻读问题的发生的。</p><img src="https://zdwtop.cn/blog/image-20230316171312958.png" alt="image-20230316171312958" style="zoom:80%;"><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改事务的隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure><p>其中的level可选值有4个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level: &#123;</span><br><span class="line">    REPEATABLE READ</span><br><span class="line">   <span class="operator">|</span> READ COMMITTED</span><br><span class="line">   <span class="operator">|</span> READ UNCOMMITTED</span><br><span class="line">   <span class="operator">|</span> SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用GLOBAL关键字（在全局范围影响）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>使用SESSION关键字（在会话范围影响）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对当前会话的所有后续的事务有效</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>只对执行语句后的下一个事务产生影响：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>查看当前会话事务：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure><h1><strong>6.MySQL事务</strong></h1><h3 id="6-1-事务基本语法"><strong>6.1.事务基本语法</strong></h3><p><strong>事务开始</strong></p><ol><li>begin</li><li>START TRANSACTION（推荐）</li><li>begin work</li></ol><p><strong>事务回滚</strong></p><p>rollback</p><p><strong>事务提交</strong></p><p>commit</p><h3 id="6-2-保存点"><strong>6.2.保存点</strong></h3><p>如果你开启了一个事务，执行了很多语句，忽然发现某条语句有点问题，你只好使用ROLLBACK语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，但是可能根据业务和数据的变化，不需要全部回滚。</p><p>所以MySQL里提出了一个保存点（英文：savepoint）的概念，就是在事务对应的数据库语句中打几个点，我们在调用ROLLBACK语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p><p>SAVEPOINT 保存点名称;</p><p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK和SAVEPOINT是可有可无的）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>] 保存点名称;</span><br></pre></td></tr></table></figure><p>不过如果ROLLBACK语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p><p>如果我们想删除某个保存点，可以使用这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure><p>使用前要把自己提交先给关闭</p><p><img src="https://zdwtop.cn/blog/image-20230316172500603.png" alt="image-20230316172500603"></p><p><img src="https://zdwtop.cn/blog/image-20230316172503895.png" alt="image-20230316172503895"></p><p><img src="https://zdwtop.cn/blog/image-20230316172519101.png" alt="image-20230316172519101"></p><h3 id="6-3-隐式提交–重要"><strong>6.3.隐式提交–重要</strong></h3><p>当我们使用START TRANSACTION或者BEGIN语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为OFF时，事务就不会进行自动提交，但是如果我们输入了某些语句之后就会悄悄的提交掉，就像我们输入了COMMIT语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为隐式提交，这些会导致事务隐式提交的语句包括：</p><h4 id="6-3-1-执行DDL-定义语句"><strong>6.3.1.执行DDL-定义语句</strong></h4><p><strong>定义或修改数据库对象的数据定义语言</strong>（Datadefinition language，缩写为：DDL）。</p><p>所谓的数据库对象，指的就是数据库、表、视图、存储过程等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会<strong>隐式的提交前边语句所属于的事务</strong>，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316172813762.png" alt="image-20230316172813762"></p><h4 id="6-3-2-隐式使用或修改mysql数据库中的表"><strong>6.3.2.隐式使用或修改mysql数据库中的表</strong></h4><p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p><h4 id="6-3-3-事务控制或关于锁定的语句"><strong>6.3.3.事务控制或关于锁定的语句</strong></h4><p>当我们在一个会话里，一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; #  </span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230316173035210.png" alt="image-20230316173035210"></p><p>或者当前的<code>autocommit</code>系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事务。</p><p>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MySQL事务和隔离级别&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;1.为什么需要事务&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="事务" scheme="https://eizo01.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>索引优化</title>
    <link href="https://eizo01.github.io/posts/484a2385.html"/>
    <id>https://eizo01.github.io/posts/484a2385.html</id>
    <published>2022-10-13T12:00:00.000Z</published>
    <updated>2023-03-18T14:02:16.580Z</updated>
    
    <content type="html"><![CDATA[<h1>什么时候适用索引？</h1><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h1>什么时候不需要创建索引？</h1><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h1>优化索引</h1><h3 id="前缀索引优化">前缀索引优化</h3><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h3 id="覆盖索引优化">覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p><h3 id="主键索引最好是自增的">主键索引最好是自增的</h3><p>我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？</p><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</p><p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p><p>而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E9%A1%B5%E5%88%86%E8%A3%82.png" alt="img"></p><p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p><p>而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E5%BC%80%E8%BE%9F%E6%96%B0%E9%A1%B5.png" alt="1"></p><p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h3 id="索引最好设置为-NOT-NULL">索引最好设置为 NOT NULL</h3><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那行格式中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>，如下图的紫色部分：</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"></p><h3 id="防止索引失效">防止索引失效</h3><p>用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;什么时候适用索引？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;字段有唯一性限制的，比如商品编码；&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;WHERE&lt;/code&gt; 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。&lt;/li&gt;
&lt;li&gt;经常用于 &lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="索引" scheme="https://eizo01.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="sql优化" scheme="https://eizo01.github.io/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL执行计划</title>
    <link href="https://eizo01.github.io/posts/4c47caa9.html"/>
    <id>https://eizo01.github.io/posts/4c47caa9.html</id>
    <published>2022-10-10T13:00:00.000Z</published>
    <updated>2022-10-20T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>MySQL执行计划</strong></h1><h2 id="2-Explain执行计划"><strong>2. Explain执行计划</strong></h2><h3 id="2-1-什么是执行计划"><strong>2.1. 什么是执行计划</strong></h3><p>有了慢查询语句后，就要对语句进行分析。一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，我们需要搞懂EPLATNEXPLAIN的各个输出项都是干嘛使的，从而可以有针对性的提升我们查询语句的性能。</p><p>通过使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析查询语句或是表结构的性能瓶颈，总的来说通过EXPLAIN我们可以：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h3 id="2-3-执行计划的语法"><strong>2.3. 执行计划的语法</strong></h3><p>执行计划的语法其实非常简单： 在SQL查询的前面加上EXPLAIN关键字就行。比如：<code>EXPLAIN select * from table1</code></p><p>重点的就是EXPLAIN后面你要分析的SQL语句</p><p>除了以SELECT开头的查询语句，其余的DELETE、INSERT、REPLACE以及UPOATE语句前边都可以加上EXPLAIN，用来查看这些语句的执行计划，不过我们这里对SELECT语句更感兴趣，所以后边只会以SELECT语句为例来描述EsxPLAIN语句的用法。</p><h3 id="2-4-执行计划详解"><strong>2.4. 执行计划详解</strong></h3><p>为了让大家先有一个感性的认识，我们把EXPLAIN语句输出的各个列的作用先大致罗列一下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp;</span><br></pre></td></tr></table></figure><ul><li><p><strong>id</strong> <strong>： 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</strong></p></li><li><p><strong>select_type</strong> <strong>： SELECT 关键字对应的那个查询的类型</strong></p></li><li><p><strong>table</strong> <strong>：表名</strong></p></li><li><p><strong>partitions</strong> <strong>：匹配的分区信息</strong></p></li><li><p><strong>type</strong> <strong>：针对单表的访问方法</strong></p></li><li><p><strong>possible_keys</strong> <strong>：可能用到的索引</strong></p></li><li><p><strong>key</strong> <strong>：实际上使用的索引</strong></p></li><li><p><strong>key_len</strong> <strong>：实际使用到的索引长度</strong></p></li><li><p><strong>ref</strong> <strong>：当使用索引列等值查询时，与索引列进行等值匹配的对象信息</strong></p></li><li><p><strong>rows</strong> <strong>：预估的需要读取的记录条数</strong></p></li><li><p><strong>filtered</strong> <strong>：某个表经过搜索条件过滤后剩余记录条数的百分比</strong></p></li><li><p><strong>Extra</strong> <strong>：—些额外的信息</strong></p></li></ul><p>接下来我们会一个一个字段的解释，执行计划是我们优化SQL的第一步。</p><h4 id="2-4-1-id">2.4.1 <strong>id</strong></h4><p>我们知道我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，</p><p>稍微复杂一点的连接查询中也只有一个SELECT关键字，比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> s1 </span><br><span class="line"><span class="keyword">INNER</span> J0IN s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id </span><br><span class="line"><span class="keyword">WHERE</span> s1.order_status <span class="operator">=</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><strong>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字:</strong></p><ol><li>查询中包含子查询的情况</li></ol><p>比如下边这个查询语句中就包含2个SELECT关键字:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure><ol start="2"><li>查询中包含UNION语句的情况</li></ol><p>比如下边这个查询语句中也包含2个SELECT关键字:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2 ;</span><br></pre></td></tr></table></figure><p>查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值。这个id值就是EXPLAIN语句的第一个列。</p><h5 id="单SELECT关键字"><strong>单SELECT关键字</strong></h5><p>比如下边这个查询中只有一个SELECT关键字，所以EXPLAIN的结果中也就只有一条id列为1的记录∶</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="连接查询"><strong>连接查询</strong></h5><p>对于连接查询来说，一个SELEOT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">inner</span> <span class="keyword">join</span> s2;</span><br><span class="line"> #即使你用了内连接，mysql他也认为是一个简单的查询</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314163143189.png" alt="image-20230314163143189"></p><p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的id值都是1。这里需要大家记住的是，在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的。</p><h5 id="包含子查询"><strong>包含子查询</strong></h5><p>对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值，比如这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314163739963.png" alt="image-20230314163739963"></p><p>但是这里大家需要特别注意，**查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。**所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/6475b28cd68144b89566254b0891a210.png" alt="image.png"></p><p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的id值全部是1，<strong>这就表明了查询优化器将子查询转换为了连接查询,</strong></p><h5 id="包含UNION子句"><strong>包含UNION子句</strong></h5><p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p>​    <img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1651212459071/4907ca3c4cea47a0add9684f8081acc3.png" alt="image.png"></p><p>这个语句的执行计划的第三条记录为什么这样？<strong>UNION子句会把多个查询的结果集合并起来并对结果集中的记录进行去重</strong>，怎么去重呢? **MySQL使用的是内部的临时表。**正如上边的查询计划中所示，UNION 子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重。</p><p>所以在内部创建了一个名为的临时表（就是执行计划第三条记录的table列的名称)，id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p><p>跟UNION 对比起来，<strong>UNIONALL就不需要为最终的结果集进行去重</strong>，<font color="blue"><strong>它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。</strong></font>所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314164241278.png" alt="image-20230314164241278"></p><h4 id="2-4-2-select-type"><strong>2.4.2 select_type</strong></h4><ul><li><p><strong>SIMPLE</strong>：简单的select查询,<strong>不使用 union 及子查询</strong> ：最外层的select 查询</p></li><li><p><strong>UNION：UNION</strong>中的第二个或随后的 select 查询,不 依赖于外部查询的结果集 – UNIONALL</p></li><li><p><strong>UNIONRESULT：UNION</strong> 结果集</p></li><li><p><strong>SUBQUERY</strong>：<strong>子查询</strong>中的第一个select 查询,不依赖于外部查询的结果集</p></li><li><p><strong>DEPENDENTUNION：UNION</strong> 中的第二个或随后的 select 查询,依赖于外部查询的结果集</p></li><li><p><strong>DEPENDENTSUBQUERY</strong>：<strong>子查询</strong>中的第一个 select 查询,依赖于外部查询的结果集</p></li><li><p><strong>DERIVED</strong>：用于 from 子句里有子查询的情况。 MySQL 会 递归执行这些子查询, 把结果放在临时表里。</p></li></ul><h4 id="2-4-3-table"><strong>2.4.3 table</strong></h4><p>不论我们的查询语句有多复杂，里边包含了多少个表，到最后也是需要对每个表 进行单表访问的，MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。</p><img src="HTTP://zdwtop.cn/blog/image-20230314164547476.png" alt="image-20230314164547476" style="zoom:67%;"><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314164553572.png" alt="image-20230314164553572" style="zoom:67%;"></p><p>可以看见，只涉及对s1表的单表查询，所以EXPLAIN输出中只有一条记录，其中的table列的值是s1，而连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2.</p><h4 id="2-4-4-partitions">2.4.4 partitions</h4><p>和分区表有关，一般情况下我们的查询语句的执行计划的partitions列的值都是NULL。</p><h3 id="2-4-5-type"><strong>2.4.5 type</strong></h3><p>我们前边说过 执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法/访问类型，其中的type列就表明了这个访问方法/访问类型是个什么东西，是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>出现比较多的是    <code> system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></p><p>一般来说，<font color="blue"><strong>得保证查询至少达到range级别，最好能达到ref。</strong></font></p><h4 id="2-4-5-1-system">2.4.5.1 system</h4><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_myisam;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314165235705.png" alt="image-20230314165235705"></p><p>当然，如果改成使用InnoDB存储引擎，试试看执行计划的type列的值是什么。</p><p><img src="HTTP://zdwtop.cn/blog/image-20230314165240265.png" alt="image-20230314165240265"></p><h4 id="2-4-5-2-const"><strong>2.4.5.2 const</strong></h4><p><font color="blue"><strong>就是当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const。</strong></font>因为只匹配一行数据，所以很快。</p><p>例如将主键置于where列表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">716</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314165636024.png" alt="image-20230314165636024"></p><p>B+树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的B+树叶子节点中的记录就是按照id列排序的。B+树矮胖，所以这样根据主键值定位一条记录的速度很快。类似的，我们根据唯一二级索引列来定位一条记录的速度也很快的，比如下边这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#伪<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time<span class="operator">=</span>’’ <span class="keyword">and</span> order_status<span class="operator">=</span>’’ <span class="keyword">and</span> expire_time<span class="operator">=</span>’’ ;</span><br></pre></td></tr></table></figure><p>这个查询的执行分两步，第一步先从<strong>u_idx_day_status</strong>对应的B+树索引中根据索引列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的用户记录。</p><p>MySQL把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：<font color="blue"><strong>const，意思是常数级别的，代价是可以忽略不计的。</strong></font></p><p>不过这种<strong>const访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时</strong>才有效，如果主键或者唯一二级索引是由多个列构成的话，组成索引的每一个列都是与常数进行等值比较时，这个const访问方法才有效。</p><p>对于唯一二级索引来说，查询该列为NULL值的情况比较特殊，因为唯一和二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说<strong>is null不可以使用const访问方法来执行。</strong></p><h4 id="2-4-5-3-eq-ref-连接查询">2.4.5.3 eq_ref 连接查询</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的〈如果<strong>该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较</strong>)，则对该被驱动表的访问方法就是eq_ref。</p><p>(<strong>驱动表与被驱动表：</strong> <strong>A表和B表join连接查询，如果通过A表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到B表中查询数据，然后合并结果。那么我们称A表为驱动表，B表为被驱动表</strong>)</p><p>比方说:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id = s2.id;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314172316367.png" alt="image-20230314172316367"></p><p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref，表明在访问s1表的时候可以通过主键的等值匹配来进行访问。</p><h4 id="2-4-5-4-ref"><strong>2.4.5.4 ref</strong></h4><p><font color="blue"><strong>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref。</strong></font></p><p>本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他属于查找和扫描的混合体</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314172518630.png" alt="image-20230314172518630"></p><p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的id值，然后再回表到聚簇索引中查找完整的用户记录。</p><p>由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记  录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以MySQL可能选择使用索引而不是全表扫描的方式来执行查询。这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：ref。</p><p><strong>对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种ref访问方法比const要差些，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的</strong>（如果匹配的二级索引记录太多那么回表的成本就太大了）。</p><h4 id="2-4-5-5-range">2.4.5.5 range</h4><p><font color="blue"><strong>如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。</strong></font></p><p>这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>); EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314173014169.png" alt="image-20230314173014169"></p><p>这种利用索引进行范围匹配的访问方法称之为：range。</p><p>此处所说的使用索引进行范围匹配中的 索引 可以是聚簇索引，也可以是二级索引。</p><h4 id="2-4-5-6-index"><strong>2.4.5.6 index</strong></h4><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> insert_time <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:36:47&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314173032226.png" alt="image-20230314173032226"></p><h4 id="2-4-5-7-all"><strong>2.4.5.7 all</strong></h4><p><strong>最熟悉的全表扫描，将遍历全表以找到匹配的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314173048781.png" alt="image-20230314173048781"></p><h4 id="2-4-6-possible-keys与key"><strong>2.4.6 possible_keys与key</strong></h4><p>在EXPLAIN 语句输出的执行计划中,possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。比方说下边这个查询:。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> order_note <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:36:47&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314173101529.png" alt="image-20230314173101529"></p><p>上述执行计划的possible keys列的值表示该查询可能使用到u_idx_day_status,idx_insert_time两个索引，然后key列的值是u_idx_day_status，表示经过查询优化器计算使用不同索引的成本后，最后决定使用u_idx_day_status来执行查询比较划算。</p><h4 id="2-4-7-key-len"><strong>2.4.7 key_len</strong></h4><p><strong>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，计算方式是这样的：</strong></p><p>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8，那么该列实际占用的最大存储空间就是100 x 3 = 300个字节。</p><p><font color="blue"><strong>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。</strong></font></p><p>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</p><p>⽐如下边这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">718</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314173238109.png" alt="image-20230314173238109"></p><p>由于id列的类型是bigint，并且不可以存储NULL值，所以在使用该列的索引时ke  y_len大小就是8。</p><p>对于可变长度的索引列来说，比如下边这个查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314173308431.png" alt="image-20230314173308431"></p><p>由于order_no列的类型是VARCHAR(50)，所以该列实际最多占用的存储空间就是50*3字节，又因为该列是可变长度列，所以key_len需要加2，所以最后ken_len的值就是152。</p><p>MySQL在执行计划中输出key_len列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列(复合索引有最左前缀的特性，如果复合索引能全部使用上，则是复合索引字段的索引长度之和，这也可以用来判定复合索引是否部分使用，还是全部使用)，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。</p><h4 id="2-4-8-rows"><strong>2.4.8 rows</strong></h4><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。比如下边两个个查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>; EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314173434845.png" alt="image-20230314173434845"></p><p>我们看到执行计划的rows列的值是分别是1和10573，这意味着查询优化器在经过分析使用idx_order_no进行查询的成本之后，觉得满足order_no&gt; ’ z '这个条件的记录只有1条，觉得满足order_no&gt; ’ a '这个条件的记录有10573条。</p><h4 id="2-4-9-filtered"><strong>2.4.9 filtered</strong></h4><p>查询优化器预测有多少条记录满⾜其余的搜索条件，什么意思呢？看具体的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">5890</span> <span class="keyword">AND</span> order_note <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从执行计划的key列中可以看出来，该查询使用 PRIMARY索引来执行查询，从rows列可以看出满足id &gt; 5890的记录有5286条。执行计划的filtered列就代表查询优化器预测在这5286条记录中，有多少条记录满足其余的搜索条件，也就是order_note = 'a’这个条件的百分比。此处filtered列的值是10.0，说明查询优化器预测在5286条记录中有10.00%的记录满足order_note = 'a’这个条件。</p><p>对于单表查询来说，这个filtered列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的filtered值，比方说下边这个查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.order_no <span class="operator">=</span> s2.order_no <span class="keyword">WHERE</span> s1.order_note <span class="operator">&gt;</span> <span class="string">&#x27;你好，李焕英&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230314173456971.png" alt="image-20230314173456971"></p><p>从执行计划中可以看出来，查询优化器打算把s1当作驱动表，s2当作被驱动表。我们可以看到驱动表s1表的执行计划的rows列为10573，filtered列为33.33 ，这意味着驱动表s1的扇出值就是10573 x 33.33 % = 3524.3，这说明还要对被驱动表执行大约3524次查询。</p><h4 id="2-4-10-Extra"><strong>2.4.10 Extra</strong></h4><p>顾名思义，Extra列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句</p><h2 id="3-查询优化器"><strong>3. 查询优化器</strong></h2><p>在查询过程中会经历查询优化器的优化。</p><p>一条SQL语句在MySQL执行的过程如下：<a href="note://WEB3e268b96236aa0be2836098b82f482b6">一条sql的执行</a></p><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314173545770.png" alt="image-20230314173545770"></p><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p></li><li><ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314173551430.png" alt="image-20230314173551430"></p><p>1.如果是查询语句（select语句），首先会查询缓存是否已有相应结果，有则返回结果，无则进行下一步（如果不是查询语句，同样调到下一步）</p><p>2.解析查询，创建一个内部数据结构（解析树），这个解析树主要用来SQL语句的语义与语法解析；</p><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>3.执行 SQL：优化SQL语句，例如重写查询，决定表的读取顺序，以及选择需要的索引等。这一阶段用户是可以查询的，查询服务器优化器是如何进行优化的，便于用户重构查询和修改相关配置，达到最优化。一阶段还涉及到存储引擎，优化器会询问存储引擎，比如某个操作的开销信息、是否对特定索引有查询优化等。</p><p>每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li><p>prepare 阶段，也就是预处理阶段；</p></li><li><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li></ul></li><li><ul><li>将 select * 中的 * 符号，扩展为表上的所有列；</li></ul></li><li><p>optimize 阶段，也就是优化阶段；</p></li><li><ul><li>重写查询，决定表的读取顺序，以及选择需要的索引</li></ul></li><li><p>execute 阶段，也就是执行阶段；</p></li><li><ul><li>这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;MySQL执行计划&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;2-Explain执行计划&quot;&gt;&lt;strong&gt;2. Explain执行计划&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;2-1-什么是执行计划&quot;&gt;&lt;strong&gt;2.1. 什么是执行计划&lt;/s</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="执行计划" scheme="https://eizo01.github.io/tags/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>MySQL慢查询</title>
    <link href="https://eizo01.github.io/posts/b141163c.html"/>
    <id>https://eizo01.github.io/posts/b141163c.html</id>
    <published>2022-10-09T12:30:00.000Z</published>
    <updated>2022-10-21T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>MySQL调优金字塔</strong></h1><p>整体介绍MySQL的调优的选择，简单了解即可。</p><p><img src="HTTP://zdwtop.cn/blog/image-20230314174431189.png" alt="image-20230314174431189"></p><p>很明显从图上可以看出，越往上走，难度越来越高，收益却是越来越小的。</p><p>对于<strong>架构调优</strong>，在系统设计时首先需要充分考虑业务的实际情况，是否可以把不适合数据库做的事情放到数据仓库、搜索引擎或者缓存中去做；然后考虑写的并发量有多大，是否需要采用分布式；最后考虑读的压力是否很大，是否需要读写分离。对于核心应用或者金融类的应用，需要额外考虑数据安全因素，数据是否不允许丢失。所以在进行优化时，首先需要关注和优化的应该是架构，如果架构不合理，即使是DBA能做的事情其实是也是比较有限的。</p><p>对于<strong>MySQL调优</strong>，需要确认业务表结构设计是否合理，SQL语句优化是否足够，该添加的索引是否都添加了，是否可以剔除多余的索引等等</p><p>比如<strong>硬件和OS调优</strong>，需要对硬件和OS有着非常深刻的了解，仅仅就磁盘一项来说，一般非DBA能想到的调整就是SSD盘比用机械硬盘更好。DBA级别考虑的至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是XFS），操作系统的磁盘调度算法选择，是否需要调整操作系统文件管理方面比如atime属性等等。</p><p>所以本章我们重点关注MySQL方面的调优，特别是索引。SQL/索引调优要求对业务和数据流非常清楚。</p><blockquote><p>在阿里巴巴内部，有三分之二的DBA是业务DBA，从业务需求讨论到表结构审核、SQL语句审核、上线、索引更新、版本迭代升级，甚至哪些数据应该放到非关系型数据库中，哪些数据放到数据仓库、搜索引擎或者缓存中，都需要这些DBA跟踪和复审。他们甚至可以称为数据架构师（Data Architecher）。</p></blockquote><h2 id="1-查询性能优化"><strong>1. 查询性能优化</strong></h2><p>前面的章节我们知道如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说是必不可少的。但这些还不够—还需要合理的设计查询。如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。</p><p>慢查询基础 -优化数据访问</p><ul><li>查询不需要的记录</li><li>取出全部的列</li><li>重复查询相同的数据  -redis缓存</li></ul><p>是否扫面额外的记录</p><ul><li>响应时间  服务时间 + 排队时间</li><li>扫描的行数和返回的行数</li><li>扫描的行数和访问类型</li></ul><p>1、使用覆盖索引 2、数据表结构 统计汇总 报表 汇总信息（汇总表）</p><p>3、重写复杂的查询SQL</p><h3 id="1-1-什么是慢查询">1.1 什么是慢查询</h3><p>慢查询日志，顾名思义，就是查询花费大量时间的日志，是指mysql记录所有执行超过<strong>long_query_time</strong>参数设定的时间阈值的SQL语句的日志。该日志能为SQL语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要使用慢查询日志功能，首先要开启慢查询日志功能。如何开启，我们稍后再说。</p><h4 id="1-1-2-慢查询基础-优化数据访问">1.1.2 慢查询基础-优化数据访问</h4><p>查询性能低下最基本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，一般通过下面两个步骤来分析总是很有效:</p><ol><li><p>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。</p></li><li><p>确认MySQL服务器层是否在分析大量超过需要的数据行。</p></li></ol><h4 id="1-1-3-请求了不需要的数据？"><strong>1.1.3 请求了不需要的数据？</strong></h4><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。比如:</p><h5 id="查询不需要的记录"><strong>查询不需要的记录</strong></h5><p>一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。我们经常会看到一些了解其他数据库系统的人会设计出这类应用程序。</p><img src="HTTP://zdwtop.cn/blog/image-20230314160139644.png" alt="image-20230314160139644" style="zoom:50%;"><img src="HTTP://zdwtop.cn/blog/image-20230314160146155.png" alt="image-20230314160146155" style="zoom:50%;"><p>以上SQL你认为MySQL会执行查询，并只返回他们需要的20条数据，然后停止查询。实际情况是MySQL会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中大部分数据。</p><h5 id="总是取出全部列"><strong>总是取出全部列</strong></h5><p>每次看到<code>SELECT*</code>的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必需的。<font color="blue"><strong>取出全部列，会让优化器无法完成索引覆盖扫描这类优化,还会为服务器带来额外的I/O、内存和CPU的消耗。</strong></font>因此，一些工作场景是严格禁止SELECT *的写法的，这样做有时候还能避免某些列被修改带来的问题。</p><p><strong>尤其是使用二级索引，使用*的方式会导致回表，导致性能低下。</strong></p><p>什么时候可以使用SELECT*如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可rr能有其好处，但不要忘记这样做的代价是什么。获取并缓存所有的列的查询，相比多个独立的只获取部分列的查询可能就更有好处。</p><h5 id="重复查询相同的数据"><strong>重复查询相同的数据</strong></h5><p>不断地重复执行相同的查询，然后每次都返回完全相同的数据。比较好的方案是，当初次查询的时候将这个数据<strong>缓存</strong>起来，需要的时候从缓存中取出，这样性能显然会更好。</p><h4 id="1-1-4-是否在扫描额外的记录">1.1.4 是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下:</p><h5 id="响应时间、扫描的行数、返回的行数"><strong>响应时间、扫描的行数、返回的行数</strong></h5><p>没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p><ul><li><strong>响应时间</strong></li></ul><p>响应时间是两个部分之和:服务时间和排队时间。</p><p>服务时间是指数据库处理这个查询真正花了多长时间。</p><p>排队时间是指服务器因为等待某些资源而没有真正执行查询的时间—-可能是等I/O操作完成，也可能是等待行锁，等等。</p><ul><li><strong>扫描的行数和返回的行数</strong></li></ul><p>分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。</p><p>理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大。</p><ul><li><strong>扫描的行数和访问类型</strong></li></ul><p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。</p><p>在<strong>EXPLAIN语句中</strong>的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。你不需要记住这些访问类型，但需要明白<strong>扫描表、扫描索引、范围访问和单值访问的概念。</strong></p><blockquote><p>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引，为什么索引对于查询优化如此重要了。索引让 MySQL以最高效、扫描行数最少的方式找到需要的记录。</p></blockquote><p>一般 MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为:</p><ol><li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> .... <span class="keyword">from</span> <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">100</span> <span class="keyword">and</span> a <span class="operator">&lt;</span><span class="number">200</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用覆盖索引扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在 MySQL服务器层完成的，但无须再回表查询记录。</p></li><li><p>从数据表中返回数据(存在回表)，然后过滤不满足条件的记录。这在 MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</p></li></ol><p>好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。</p><p><strong>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它:</strong></p><p>1、使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</p><p>2、改变库表结构。例如使用单独的汇总表。</p><p>3、重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p><h3 id="1-2-慢查询"><strong>1.2 慢查询</strong></h3><p><strong>1.3.3.1慢查询配置</strong></p><p>我们已经知道慢查询日志可以帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。但是默认值为关闭的，需要我们手动开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="HTTP://zdwtop.cn/blog/image-20230314161024083.png" alt="image-20230314161024083" style="zoom:67%;"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>开启1，关闭0</p><p>但是多慢算慢？MySQL中可以设定一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志中。<code>long_query_time</code>参数就是这个阈值。<strong>默认值为10</strong>，代表10秒。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line">#当然也可以设置</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"># 默认<span class="number">10</span>秒，这里为了演示方便设置为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>同时对于运行的SQL语句没有使用索引，则MySQL数据库也可以将这条SQL语句记录到慢查询日志文件，控制参数是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%log_queries_not_using_indexes%&#x27;</span>;#开启<span class="number">1</span>，关闭<span class="number">0</span>（默认）</span><br><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log_file%&#x27;</span>;#慢查询日志文件名字</span><br></pre></td></tr></table></figure><img src="HTTP://zdwtop.cn/blog/image-20230314161404029.png" alt="image-20230314161404029" style="zoom:67%;">    <img src="HTTP://zdwtop.cn/blog/image-20230314161157667.png" alt="image-20230314161157667" style="zoom:67%;"><p>小结</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log #启动停止慢查询日志</span><br><span class="line"></span><br><span class="line">slow_query_log_file #指定慢查询日志得存储路径及文件（默认和数据文件放一起）</span><br><span class="line"></span><br><span class="line">long_query_time #指定记录慢查询日志<span class="keyword">SQL</span>执行时间得伐值（单位：秒，默认<span class="number">10</span>秒）</span><br><span class="line"></span><br><span class="line">log_queries_not_using_indexes  #是否记录未使用索引的<span class="keyword">SQL</span></span><br><span class="line"></span><br><span class="line">llog_output #日志存放的地方可以是<span class="keyword">TABLE</span>[FILE,<span class="keyword">TABLE</span>]</span><br></pre></td></tr></table></figure><p>ps:由于篇幅过长，执行计划请下一篇文章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;MySQL调优金字塔&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;整体介绍MySQL的调优的选择，简单了解即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;HTTP://zdwtop.cn/blog/image-20230314174431189.png&quot; alt=&quot;ima</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="慢查询" scheme="https://eizo01.github.io/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>高性能的索引创建策略</title>
    <link href="https://eizo01.github.io/posts/5ae93cc9.html"/>
    <id>https://eizo01.github.io/posts/5ae93cc9.html</id>
    <published>2022-10-06T12:00:00.000Z</published>
    <updated>2022-10-06T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>高性能的索引使用策略</strong></h1><p>今天要用到的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `order_exp`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_exp` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">22</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单的主键&#x27;</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的编号&#x27;</span>,</span><br><span class="line">  `order_note` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的说明&#x27;</span>,</span><br><span class="line">  `insert_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;插入订单的时间&#x27;</span>,</span><br><span class="line">  `expire_duration` <span class="type">bigint</span>(<span class="number">22</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的过期时长，单位秒&#x27;</span>,</span><br><span class="line">  `expire_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的过期时间&#x27;</span>,</span><br><span class="line">  `order_status` <span class="type">smallint</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单的状态，0：未支付；1：已支付；-1：已过期，关闭&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `u_idx_day_status` (`insert_time`,`order_status`,`expire_time`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_order_no` (`order_no`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_expire_time` (`expire_time`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10819</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `order_exp_cut`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_exp_cut` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">22</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单的主键&#x27;</span>,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的编号&#x27;</span>,</span><br><span class="line">  `order_note` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的说明&#x27;</span>,</span><br><span class="line">  `insert_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;插入订单的时间&#x27;</span>,</span><br><span class="line">  `expire_duration` <span class="type">bigint</span>(<span class="number">22</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的过期时长，单位秒&#x27;</span>,</span><br><span class="line">  `expire_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的过期时间&#x27;</span>,</span><br><span class="line">  `order_status` <span class="type">smallint</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单的状态，0：未支付；1：已支付；-1：已过期，关闭&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `u_idx_day_status` (`insert_time`,`order_status`,`expire_time`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_order_no` (`order_no`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_expire_time` (`expire_time`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10819</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br></pre></td></tr></table></figure><h2 id="1-不在索引列上做任何操作"><strong>1. 不在索引列上做任何操作</strong></h2><p>我们通常会看到一些查询不当地使用索引，或者使得MySQL无法使用已有的索引。如果查询中的列不是独立的，则 MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p>例如，我们假设id上有主键索引，但是下面这个查询无法使用主键索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315210042935.png" alt="image-20230315210042935"></p><p>凭肉眼很容易看出 WHERE中的表达式其实等价于id= 16，但是MySQL无法自动解析这个方程式。这完全是用户行为。我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p><p>下面是另一个常见的错误:</p><p>在索引列上使用函数，也是无法利用索引的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(insert_time)<span class="operator">=</span><span class="keyword">YEAR</span>(DATE_SUB(NOW(),<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>));</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="keyword">BETWEEN</span> str_to_date(<span class="string">&#x27;01/01/2021&#x27;</span>, <span class="string">&#x27;%m/%d/%Y&#x27;</span>) <span class="keyword">and</span> str_to_date(<span class="string">&#x27;12/31/2021&#x27;</span>, <span class="string">&#x27;%m/%d/%Y&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315213106919.png" alt="image-20230315213106919"></p><p>利用联合索引,修改查询列</p><p><img src="https://zdwtop.cn/blog/image-20230315213455603.png" alt="image-20230315213455603"></p><h2 id="2-尽量全值匹配"><strong>2.尽量全值匹配</strong></h2><p>建立了联合索引列后，如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp </span><br><span class="line"><span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span>                                       </span><br><span class="line"><span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line"><span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们建立的u_idx_day_statusr索引包含的3个列在这个查询语句中都展现出来了，联合索引中的三个列都可能被用到。</p><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNIQUE</span> KEY `u_idx_day_status` (`insert_time`,`order_status`,`expire_time`) <span class="keyword">USING</span> BTREE,</span><br></pre></td></tr></table></figure></code></pre><p><img src="https://zdwtop.cn/blog/image-20230315213755786.png" alt="image-20230315213755786"></p><p>也许这里有个疑问，WHERE子句中的几个搜索条件的顺序对查询结果有啥影响么？</p><p>也就是说如果我们调换 insert_time, order_status, expire_time这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp </span><br><span class="line"><span class="keyword">where</span>  order_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line"><span class="keyword">and</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure><p>放心，MySQL没这么蠢，查询优化器会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。</p><p><img src="https://zdwtop.cn/blog/image-20230315214026869.png" alt="image-20230315214026869"></p><p>所以，当建立了联合索引列后，能在where条件中使用索引的尽量使用。</p><h2 id="3-最佳左前缀法则"><strong>3.最佳左前缀法则</strong></h2><p>建立了联合索引列，如果搜索条件不够全值匹配怎么办？在我们的搜索语句中也可以不用包含全部联合索引中的列，但要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p>搜索条件中必须出现左边的列才可以使用到这个B+树索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNIQUE</span> KEY `u_idx_day_status` (`insert_time`,`order_status`,`expire_time`) <span class="keyword">USING</span> BTREE,</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315214331538.png" alt="image-20230315214331538"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315214412145.png" alt="image-20230315214412145"></p><p><strong>只要出现左边的第一列就会开始使用索引！</strong></p><p>接下来请看这两个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_status<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315214535140.png" alt="image-20230315214535140"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> order_status<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315214903250.png" alt="image-20230315214903250"></p><p><strong>搜索条件中没有出现左边的列不可以使用到这个B+树索引。</strong></p><p><font color="\#87CEFA"><strong>那为什么搜索条件中必须出现左边的列才可以使用到这个B+树索引呢？比如下边的语句就用不到这个B+树索引么？</strong></font></p><p>因为B+树的数据页和记录先是按照insert_time列的值排序的，在insert_time列的值相同的情况下才使用order_status列进行排序，也就是说insert_time列的值不同的记录中order_status的值可能是无序的。</p><p>而现在你跳过insert_time列直接根据order_status的值去查找，怎么可能呢？expire_time也是一样的道理，那如果我就想在只使用expire_time的值去通过B+树索引进行查找咋办呢？这好办，你再对expire_time列建一个B+树索引就行了。</p><p>再补充一个之前讲索引的图：道理一样，补充一下细节</p><img src="https://zdwtop.cn/blog/image-20230315215236733.png" alt="image-20230315215236733" style="zoom:50%;"><p>但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。比方说联合索引<code>u_idx_day_status</code>中列的定义顺序是 insert_time, order_status, expire_time，<strong>如果我们的搜索条件中只有insert_time和expire_time，而没有中间的order_status。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp </span><br><span class="line"><span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315215504330.png" alt="image-20230315215504330"></p><p><strong>请注意key_len,只有5，说明只有insert_time用到了，其他的没有用到。</strong></p><h2 id="4-范围条件放最后"><strong>4.范围条件放最后</strong></h2><p>这一点，也是针对联合索引来说的，前面我们反复强调过，所有记录都是按照索引列的值从小到大的顺序排好序的，而<font color="\#87CEFA"><strong>联合索引则是按创建索引时的顺序进行分组排序。</strong></font></p><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> </span><br><span class="line">insert_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> insert_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315215926405.png" alt="image-20230315215926405"></p><p>由于B+树中的数据页和记录是先按insert_time列排序的，所以我们上边的查询过程其实是这样的：</p><ol><li><p>找到<code>insert_time</code>值为’2021-03-22 18:23:42’ 的记录。</p></li><li><p>找到<code>insert_time</code>值为’2021-03-22 18:35:00’的记录。</p></li></ol><p>由于所有记录都是由链表连起来的，所以他们之间的记录都可以很容易的取出来，找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</p><p>但是如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> </span><br><span class="line">insert_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> insert_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> order_status <span class="operator">&gt;</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>为什么这里key_len 是 6呢？你可以回到开头查看，insert_time为空，行格式是多1个字节存储的。行格式以后会讲的。</p><p><img src="https://zdwtop.cn/blog/image-20230315215635123.png" alt="image-20230315215635123"></p><p>上边这个查询可以分成两个部分：</p><p>通过条件insert_time&gt;‘2021-03-22 18:23:42’ and insert_time&lt;‘2021-03-22 18:35:00’ 来对insert_time进行范围，查找的结果可能有多条insert_time值不同的记录，</p><p>然后 对这些insert_time值不同的记录继续通过order_status&gt;-1条件继续过滤。</p><p>这样子对于联合索引<code>u_idx_day_status</code>来说，只能用到insert_time列的部分，而用不到order_status列的部分（这里的key_len和之前的SQL的是一样长），因为只有insert_time值相同的情况下才能用order_status列的值进行排序，而这个查询中通过insert_time进行范围查找的记录中可能并不是按照order_status列进行排序的，所以在搜索条件中继续以order_status列进行查找时是用不到这个B+树索引的。</p><p><strong>所以对于一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line"><span class="keyword">and</span> expire_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:23:57&#x27;</span> <span class="keyword">and</span> expire_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315220600614.png" alt="image-20230315220600614"></p><p><strong>而中间有范围查询会导致后面的列全部失效，无法充分利用这个联合索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut </span><br><span class="line"><span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span>  <span class="keyword">and</span> order_status<span class="operator">&gt;</span><span class="number">-1</span>  </span><br><span class="line"><span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315220614355.png" alt="image-20230315220614355"></p><p>​</p><h2 id="5-覆盖索引尽量用"><strong>5.覆盖索引尽量用</strong></h2><p>覆盖索引是非常有用的工具，能够极大地提高性能，三星索引里最重要的那颗星就是宽索引星。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处:</p><p>**索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MySQL就会极大地减少数据访问量。**这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小,更容易全部放入内存中。</p><p><strong>因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。</strong></p><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p><p><em><em>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，不是必要的情况下减少select</em>，除非是需要将表中的全部列检索后，进行缓存。</em>*</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut </span><br><span class="line"><span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:04&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315220738490.png" alt="image-20230315220738490"></p><p><strong>使用具体名称取代</strong>*</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">select</span> expire_time,order_status,expire_time <span class="keyword">from</span></span><br><span class="line">order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:04&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315220816672.png" alt="image-20230315220816672"></p><p><strong>解释一下Extra中的Using index</strong></p><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以<strong>使用索引覆盖的情况</strong>下，在Extra列将会提示该额外信息。以上的查询中只需要用到<code>u_idx_day_status</code>而不需要回表操作：</p><h2 id="6-不等于要慎用"><strong>6.不等于要慎用</strong></h2><p>mysql 在使用不等于(<code>!= 或者&lt;&gt;</code>)的时候无法使用索引<strong>会导致全表扫描</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315220918205.png" alt="image-20230315220918205"></p><p><strong>解释一下Extra中的Using where</strong>当我们使用<strong>全表扫描来执行对某个表的查询</strong>，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p><h2 id="7-Null-Not-有影响">7.Null/Not 有影响</h2><p>需要注意null/not null对索引的可能影响</p><p><strong>表order_exp的order_no为索引列，同时不允许为null，</strong></p><p><img src="https://zdwtop.cn/blog/image-20230315221009568.png" alt="image-20230315221009568"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315221032536.png" alt="image-20230315221032536"></p><p><img src="https://zdwtop.cn/blog/image-20230315221047735.png" alt="image-20230315221047735"></p><p>可以看见，<code>order_no is null</code>的情况下，<strong>MySQL直接表示Impossible WHERE(查询语句的WHERE子句永远为FALSE时将会提示该额外信息)，对于 is not null直接走的全表扫描。</strong></p><p><strong>表order_exp_cut的order_no为索引列，同时允许为null，</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> order_no <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> order_no <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315221138170.png" alt="image-20230315221138170"></p><p><img src="https://zdwtop.cn/blog/image-20230315221838213.png" alt="image-20230315221838213"></p><p><strong>is null会走ref类型的索引访问，is not null;依然是全表扫描。</strong></p><p>所以总结起来：</p><p><font color="\#87CEFA"><strong>is not null容易导致索引失效，is null则会区分被检索的列是否为null，如果是null则会走ref类型的索引访问，如果不为null，也是全表扫描。</strong></font></p><p><strong>但是当联合索引上使用时覆盖索引时，情况会有一些不同(order_exp_cut表的order_no可为空)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> order_status,expire_time <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> order_status,expire_time <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315221300009.png" alt="image-20230315221300009"></p><p><img src="https://zdwtop.cn/blog/image-20230315221324650.png" alt="image-20230315221324650"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> order_status,expire_time <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> insert_time <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> order_status,expire_time <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> insert_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315221504553.png" alt="image-20230315221504553"></p><p><font color="\#87CEFA"><strong>根据system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL 的原则，看起来在联合索引中，is not null的<code>order_exp_cut</code>表现会更好（如果列可为null的话），但是key_len的长度增加了1。所以总的来说，在设计表时列尽可能的不要声明为null。</strong></font></p><p><strong>省流：列不要设置为空</strong></p><h2 id="8-Like查询要当心"><strong>8.Like查询要当心</strong></h2><p>like以通配符开头(‘%abc…’)，mysql索引失效会变成全表扫描的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="keyword">like</span> <span class="string">&#x27;%_6S&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315221957524.png" alt="image-20230315221957524"></p><p>此时如果使用覆盖索引可以改善这个问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> order_status,expire_time <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> insert_time <span class="keyword">like</span> <span class="string">&#x27;%18:35:09&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315222033090.png" alt="image-20230315222033090"></p><p>​</p><h2 id="9-字符类型加引号"><strong>9.字符类型加引号</strong></h2><p>字符串不加单引号索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315222104653.png" alt="image-20230315222104653"></p><p><img src="https://zdwtop.cn/blog/image-20230315222111152.png" alt="image-20230315222111152"></p><p><strong>MySQL的查询优化器，会自动的进行类型转换，比如上个语句里会尝试将order_no转换为数字后和6进行比较，自然造成索引失效。</strong></p><h2 id="10-使用or关键字时要注意"><strong>10.使用or关键字时要注意</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> expire_time<span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span>  <span class="keyword">OR</span> order_note <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315222200433.png" alt="image-20230315222200433"></p><p><strong>表现是不一样的，第一个SQL的or是相同列，相当于产生两个扫描区间，可以使用上索引。</strong></p><p>第二个SQL中or是不同列，并且order_note不是索引。所以只能全表扫描</p><p>当然如果两个条件都是索引列，情况会有变化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp </span><br><span class="line"><span class="keyword">WHERE</span> expire_time<span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span>  <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;DD00_6S&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315222303244.png" alt="image-20230315222303244"></p><p>这也给了我们提示，如果我们将 SQL改成<strong>union all</strong></p><p><strong>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> expire_time<span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span>                  </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_note <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>当然使用覆盖扫描也可以改善这个问题：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> order_status,id <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> </span><br><span class="line">insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">or</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:28:28&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315222423696.png" alt="image-20230315222423696"></p><h2 id="11-使用索引扫描来做排序和分组"><strong>11.使用索引扫描来做排序和分组</strong></h2><p>MySQL有两种方式可以生成有序的结果﹔通过排序操作﹔或者按索引顺序扫描施﹔</p><p>如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。</p><p>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在IO密集型的工作负载时。</p><p>MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。</p><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当0RDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</p><h2 id="12-排序要当心"><strong>12.排序要当心</strong></h2><p><strong>ASC升序、DESC降序别混用</strong></p><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。</p><p><strong>排序列包含非同一个索引的列不能使用索引进行排序</strong></p><p>用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">order_no,insert_time;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315222754337.png" alt="image-20230315222754337"></p><h2 id="13-尽可能按主键顺序插入行"><strong>13.尽可能按主键顺序插入行</strong></h2><p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕，它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</p><p>最简单的方法是使用<code>AUTO_INCREMENT</code>自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。</p><p><strong>注意到向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长﹔另一方面毫无疑问是由于页分裂和碎片导致的。</strong></p><p>因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时(InnoDB默认的最大填充因子是页大小的15/16，留出部分空间用于以后修改)，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载,主键页就会近似于被顺序的记录填满,这也正是所期望的结果。</p><p>如果新行的主键值不一定比之前插入的大，所以InnoDB无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置-—通常是已有数据的中间位置——并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化。下面是总结的一些缺点:</p><p>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机IO。</p><p>因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p><p><strong>所以使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。</strong></p><h2 id="14-优化Count查询"><strong>14.优化Count查询</strong></h2><p>首先要注意，<strong>COUNT()是一个特殊的函数</strong>，有两种非常不同的作用:<strong>它可以统计某个列值的数量，也可以统计行数。</strong></p><p><strong>在统计列值时要求列值是非空的（不统计NULL)。</strong></p><p><strong>COUNT()的另一个作用是统计结果集的行数。常用的就是就是当我们使用COUNT(*)。实际上，它会忽略所有的列而直接统计所有的行数。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(c1) <span class="keyword">from</span> test;</span><br></pre></td></tr></table></figure><img src="https://zdwtop.cn/blog/image-20230315223058262.png" alt="image-20230315223058262" style="zoom:50%;"><p>通常来说，COUNT()都需要扫描大量的行（意味着要访问大量数据）才能获得精确的结果，因此是很难优化的。**在MySQL层面能做的基本只有索引覆盖扫描了。**如果这还不够,就需要考虑修改应用的架构，可以用估算值取代精确值，可以增加汇总表，或者增加类似Redis这样的外部缓存系统。</p><h2 id="15-优化limit分页"><strong>15.优化limit分页</strong></h2><p>在系统中需要进行分页操作的时候，我们通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY子句。</p><p>一个非常常见又令人头疼的问题就是，在偏移量非常大的时候，例如可能是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp limit <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这样的查询，这时MySQL需要查询10010条记录然后只返回最后10条，前面10000条记录都将被抛弃，这样的代价非常高。</p><p>优化此类分页查询的一个最简单的办法是</p><p>会先查询翻页中需要的N条数据的主键值，然后根据主键值回表查询所需要的N条数据，在此过程中查询N条数据的主键id在索引中完成，所以效率会高一些。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">select</span> id <span class="keyword">from</span> order_exp limit <span class="number">10000</span>,<span class="number">10</span>) b,order_exp a</span><br><span class="line"><span class="keyword">where</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315223241334.png" alt="image-20230315223241334"></p><p>从执行计划中可以看出，首先执行子查询中的order_exp表，根据主键做索引全表扫描，然后与a表通过id做主键关联查询，相比传统写法中的全表扫描效率会高一些。</p><p>上面已经是官方推荐的方法，通过覆盖索引 和 子查询优化， 业务上可以怎么优化？</p><p>从两种写法上能看出性能有一定的差距，虽然并不明显，但是随着数据量的增大，两者执行的效率便会体现出来。</p><p>上面的写法虽然可以达到一定程度的优化，但还是存在性能问题。最佳的方式是在业务上进行配合修改为以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">67</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315224116974.png" alt="image-20230315224116974"></p><p>采用这种写法，需要前端通过点击More来获得更多数据，而不是纯粹的翻页，因此，每次查询只需要使用上次查询出的数据中的id来获取接下来的数据即可，但这种写法需要业务配合。</p><h2 id="16-关于Null的特别说明"><strong>16.关于Null的特别说明</strong></h2><p>对于Null到底算什么，存在着分歧：</p><ol><li>有的认为NULL值代表一个未确定的值，MySQL认为<strong>任何和NULL值做比较的表达式的值都为NULL</strong>，包括<code>select null=null</code>和<code>select null!=null</code>;</li></ol><img src="https://zdwtop.cn/blog/image-20230315224233884.png" alt="image-20230315224233884" style="zoom:50%;"><ol start="2"><li><p>有的认为其实NULL值在业务上就是代表没有，所有的NULL值和起来算一份；</p></li><li><p>有的认为这NULL完全没有意义，所以在统计数量时压根儿不能把它们算进来。</p></li></ol><p>假设一个表中某个列c1的记录为(2,1000,null,null)，在第一种情况下，表中c1的记录数为4，第二种表中c1的记录数为3，第三种表中c1的记录数为2。</p><p>在对统计索引列不重复值的数量时如何对待NULL值，MySQL专门提供了一个<code>innodb_stats_method</code>的系统变量，</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method">https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method</a></p><p><strong>这个系统变量有三个候选值：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nulls<span class="emphasis">_equal：认为所有NULL值都是相等的。这个值也是innodb_</span>stats<span class="emphasis">_method的默认值。</span></span><br><span class="line"><span class="emphasis">如果某个索引列中NULL值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。</span></span><br><span class="line"><span class="emphasis">nulls_</span>unequal：认为所有NULL值都是不相等的。</span><br><span class="line">如果某个索引列中NULL值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。</span><br><span class="line">nulls<span class="emphasis">_ignored：直接把NULL值忽略掉。</span></span><br></pre></td></tr></table></figure><p>在MySQL5.7.22以后的版本，对这个<code>innodb_stats_method</code>的修改不起作用，MySQL把这个值在代码里写死为nulls_equal。</p><p>也就是说MySQL在进行索引列的数据统计行为又把null视为第二种情况（NULL值在业务上就是代表没有，所有的NULL值和起来算一份），看起来，MySQL中对Null值的处理也很分裂。所以总的来说，对于列的声明尽可能的不要允许为null。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;高性能的索引使用策略&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;今天要用到的表&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="索引" scheme="https://eizo01.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>高性能的索引创建策略</title>
    <link href="https://eizo01.github.io/posts/5ae93cc9.html"/>
    <id>https://eizo01.github.io/posts/5ae93cc9.html</id>
    <published>2022-10-05T12:00:00.000Z</published>
    <updated>2022-10-05T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>高性能的索引创建策略</strong></h1><p>正确地创建和使用索引是实现高性能查询的基础。前面的文章我们已经了解了索引相关的数据结构，各种类型的索引及其对应的优缺点。现在我们一起来看看如何真正地发挥这些索引的优势。</p><h2 id="1…索引列的类型尽量小"><strong>1…索引列的类型尽量小</strong></h2><p>这个可以参考 <a href="https://javazdw.top/posts/86b66af2.html"><strong>字段数据类型优化</strong></a>这篇文章</p><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TTNYINT、NEDUMNT、INT、BIGTNT这么几种，它们占用的存储空间依次递增，我们这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用NEDIUMINT就不要使用INT，这是因为数据类型越小，在查询时进行的比较操作越快（CPU层次)数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p><p><font color="\#87CEFA"><strong>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。</strong></font></p><h2 id="2-索引的选择性"><strong>2.索引的选择性</strong></h2><p>**创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality)和数据表的记录总数（N)的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。**唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>很差的索引选择性就是列中的数据重复度很高，比如性别字段，不考虑政治正确的情况下，只有两者可能，男或女。那么我们在查询时，即使使用这个索引，从概率的角度来说，依然可能查出一半的数据出来。</p><p><img src="https://zdwtop.cn/blog/image-20230315184507246.png" alt="image-20230315184507246"></p><p>哪列做为索引字段最好？当然是姓名字段，因为里面的数据没有任何重复，性别字段是最不适合做索引的，因为数据的重复度非常高。</p><p>怎么算索引的选择性/离散性？比如person这个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> name)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span><span class="operator">*</span>) <span class="keyword">FROM</span> person;<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> sex)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span><span class="operator">*</span>) <span class="keyword">FROM</span> person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> age)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span><span class="operator">*</span>) <span class="keyword">FROM</span> person;<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>  area)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span><span class="operator">*</span>) <span class="keyword">FROM</span> person;</span><br></pre></td></tr></table></figure><h2 id="3-前缀索引"><strong>3.前缀索引</strong></h2><p><font color="\#87CEFA"> **针对blob、text、很长的varchar字段，mysql不支持索引他们的全部长度，需建立前缀索引。 **</font></p><p><strong>语法：<code>Alter table tableName add key/index (column(X))      </code></strong></p><p>**优点：**前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p>**有时候后缀索引 (suffixindex)也有用途（例如，找到某个域名的所有电子邮件地址)。**MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器或者应用程序自行处理来维护索引。</p><p>案例：</p><p>这里是一张电影订单记录表</p><p><img src="https://zdwtop.cn/blog/image-20230315185543570.png" alt="image-20230315185543570"></p><p>首先找到最常见的值的列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note,<span class="number">3</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel3,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note,<span class="number">4</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span> sel4,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel5,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">6</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel6,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">7</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel7,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">8</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel8,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">9</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel9,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">10</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel10,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">11</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel11,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">12</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel12,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">13</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel13,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">14</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel14,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(order_note, <span class="number">15</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> sel15,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> order_note)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">As</span> total</span><br><span class="line"><span class="keyword">FROM</span> order_exp;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315185559295.png" alt="image-20230315185559295"></p><p>可以看见，从第10个开始选择性的增加值很高，随着前缀字符的越来越多，选择度也在不断上升，但是增长到第15时，已经和第14没太大差别了，选择性提升的幅度已经很小了，都非常接近整个列的选择性了。</p><p><strong>那么针对这个字段做前缀索引的话，从第13到第15都是不错的选择</strong></p><p>在上面的示例中，已经找到了合适的前 缀长度，如何创建前缀索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> order_exp <span class="keyword">ADD</span> KEY (order_note(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>建立前缀索引后查询语句并不需要更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> order_note <span class="operator">=</span> <span class="string">&#x27;xxxx&#x27;</span> ;</span><br></pre></td></tr></table></figure><h2 id="4-只为用于搜索、排序或分组的列创建索引"><strong>4.只为用于搜索、排序或分组的列创建索引</strong></h2><p>也就是说，只为出现在WHERE 子句中的列、连接子句中的连接列创建索引，而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引；又或者为出现在ORDER BY或GROUP BY子句中的列创建索引，这句话什么意思呢？比如：</p><p><strong>搜索</strong></p><p>只为 <strong>条件中的列</strong>建立索引即可:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_note <span class="keyword">from</span> <span class="keyword">where</span> .... <span class="keyword">and</span> ....</span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">ORDER</span> <span class="keyword">BY</span> insert_time, order_status,expire_time;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/image-20230315185937120.png" alt="image-20230315185937120"></p><p>查询的结果集需要先按照<code>insert_time</code>值排序，**如果记录的insert_time值相同，则需要按照order_status来排序，如果order_status的值相同，则需要按照expire_time排序。**回顾一下联合索引的存储结构，<code>u_idx_day_status</code>索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。</p><p><img src="https://zdwtop.cn/blog/image-20230315185948824.png" alt="image-20230315185948824"></p><h2 id="5-多列索引"><strong>5.多列索引</strong></h2><p>很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p><p>我们遇到的最容易引起困惑的问题就是索引列的顺序。正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p><p><strong>反复强调过，在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。</strong></p><p>所以多列索引的列顺序至关重要。对于如何选择索引的列顺序有一个经验法则：<font color="\#87CEFA"> <strong>将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。</strong></font>这时候索引的作用只是用于优化WHERE条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在WHERE子句中只使用了索引部分前缀列的查询来说选择性也更高。</p><p>然而，性能不只是依赖于索引列的选择性，也和查询条件的有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，比如排序和分组，让这种情况下索引的选择性最高。</p><p>同时，在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p><h2 id="6-三星索引"><strong>6.三星索引</strong></h2><p><strong>三星索引概念</strong></p><p>对于一个查询而言，一个三星索引，可能是其最好的索引。</p><p>满足的条件如下：</p><ul><li><p>索引将相关的记录放到一起则获得一星    （比重27%）</p></li><li><p>如果索引中的数据顺序和查找中的排列顺序一致则获得二星（排序星） （比重27%）</p></li><li><p>如果索引中的列包含了查询中需要的全部列则获得三星（宽索引星） （比重50%）</p></li></ul><p>这三颗星，哪颗最重要？第三颗星。因为将一个列排除在索引之外可能会导致很多磁盘随机读（回表操作）。第一和第二颗星重要性差不多，可以理解为第三颗星比重是50%，第一颗星为27%，第二颗星为23%，所以在大部分的情况下，会先考虑第一颗星，但会根据业务情况调整这两颗星的优先度。</p><p><strong>一星：</strong></p><p>一星的意思就是：如果一个查询相关的索引行是相邻的或者至少相距足够靠近的话，必须扫描的索引片宽度就会缩至最短，也就是说，让索引片尽量变窄，也就是我们所说的索引的扫描范围越小越好。</p><p><strong>二星（排序星）</strong> ：</p><p>在满足一星的情况下，当查询需要排序，group by、 order by，如果查询所需的顺序与索引是一致的（索引本身是有序的），是不是就可以不用再另外排序了，一般来说排序可是影响性能的关键因素。</p><p><strong>三星（宽索引星）</strong> ：</p><p>在满足了二星的情况下，如果索引中所包含了这个查询所需的所有列（包括 where 子句和 select 子句中所需的列，也就是覆盖索引），这样一来，查询就不再需要回表了，减少了查询的步骤和IO请求次数，性能几乎可以提升一倍。</p><h2 id="7-设计三星索引实战"><strong>7.设计三星索引实战</strong></h2><p><strong>现在有表，SQL如下</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    cno <span class="type">INT</span>,</span><br><span class="line">    lname <span class="type">VARCHAR</span> (<span class="number">10</span>),</span><br><span class="line">    fname <span class="type">VARCHAR</span> (<span class="number">10</span>),</span><br><span class="line">    sex <span class="type">INT</span>,</span><br><span class="line">    weight <span class="type">INT</span>,</span><br><span class="line">    city <span class="type">VARCHAR</span> (<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cust <span class="keyword">ON</span> customer (city, lname, fname, cno);</span><br></pre></td></tr></table></figure><p>对于下面的SQL而言，这是个三星索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> cno,fname <span class="keyword">from</span> customer <span class="keyword">where</span> lname<span class="operator">=</span>’xx’ <span class="keyword">and</span> city <span class="operator">=</span>’yy’ <span class="keyword">order</span> <span class="keyword">by</span> fname;</span><br></pre></td></tr></table></figure><p>来评估下：</p><p><strong>第一颗星：所有等值谓词的列，是组合索引的开头的列，可以把索引片缩得很窄，符合。</strong></p><p>根据之前讲过的联合索引，我们是知道条件已经把搜索范围搜到很窄了，例如图中</p><p>​    <img src="https://zdwtop.cn/blog/image-20230315190526119.png" alt="image-20230315190526119" style="zoom:50%;"></p><p><strong>第二颗星：order by的fname字段在组合索引中且是索引自动排序好的，符合。</strong></p><p><strong>第三颗星：select中的cno字段、fname字段在组合索引中存在，符合。</strong></p><p><strong>现在有表，SQL如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">    `id` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `user_name` <span class="type">VARCHAR</span> (<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `sex` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_sex_age <span class="keyword">ON</span> test (user_name,sex,age);</span><br></pre></td></tr></table></figure><p><strong>如果我们建立索引(user_name,sex,age)：</strong></p><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,sex,age <span class="keyword">from</span> test </span><br><span class="line"><span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">&#x27;马%&#x27;</span>  </span><br><span class="line"><span class="keyword">and</span> sex <span class="operator">=</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age</span><br></pre></td></tr></table></figure><p>​    <img src="https://zdwtop.cn/blog/image-20230315191003735.png" alt="image-20230315191003735" style="zoom: 67%;"></p><img src="https://zdwtop.cn/blog/image-20230315191012650.png" alt="image-20230315191012650" style="zoom: 67%;"><p>第三颗星，满足</p><p>第一颗星，满足</p><p>第二颗星，不满足，user_name 采用了范围匹配，sex 是过滤列，此时age 列无法保证有序的。</p><p>上述我们看到，此时索引(user_name,sex,age)并不能满足三星索引中的第二颗星（排序）。</p><p><strong>于是我们改改，建立索引(sex, age，user_name)：</strong></p><p>​    <img src="https://zdwtop.cn/blog/image-20230315191445143.png" alt="image-20230315191445143" style="zoom:67%;"></p><p>第一颗星，不满足，只可以匹配到sex，sex选择性很差，意味着是一个宽索引片(同时因为age也会导致排序选择的碎片问题)</p><p>第二颗星，满足，等值sex 的情况下，age是有序的，</p><p>第三颗星，满足，select查询的列都在索引列中，</p><p>对于索引(sex,age，user_name)我们可以看到，此时无法满足第一颗星，窄索引片的需求。</p><p>以上2个索引，都是无法同时满足三星索引设计中的三个需求的，我们只能尽力满足2个。而在多数情况下，能够满足2颗星，已经能缩小很大的查询范围了，具体最终要保留那一颗星（排序星 or 窄索引片星），这个就需要看查询者自己的着重点了，无法给出标准答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;高性能的索引创建策略&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;正确地创建和使用索引是实现高性能查询的基础。前面的文章我们已经了解了索引相关的数据结构，各种类型的索引及其对应的优缺点。现在我们一起来看看如何真正地发挥这些索引的优势。&lt;/p&gt;
&lt;h2 id=&quot;1…索</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="索引" scheme="https://eizo01.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的索引</title>
    <link href="https://eizo01.github.io/posts/86b66af2.html"/>
    <id>https://eizo01.github.io/posts/86b66af2.html</id>
    <published>2022-10-02T12:00:00.000Z</published>
    <updated>2022-10-02T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>一.MySQL中的索引</strong></h1><p>InnoDB存储引擎支持以下几种常见的索引：B+树索引、全文索引、哈希索引，其中比较关键的是B+树索引。</p><p>各种引擎的索引结构对比</p><p><img src="http://zdwtop.cn/blog/image-20230313224124751.png" alt></p><h2 id="1-B-树索引"><strong>1.B+树索引</strong></h2><p>InnoDB中的索引自然也是按照B+树来组织的，前面我们说过B+树的叶子节点用来放数据的，但是放什么数据呢？索引自然是要放的，因为B+树的作用本来就是就是为了快速检索数据而提出的一种数据结构，不放索引放什么呢？但是数据库中的表，数据才是我们真正需要的数据，索引只是辅助数据，甚至于一个表可以没有自定义索引。InnoDB中的数据到底是如何组织的？</p><h3 id="1-1-主键索引-聚簇索引"><strong>1.1.主键索引/聚簇索引</strong></h3><p>InnoDB中使用了聚集索引，就是将表的主键用来构造一棵B+树，并且将整张表的行记录数据存放在该B+树的叶子节点中。也就是所谓的索引即数据，数据即索引。由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。</p><p>聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行记录。因此聚集索引的一个优点就是：通过过聚集索引能获取完整的整行数据。另一个优点是：对于主键的排序查找和范围查找速度非常快。</p><p><img src="http://zdwtop.cn/blog/%E4%B8%BB%E9%94%AE%E6%95%B0%E6%8D%AE.png" alt="聚集索引"></p><p><strong>如果我们没有定义主键呢？</strong></p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>总结：MySQL会使用唯一性索引，没有唯一性索引，MySQL也会创建一个<strong>隐含列RowID来做主键</strong>，然后用这个主键来建立聚集索引。</p><h3 id="1-2-辅助索引-二级索引"><strong>1.2.辅助索引/二级索引</strong></h3><p><strong>聚簇索引只能在搜索条件是主键值时才能发挥作用</strong>，因为B+树中的数据都是按照主键进行排序的。</p><p>如果我们想以别的列作为搜索条件怎么办？我们一般会建立多个索引，这些索引被称为辅助索引/二级索引。</p><p>（每建立一个索引，就有一颗B+树，对于辅助索引(Secondary Index，也称二级索引、非聚集索引)， 叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签( bookmark)。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p><p>比如辅助索引index(node)，那么叶子节点中包含的数据就包括了(note和主键)。</p><p><img src="HTTP://zdwtop.cn/blog/image-20230313224124751.png" alt="image-20230313224124751"></p><h3 id="1-3-回表"><strong>1.3.回表</strong></h3><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为 <strong>回表</strong> 。也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树----一次辅助索引，一次聚集索引。</p><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230313224333866.png" alt="回表"></p><p>为什么我们还需要一次回表操作呢?直接把完整的用户记录放到辅助索引d的叶子节点不就好了么？如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。而且每次对数据的变化要在所有包含数据的索引中全部都修改一次，性能也非常低下。</p><p>很明显，回表的记录越少，性能提升就越高，需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。</p><p>那什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方式去执行查询呢？这个就是<strong>查询优化器</strong>做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。</p><h3 id="1-4-覆盖索引"><strong>1.4.覆盖索引</strong></h3><p>既然多个列可以组合起来构建为联合索引，那么辅助索引自然也可以由多个列组成。</p><p>当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p><p><strong>InnoDB存储引擎支持覆盖索引(covering index，或称索引覆盖)</strong>，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录(回表)。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。所以记住，<font color="Blue"><strong>覆盖索引并不是索引类型的一种。</strong></font></p><p>​    <img src="HTTP://zdwtop.cn/blog/stickPicture.png" alt="stickPicture"></p><h3 id="索引分类">索引分类</h3><ol><li>从字段个数的角度来看，索引分为<strong>单列索引、联合索引</strong>（复合索引）。</li></ol><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><p>其他的索引分类都是索引的优化或者使用的区别：</p><ol start="2"><li>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</li></ol><p>这里稍微解释一下<strong>前缀索引</strong>，这里也是一个好用的索引使用方式</p><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><span class="p blue">使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率</span><p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h3 id="1-5-联合索引-复合索引"><strong>1.5.联合索引/复合索引</strong></h3><p>前面我们对索引的描述，隐含了一个条件，那就是构建索引的字段只有一个，但实践工作中构建索引的完全可以是多个字段。所以，将表上的多个列组合起来进行索引我们称之为联合索引或者复合索引，比如index(a,b)就是将a,b两个列组合起来构成一个索引。</p><p>并且按字段先后顺序排序，先按a字段开始排序，a相同时，采用b字段排序，b相同时，采用c字段排序，依次类推。</p><p>千万要注意一点，<strong>建立联合索引只会建立1棵B+树</strong>，多个列分别建立索引会分别以每个列则建立B+树，有几个列就有几个B+树，比如，index(note)、index(b)，就分别对note,b两个列各构建了一个索引。</p><p>而如果是index(note,b)在索引构建上，包含了两个意思：</p><p>1、先把各个记录按照note列进行排序。</p><p>2、在记录的note列相同的情况下，采用b列进行排序</p><p>从原理可知，为什么有最佳左前缀法则，就是这个道理</p><p><img src="HTTP://zdwtop.cn/blog/image-20230314002025314.png" alt="image-20230314002025314"></p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><h4 id="1-5-1-联合索引范围查询">1.5.1 联合索引范围查询</h4><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>联合索引的范围查询并不意味着所有的字段都可以用的到。</p><p>举几个例子：</p><blockquote><p>Q1: <code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a &gt; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p><p><strong><font color="Blue">但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的。</font></strong></p><p>所以b字段在联合索引这颗B+树中无法快速查询，根据EXPLAIN计划他是不会被选择的</p><p>通过 Q1 查询语句我们可以知道，a 字段使用了 &gt; 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ &gt;）后就停止匹配了，因此 b 字段并没有使用到联合索引。</p><p><font color="Blue"><strong>Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</font></p><blockquote><p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。</p><p>正常a字段是一定会用到联合索引，在符合 a&gt;= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但<font color="Blue"><strong>但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong></font>（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。</p><p>所以确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围。</p><p>因此<font color="Blue"><strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</font></p><blockquote><p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值（类似于 <strong>&gt;= and =&lt;</strong>）。而有的数据库则不包含 value1 和 value2 边界值（类似于 <strong>&gt; and &lt;</strong>）,这一点是需要注意的。</p><p>在a确定2到8的范围查询里，可以利用b = 2缩小范围</p><p>所以类似于 Q2 查询语句，因此<font color="Blue"> <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</font></p><blockquote><p>Q4: <code>SELECT * FROM t_user WHERE name like 'j%' and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>联合索引先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。</p><p>假如a字段在B树进行的索引查询形成的扫描区间是[‘j’,‘k’)， j 是闭区间。</p><p><img src="HTTP://zdwtop.cn/blog/q4-1.drawio.png" alt="img"></p><p>跟之前的范围查询情况一样，a = ‘j’ 的二级索引记录里，age的值是有序，但也仅限这个情况。</p><p>从符合 <code>name = 'j' and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：</p><p><img src="http://zdwtop.cn/blog/q4-2.drawio.png" alt="img"></p><p><font color="Blue"> <strong>Q4 这条查询语句 name 和 age 字段都用到了联合索引进行索引查询。</strong></font></p><blockquote><p>以上的例子情况都可以通过执行计划EXPLAIN验证。</p><p>需要注意的是查看索引长度key_len 的显示比较特殊，行格式是由 innodb存 储引擎实现的，而执行计划是在server 层生成的，所以它不会去问 innodb 存储引擎**可变字段的长度（varchar）**占用多少字节，而是不管三七二十一都使用 2 字节表示可变字段的长度。</p><p>其他字段要看数据库的选用哪种字符集排序规则。</p></blockquote><p>综上所示，<font color="Blue"><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面也用了四个例子说明了</strong>。</font></p><h4 id="1-5-2-索引下推"><strong>1.5.2 索引下推</strong></h4><p><strong>索引下推什么时候出现？</strong></p><p>在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，是选择回表呢？还是在联合索引下筛选？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<font color="Blue"><strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</font></li></ul><p>但请注意范围查询是不会走索引下推这个优化，索引下推也只能在二级索引上使用。</p><p><strong>什么是索引下推？</strong></p><p>对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;LiLei%&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span>  </span><br></pre></td></tr></table></figure><p>这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和position是无序的，无法很好的利用索引。</p><p>在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。</p><p>MySQL 5.6引入了索引下推优化，<font color="Blue"><strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数</strong>。</font>使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</p><p>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p><p>因此<strong>like KK% 一般情况都会走索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;LiLei%&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230313235826464.png" alt="image-20230313235826464"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees_copy <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;LiLei%&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="HTTP://zdwtop.cn/blog/image-20230313235810735.png" alt="image-20230313235810735"></p><p><strong>为什么范围查找Mysql没有用索引下推优化？</strong></p><p>估计应该是Mysql认为范围查找过滤的<strong>结果集过大</strong>，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p><h2 id="2-哈希索引"><strong>2.哈希索引</strong></h2><p>InnoDB存储引擎除了我们前面所说的各种索引，还有一种自适应哈希索引，我们知道B+树的查找次数,取决于B+树的高度,在生产环境中,B+树的高度一般为3、4层,故需要3、4次的IO查询。</p><p>所以在InnoDB存储引擎内部自己去监控索引表，如果监控到某个索引经常用，那么就认为是热数据，然后内部自己创建一个hash索引，称之为<strong>自适应哈希索引(</strong> Adaptive Hash Index,AHI)，创建以后，如果下次又查询到这个索引，那么直接通过hash算法推导出记录的地址，直接一次就能查到数据，比重复去B+tree索引中查询三四次节点的效率高了不少。</p><p>InnoDB存储引擎使用的哈希函数采用除法散列方式，其冲突机制采用链表方式。注意，对于自适应哈希索引仅是数据库自身创建并使用的，我们并不能对其进行干预。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status</span><br></pre></td></tr></table></figure><p>​</p><p>哈希索引只能用来搜索等值的查询,如 SELECT* FROM table WHERE index co=xxx。而对于其他查找类型,如范围查找,是不能使用哈希索引的,</p><p>因此这里出现了non-hash searches/s的情况。通过 hash searches: non- hash searches可以大概了解使用哈希索引后的效率。</p><p><strong>innodb_adaptive_hash_index</strong>来考虑是禁用或启动此特性,默认AHI为开启状态。</p><p><img src="http://zdwtop.cn/mysql/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt="哈希索引"></p><h2 id="3-全文索引"><strong>3.全文索引</strong></h2><p>什么是全文检索（Full-Text Search）？它是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。我们比较熟知的Elasticsearch、Solr等就是全文检索引擎，底层都是基于Apache Lucene的。</p><p>举个例子，现在我们要保存唐宋诗词，数据库中我们们会怎么设计？诗词表我们可能的设计如下：</p><table><thead><tr><th>朝代</th><th>作者</th><th>诗词年代</th><th>标题</th><th>诗词全文</th></tr></thead><tbody><tr><td>唐</td><td>李白</td><td></td><td>静夜思</td><td>床前明月光，疑是地上霜。 举头望明月，低头思故乡。</td></tr><tr><td>宋</td><td>李清照</td><td></td><td>如梦令</td><td>常记溪亭日暮，沉醉不知归路，兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭。</td></tr><tr><td>….</td><td>….</td><td>…</td><td>….</td><td>…….</td></tr></tbody></table><p>要根据朝代或者作者寻找诗，都很简单，比如“select 诗词全文 from 诗词表 where作者=‘李白’”，如果数据很多，查询速度很慢，怎么办？我们可以在对应的查询字段上建立索引加速查询。</p><p>但是如果我们现在有个需求：要求找到包含“望”字的诗词怎么办？用</p><p>“select 诗词全文 from 诗词表 where诗词全文 like‘%望%’”，这个意味着要扫描库中的诗词全文字段，逐条比对，找出所有包含关键词“望”字的记录，。基本上，数据库中一般的SQL优化手段都是用不上的。数量少，大概性能还能接受，如果数据量稍微大点，就完全无法接受了，更何况在互联网这种海量数据的情况下呢？怎么解决这个问题呢，用倒排索引。</p><p><strong>倒排索引就是，将文档中包含的关键字全部提取处理，然后再将关键字和文档之间的对应关系保存起来，最后再对关键字本身做索引排序。用户在检索某一个关键字是，先对关键字的索引进行查找，再通过关键字与文档的对应关系找到所在文档。</strong></p><p>于是我们可以这么保存</p><table><thead><tr><th>序号</th><th>关键字</th><th>蜀道难</th><th>静夜思</th><th>春台望</th><th>鹤冲天</th></tr></thead><tbody><tr><td>1</td><td>望</td><td>有</td><td>有</td><td>有</td><td>有</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果查哪个诗词中包含上，怎么办，上述的表格可以继续填入新的记录</p><table><thead><tr><th>序号</th><th>关键字</th><th>蜀道难</th><th>静夜思</th><th>春台望</th><th>鹤冲天</th></tr></thead><tbody><tr><td>1</td><td>望</td><td>有</td><td>有</td><td>有</td><td>有</td></tr><tr><td>2</td><td>上</td><td>有</td><td></td><td></td><td>有</td></tr></tbody></table><p>从InnoDB 1.2.x版本开始，InnoDB存储引擎开始支持全文检索，对应的MySQL版本是5.6.x系列。不过MySQL从设计之初就是关系型数据库，<strong>存储引擎虽然支持全文检索，整体架构上对全文检索支持并不好而且限制很多，比如每张表只能有一个全文检索的索引，不支持没有单词界定符( delimiter）的语言，如中文、日语、韩语等。</strong></p><p><code>所以MySQL中的全文索引功能比较弱鸡，了解即可。</code></p><p><strong>1.2.4.索引在查询中的使用</strong></p><p>索引在查询中的作用到底是什么？在我们的查询中发挥着什么样的作用呢？</p><p>请记住：</p><ol><li><p>一个索引就是一个B+树，索引让我们的查询可以快速定位和扫描到我们需要的数据记录上，加快查询的速度。</p></li><li><p>一个select查询语句在执行过程中一般最多能使用一个二级索引，即使在where条件中用了多个二级索引。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;一.MySQL中的索引&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;InnoDB存储引擎支持以下几种常见的索引：B+树索引、全文索引、哈希索引，其中比较关键的是B+树索引。&lt;/p&gt;
&lt;p&gt;各种引擎的索引结构对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zdw</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="索引" scheme="https://eizo01.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL字段数据类型优化</title>
    <link href="https://eizo01.github.io/posts/86b66af2.html"/>
    <id>https://eizo01.github.io/posts/86b66af2.html</id>
    <published>2022-10-01T12:00:00.000Z</published>
    <updated>2022-11-12T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>字段数据类型优化</strong></h1><p>MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p><h2 id="1-字段优化基本原则"><strong>1.字段优化基本原则</strong></h2><ul><li>更小的通常更好</li></ul><p>一般情况下,应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。</p><p>比如：是有一个类型既可以用字符串也可以使用整型，<strong>优先选择整型</strong>。因为字符串牵涉到了字符集及校对规则等。</p><ul><li>简单就好</li></ul><p>简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则(排序规则)使字符比较比整型比较更复杂。比如应该使用MySQL内建的类型而不是字符串来存储日期和时间。</p><ul><li>尽量避免NULL</li></ul><p><strong>通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。</strong></p><p>如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。</p><p>通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。</p><h2 id="2-Int-整数类型"><strong>2.Int/整数类型</strong></h2><p>存储整数，可以使用这几种整数类型:TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64位存储空间，也就是1、2、3、4、8个字节。它们可以存储的值的范围请自行计算。</p><p><img src="HTTP://zdwtop.cn/blog/image-20230314003458907.png" alt="image-20230314003458907"></p><p>同时整数类型有可选的 UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如TINYINT UNSIGNED可以存储的范围是0~255，而TINYINT的存储范围是-128127。</p><p>有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。</p><p>另外integer和int存储及大小没有任何差别，只是为了业务上区分。</p><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314003508984.png" alt="image-20230314003508984"></p><p>MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的，它不会限制值的合法范围,只是规定了MySQL的一些交互工具（例如MySQL命令行客户端)用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)是相同的。</p><p>​    <img src="HTTP://zdwtop.cn/blog/image-20230314003655511.png" alt="image-20230314003655511"></p><p>MySQL中没有long型，对应的只有bigint</p><p>长度跟存储空间没关系，只是可视化的工具显示的长度</p><h2 id="3-实数类型"><strong>3.实数类型</strong></h2><p>实数是带有小数部分的数字。MySQL既支持精确类型的存储DECIMAL类型，也支持不精确类型存储FLOAT和 DOUBLE类型（浮点类型）。DECIMAL类型用于存储精确的小数，本质上MySQL是以字符串形式存放的。所以CPU不支持对DECIMAL的直接计算，只是在MySQL中自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快。</p><p>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储，DOUBLE占用8个字节，DECIMAL里面存储65个数字，DECIMAL对于列的空间消耗比较大，另外DOUBLE比 FLOAT有更高的精度和更大的范围。</p><p><strong>如何选择？</strong></p><p><strong>在精度不敏感和需要快速运算的时候，选择FLOAT和 DOUBLE。</strong></p><p>应该尽量只在对小数进行精确计算时才使用<strong>DECIMAL</strong>，例如存储财务或金融数据。</p><p>但在数据量比较大的而且要求精度时，可以考虑使用<strong>BIGINT</strong>代替DECIMAL，**将需要存储的货币单位根据小数的位数乘以相应的倍数即可。**假设要存储财务数据精确到万分之一分，则可以把所有金额乘以一百万,然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和 DECIMAL精确计算代价高的问题。</p><h2 id="4-字符串类型"><strong>4.字符串类型</strong></h2><p>MysQL支持多种字符串类型，包括VARCHAR和CHAR类型、BLOB和TEXT类型、ENUM（枚举）和SET类型。</p><p><strong>VARCHAR和 CHAR是两种最主要的字符串类型。</strong></p><h3 id="4-1-VARCHAR">4.1.VARCHAR</h3><p><strong>VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间（例如，越短的字符串使用越少的空间)。<strong>在内部实现上，既然是变长</strong>，VARCHAR需要使用1或2个额外字节记录字符串的长度，如果列的最大长度小于或等于255字节,则只使用1个字节表示,否则使用2个字节。</strong></p><p>VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时新值比旧值长时，使行变得比原来更长，这就肯能导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p><h3 id="4-2-CHAR">4.2.CHAR</h3><p>CHAR类型是定长的，MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格，CHAR值会根据需要采用空格进行填充以方便比较。</p><p><font color="blue"><strong>CHAR与VARCHAR如何选择？</strong></font></p><p>在CHAR和VARCHAR的选择上，<code>这些情况下使用VARCHAR是合适的</code>：</p><p>字符串列的最大长度比平均长度大很多，列的更新很少；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>CHAR适合存储很短的字符串，或者所有值定长或都接近同一个长度。例如，**CHAR非常适合存储密码的MD5值，**因为这是一个定长的值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。</p><p>对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR( 1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，<strong>但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节。</strong></p><p>另外，使用VARCHAR(5)和VARCHAR(200)存储’hello’在磁盘空间上开销是一样的。我们随便选择一个就好？<u>应该使用更短的列</u>，为什么?</p><p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p><p>所以最好的策略是只分配真正需要的空间。</p><h2 id="5-BLOB和TEXT类型">5.BLOB和TEXT类型</h2><p><strong>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</strong></p><p>与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p><p>BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而 TEXT类型有字符集和排序规则。</p><p>使用BLOB和TEXT要慎重：</p><ol><li><p>BLOB和 TEXT 值会引起一些性能问题，所以尽量避免使用BLOB和TEXT类型；</p></li><li><p>一定要用，建议把BLOB或TEXT 列分离到单独的表中；</p></li><li><p>在不必要的时候避免检索大型的 BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，很可能毫无目的地在网络上传输大量的值。建议可以搜索索引列，决定需要的哪些数据行，然后从符合条件的数据行中检索BLOB或 TEXT值；</p></li><li><p>还可以使用合成的(Synthetic)索引来提高大文本字段(BLOB或TEXT)的查询性能。简单来说，合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了。但是，要注意这种技术只能用于精确匹配的查询（散列值对于类似“&lt;”或“&gt;=”等范围搜索操作符是没有用处的)。可以使用MD5函数生成散列值，也可以使用SHA1(或CRC32)，或者使用自己的应用程序逻辑来计算散列值。</p></li></ol><h2 id="6-枚举类型">6.枚举类型</h2><p>如果表中的字段的取值是固定几个字符串，可以使用枚举列代替常用的字符串类型。</p><p>枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中，MySQL在内部会将每个值在列表中的位置保存为整数，这样的话可以让表的大小大为缩小。</p><p>具体枚举使用见官网地址：<a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html">https://dev.mysql.com/doc/refman/5.7/en/enum.html</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> enum_test(e ENUM(<span class="string">&#x27; fish&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test(e) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>但是要注意，</p><ol><li><p>因为枚举列实际存储为整数，而不是字符串，所以不要使用数字作为ENUM枚举常量，这种双重性很容易导致混乱，例如ENUM( ’ 1’,‘2’，‘3’)。</p></li><li><p>枚举字段是按照内部存储的整数而不是定义的字符串进行排序的，所以尽量按照需要的顺序来定义枚举列。</p></li></ol><h2 id="7-日期和时间类型">7.日期和时间类型</h2><p>MySQL可以使用许多类型来保存日期和时间值，例如YEAR和 DATE以及DATETIME和TIMESTAMP。MySQL能存储的最小时间粒度为秒。</p><p><strong>datetime</strong> 存储日期范围：1001年~9999年</p><p><strong>timestamp</strong> 存储日期范围：1970年~2038年,并且跟时区有关系。</p><p>如果需要存储比秒更小粒度的日期和时间值怎么办？MySQL目前没有提供合适的数据类型，但是可以使用自己的存储格式：可以使用BIGINT类型存储微秒级别的时间截，或者使用DOUBLE存储秒之后的小数部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;字段数据类型优化&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。&lt;/p&gt;
&lt;h2 id=&quot;1-字段优化基本原则&quot;&gt;&lt;strong</summary>
      
    
    
    
    <category term="MySQL" scheme="https://eizo01.github.io/categories/MySQL/"/>
    
    
    <category term="sql优化" scheme="https://eizo01.github.io/tags/sql%E4%BC%98%E5%8C%96/"/>
    
    <category term="列" scheme="https://eizo01.github.io/tags/%E5%88%97/"/>
    
  </entry>
  
</feed>
