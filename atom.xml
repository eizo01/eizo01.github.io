<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDW🥝</title>
  
  <subtitle>一个入行Java程序员</subtitle>
  <link href="https://eizo01.github.io/atom.xml" rel="self"/>
  
  <link href="https://eizo01.github.io/"/>
  <updated>2023-05-18T03:12:12.025Z</updated>
  <id>https://eizo01.github.io/</id>
  
  <author>
    <name>曾德威🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-04-21T15:08:31.501Z</published>
    <updated>2023-05-18T03:12:12.025Z</updated>
    
    <content type="html"><![CDATA[<h1>ReentrantLock</h1><p><img src="HTTPs://zdwtop.cn/blog/reentrantlock-class-diagram.png" alt="reentrantLock"></p><h2 id="ReentrantLock-是什么？">ReentrantLock 是什么？</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。默认是非公平锁，可以通过构造器设置为公平。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以指定等待时间，lock可以使用tryLock指定等待锁的时间，lock锁还提供了lockInterruptibly允许线程在获取锁的期间被中断。</p><p>相对于 synchronized， ReentrantLock具备如下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li><li>与 synchronized 一样，都支持可重入</li></ul><p>总结了几点synchronized和ReentrantLock的区别：</p><ul><li>synchronized是JVM层次的锁实现，ReentrantLock是JDK层次API的锁实现；</li><li>synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</li><li>synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li><li>synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</li><li>在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；</li><li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li><li>synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（回顾一下sychronized的唤醒策略），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁</li></ul><h2 id="源码">源码</h2><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><h3 id="Lock方法源码">Lock方法源码</h3><p>清楚lock方法是如何实现让当前线程获取到锁资源（什么效果算是拿到了锁资源）</p><p>**非公平锁：**上来先尝试将state从0修改为1，如果成功，代表获取锁资源。如果没有成功，调用acquire</p><p>**公平锁：**调用acquire</p><blockquote><p>state是个什么?</p></blockquote><p>ReentrantLock是基于AQS实现，state是AQS中的一个由volatile修饰的int类型变量，AQS是通过state状态位来控制锁的状态，多个线程会通过CAS的方式修改state，在并发情况下，只会有一个线程成功的修改state（从0~1）</p><blockquote><p>如果线程修改state失败怎么办？</p></blockquote><p>如果线程没有拿到锁资源，会到AQS的双向链表中排队等待（在期间，线程可能会挂起）</p><blockquote><p>AQS的双向链表（队列）是个啥？</p></blockquote><p>AQS中的双向链表是基于内部类 Node在维护，Node中包含prev，next，thread属性，并且在AQS中还有两个属性，分别是head，tail。</p><p>给出大概的图,注意这里有一个头结点，它是不存储线程。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230421211702367.png" alt="image-20230421211702367"></p><p>公平&amp;非公平的方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁的sync的lock方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的sync的lock方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//上来先抢一手</span></span><br><span class="line">        <span class="comment">//成功设置拥有权设置成当前的自己</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到源码，锁住一个资源就是尝试把state变成1，并且调用了acquire(1);</p><h3 id="acquire方法源码"><strong>acquire方法源码</strong></h3><p>在获取锁资源时，该线程已经将锁资源的占用计数器加1，并记录了当前持有锁资源的线程。在释放锁资源时，该线程也会将锁资源的占用计数器减1，只有当占用计数器归零时，锁资源才会被完全释放。</p><p>acquire是AQS的一个业务方法，里面并没有实际的业务处理，都是在调用其他方法</p><ol><li><p>调用<code>tryAcquire</code>方法：尝试获取锁资源（非公平、公平），拿到锁资源，返回true，直接结束方法。 没有拿到锁资源， 需要执行&amp;&amp;后面的方法</p></li><li><p>当没有获取锁资源后，会先调用<code>addWaiter</code>：会将没有获取到锁资源的线程封装为Node对象， 并且插入到AQS的队列的末尾，并且作为tail</p></li><li><p>继续调用<code>acquireQueued</code>方法，查看当前排队的Node是否在队列的前面，如果在前面（head的next），尝试获取锁资源  如果没在前面，尝试将线程挂起，阻塞起来！</p></li><li><p>如果当前线程在等待过程中被中断，则调用 <code>selfInterrupt()</code> 方法自我中断，以便让其他等待线程有机会获得锁资源。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心acquire     arg = 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到锁资源 返回true 加上！ false短路运算直接走</span></span><br><span class="line">    <span class="keyword">if</span> ( ! tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以知道首先执行的是tryAcquire方法。</p><h3 id="tryAcquire方法源码"><strong>tryAcquire方法源码</strong></h3><p>tryAcquire分为公平和非公平两种、</p><p>tryAcquire主要做了两件事：</p><ul><li>如果state为0，尝试获取锁资源</li><li>如果state不为0，看一下是不是锁重入操作</li></ul><p><strong>非公平：</strong></p><p>在非公平锁的情况下，<code>tryAcquire(int arg)</code>方法会直接尝试获取锁资源，而不进行任何等待操作。如果获取锁成功，则直接返回<code>true</code>；否则，线程将自旋等待。</p><p>具体思路：拿到当前的线程和state变量，</p><p>如果state变量等于0，那么cas操作将0改成1，成功的话就把当锁拥有者设置成当前线程，返回ture</p><p>如果state不等于0，先判断是不是锁重入，是的话将state+1，在判断+1后的state是否会超过锁重入的最大限制，会的话抛出异常，不会的话设置state，并且返回ture</p><p><strong>公平：</strong></p><p>先检查等待队列中是否有比当前线程更早进入队列的节点，如果有，则会放弃获取锁资源的机会，当前线程进入等待队列。只有当等待队列中没有其他线程等待或者其他线程等待时间比当前线程晚时，当前线程才会获取到锁资源。</p><p>因为公平锁需要维护等待队列,性能开销会大一点。</p><blockquote><p>等待队列指的是CLH（Craig, Landin, and Hagersten）队列或者是其变种。CLH队列是一种FIFO队列，它的基本思想是将线程封装成一个节点，并维护一个类似于链表的结构，形成一个虚拟的环。在该队列中，每个节点都有一个状态字段，用于表示其前一个节点是否已经释放锁资源。当一个线程需要获取锁资源时，它会创建一个节点并将其添加到队列的末尾。然后，该线程会自旋等待它的前驱节点释放锁资源。这样，所有线程都可以按照FIFO顺序获取锁资源，避免了饥饿问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁实现！</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到AQS的state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果state == 0，说明没有线程占用着当前的锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没人占用锁资源，我直接抢一波（不管有没有线程在排队）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 将当前占用这个互斥锁的线程属性设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">// 返回true，拿锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前state != 0，说明有线程占用着锁资源</span></span><br><span class="line">    <span class="comment">// 判断拿着锁的线程是不是当前线程（锁重入）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将state再次+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// 锁重入是否超过最大限制</span></span><br><span class="line">        <span class="comment">// 01111111 11111111 11111111 11111111   + 1</span></span><br><span class="line">        <span class="comment">// 10000000 00000000 00000000 00000000</span></span><br><span class="line">        <span class="comment">// 抛出error</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 将值设置给state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 返回true，拿锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到AQS的state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">   <span class="comment">// 如果state == 0，说明没有线程占用着当前的锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否有线程在排队，如果有线程排队，返回true，配上前面的!，那会直接不执行返回最外层的false</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程排队，直接CAS尝试获取锁资源</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置当前线程，返回true</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁重入的判断</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是acquire方法的第一个方法的执行，防止读者（我）忘记，再把代码放上来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果if里tryAcquire返回的false，也就是抢锁失败，再加上！语句就是执行后面的方法acquireQueued（addWaiter(Node.EXCLUSIVE), arg)），注意这个方法会先执行addWaiter，逻辑是这样的，因为抢锁失败，所以当前线程需要封装成Node节点，插入等待队列尾巴。</p><h3 id="addWaiter方法"><strong>addWaiter方法</strong></h3><p>在获取锁资源失败后，需要将当前线程封装为Node对象，并且插入到AQS队列的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程封装为Node对象，并且插入到AQS队列的末尾</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装为Node对象，mode为null，代表互斥锁</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// pred是tail节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 如果pred不为null，有线程正在排队</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的prev，指定tail尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 以CAS的方式，将当前节点变为tail节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 之前的tail的next指向当前节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加的流程为，  自己prev指向、tail指向自己、前节点next指向我</span></span><br><span class="line">    <span class="comment">// 如果上述方式，CAS操作失败，导致加入到AQS末尾失败，如果失败，就基于enq的方式添加到AQS队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// enq，无论怎样都添加进入</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到tail</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 如果tail为null，说明当前没有Node在队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 创建一个新的Node作为head，并且将tail和head指向一个Node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 和上述代码一致！</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter(Node.EXCLUSIVE)</code>方法的作用是将当前线程封装成一个节点，并添加到等待队列中，以便于在后续调用<code>acquireQueued(Node node, int arg)</code>方法时能够正确地获取到节点并加入到等待队列中。</p><h3 id="acquireQueued方法源码">acquireQueued方法源码</h3><p>acquireQueued方法会查看当前排队的Node是不是head的next，如果是，尝试获取锁资源，如果不是或者获取锁资源失败那么就尝试将当前Node的线程挂起（unsafe.park()）。</p><p>复习一下-前驱节点的状态可以有以下几种：</p><ul><li>CANCELLED：表示当前节点已经取消了等待，需要从等待队列中移除。1</li><li>SIGNAL：表示当前节点的后继节点（即等待队列中排在当前节点后面的节点）需要被唤醒。 -1</li><li>CONDITION：表示当前节点正在等待条件变量，因此需要特殊处理。-2</li><li>0或负数：表示前驱节点可以将当前节点插入到等待队列中。</li></ul><p><strong>在挂起线程前，需要确认当前节点的上一个节点的状态必须是小于等于0：</strong></p><p>如果为1，代表是取消的节点，不能挂起</p><p>如果为-1，代表挂起当前线程</p><p>如果为-2，-3，需要将状态改为-1之后，才能挂起当前线程</p><p>获取当前节点的前驱节点，如果当前节点的前驱节点（即等待队列中排在当前节点前面的节点）是已经释放了锁资源的节点，则当前线程可以立即获取锁资源，否则当前线程将被阻塞，等待前驱节点释放锁资源后再次尝试获取锁资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireQueued方法</span></span><br><span class="line"><span class="comment">// 查看当前排队的Node是否是head的next，</span></span><br><span class="line"><span class="comment">// 如果是，尝试获取锁资源，</span></span><br><span class="line"><span class="comment">// 如果不是或者获取锁资源失败那么就尝试将当前Node的线程挂起（unsafe.park()）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 标识。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环走起</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿到上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; <span class="comment">// 说明当前节点是head的next</span></span><br><span class="line">                tryAcquire(arg)) &#123; <span class="comment">// 竞争锁资源，成功：true，失败：false</span></span><br><span class="line">                <span class="comment">// 进来说明拿到锁资源成功</span></span><br><span class="line">                <span class="comment">// 将当前节点置位head，thread和prev属性置位null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 帮助快速GC</span></span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                <span class="comment">// 设置获取锁资源成功</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 不管线程中断。</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是或者获取锁资源失败,尝试将线程挂起</span></span><br><span class="line">            <span class="comment">// 第一个事情，当前节点的上一个节点的状态正常！</span></span><br><span class="line">            <span class="comment">// 第二个事情，挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 通过LockSupport将当前线程挂起</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 确保上一个节点状态是正确的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到上一个节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果上一个节点为 -1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 返回true，挂起线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果上一个节点是取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环往前找，找到一个状态小于等于0的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将小于等于0的节点状态该为-1</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么唤醒线程时，为啥从尾部往前找，而不是从前往后找？</p><p>因为在addWaiter操作时，是先将当前Node的prev指针指向前面的节点，然后是将tail赋值给当前Node，最后才是能上一个节点的next指针，指向当前Node。</p><p>如果从前往后，通过next去找，可能会丢失某个节点，导致这个节点不会被唤醒~</p><p>如果从后往前找，肯定可以找到全部的节点。</p><p>具体解释：<a href="https://my.oschina.net/chuhecc/blog/8590137">https://my.oschina.net/chuhecc/blog/8590137</a></p><h3 id="unlock方法"><strong>unlock方法</strong></h3><p>释放锁资源：</p><ul><li>将state - 1。</li><li>如果state减为0了，唤醒在队列中排队的Node。（一定唤醒离head最近的）</li></ul><p>释放锁不分公平和非公平，就一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正释放锁资源的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心的释放锁资源方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁资源释放干净了。  （state == 0）</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 如果头节点不为null，并且头节点的状态不为0，唤醒排队的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)、</span><br><span class="line">            <span class="comment">// 唤醒线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁成功，但是state != 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心的释放锁资源方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取state - 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果释放锁的线程不是占用锁的线程，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 是否成功的将锁资源释放利索 （state == 0）</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁资源释放干净。</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 将占用锁资源的属性设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将state赋值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 返回true，代表释放干净了</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 唤醒节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到头节点状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果头节点状态小于0，换为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 拿到当前节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 如果s == null ，或者s的状态为1</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// next节点不需要唤醒，需要唤醒next的next</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部往前找，找到状态正常的节点。（小于等于0代表正常状态）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过循环的获取，如果拿到状态正常的节点，并且不为null</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ReentrantLock&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;HTTPs://zdwtop.cn/blog/reentrantlock-class-diagram.png&quot; alt=&quot;reentrantLock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock-是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:28.303Z</published>
    <updated>2023-04-04T08:57:38.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-Bean定义配置化"><a href="#Spring源码手写篇-Bean定义配置化" class="headerlink" title="Spring源码手写篇-Bean定义配置化"></a>Spring源码手写篇-Bean定义配置化</h1><h1 id="一、Bean定义配置分析"><a href="#一、Bean定义配置分析" class="headerlink" title="一、Bean定义配置分析"></a>一、Bean定义配置分析</h1><p>&emsp;&emsp;我们前面实现了手写IoC和AOP的功能，但是我们在使用的时候发现我们的调用代码还是非常的繁琐，会给应用者很不好的体验。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/a3813fe22e7848cb9e46a82c8bb6ac8e.png" alt="image.png"></p><p>&emsp;&emsp;上面的代码很直观的看到重复代码很多，要用户设置的内容也很多，低效而且容易出错，这时我们可以看看在Spring中是怎么处理的呢？</p><p>一种是通过XML的配置文件方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;abean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.samples.ABean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abean01&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;cbean&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cbean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.samples.CBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cbean01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一种是通过注解的方式来处理</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Acc</span> ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-XML方式实现"><a href="#1-XML方式实现" class="headerlink" title="1. XML方式实现"></a>1. XML方式实现</h2><p>基于XML方式实现我们需要做什么操作呢?</p><ul><li>定义XML规范</li><li>要写代码来解析XML，完成Bean定义的注册</li></ul><h2 id="2-注解方式实现"><a href="#2-注解方式实现" class="headerlink" title="2.注解方式实现"></a>2.注解方式实现</h2><p>基于XML方式实现我们需要做什么操作呢?</p><ul><li>定义一套注解</li><li>要写代码来扫描、解析注解、完成Bean定义注册。</li></ul><h1 id="二、Bean定义配置实现"><a href="#二、Bean定义配置实现" class="headerlink" title="二、Bean定义配置实现"></a>二、Bean定义配置实现</h1><h2 id="1-XML方法设计"><a href="#1-XML方法设计" class="headerlink" title="1. XML方法设计"></a>1. XML方法设计</h2><p>&emsp;&emsp;xml方式的流程如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/b65b1279f9d34bb1835cff193182b5a4.png" alt="image.png"></p><p>我们可以自己写一个解析器，专门来解析对应的xml文件</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/ffd0f363cfaf451d951cd402bd294089.png" alt="image.png"></p><h2 id="2-注解方式设计"><a href="#2-注解方式设计" class="headerlink" title="2. 注解方式设计"></a>2. 注解方式设计</h2><h3 id="2-1-定义相关的注解"><a href="#2-1-定义相关的注解" class="headerlink" title="2.1 定义相关的注解"></a>2.1 定义相关的注解</h3><p>&emsp;&emsp;然后我们来看看需要定义的注解有哪些。</p><ul><li>类要不要配置为Bean       @Component</li><li>BeanName Scope和Primary   @Scope  @Primary</li><li>工厂方法  工厂Bean  @Bean</li><li>初始化方法、销毁方法 @PostConstruct @PreDestory</li><li>构造参数依赖 @Autowired @Value</li><li>属性依赖  @Qualifier</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/c0a718c8b2014741b6632f3fa015c43f.png" alt="image.png"></p><h3 id="2-2-扫描解析注册操作"><a href="#2-2-扫描解析注册操作" class="headerlink" title="2.2 扫描解析注册操作"></a>2.2 扫描解析注册操作</h3><p>&emsp;&emsp;我们定义了相关注解后，谁来实现扫描注解、解析注解并完成Bean定义注册呢</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/be1c3a58d5984cd69ff5cbfa057d63f8.png" alt="image.png"></p><p>先来看如何实现扫描操作</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/20b7d507fe0542eb84008560fdd7ee5d.png" alt="image.png"></p><p>实现的逻辑应该是递归找出包目录下的所有的.class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span> (basePackages != <span class="literal">null</span> &amp;&amp; basePackages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String p : basePackages) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1 递归扫描包目录下的.class文件</span></span><br><span class="line"><span class="comment"> 2 组合包路径+class文件名 得到全限定类名</span></span><br><span class="line"><span class="comment"> 3 ClassLoad.load(&quot;类名&quot;) 得到 Class 对象</span></span><br><span class="line"><span class="comment"> 4 解析Class上的注解，获得Bean定义信息，注册Bean定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1 递归扫描包目录下的.class文件</span></span><br><span class="line">            Set&lt;File&gt; classFiles = <span class="built_in">this</span>.doScan(p);</span><br><span class="line">            <span class="comment">//2 得到Class对象，并解析注解、注册Bean定义</span></span><br><span class="line">            <span class="built_in">this</span>.readAndRegisterBeanDefintion(classFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看如何来解析类注解</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/adaf37e07d60482988735a68183c405d.png" alt="image.png"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void read<span class="constructor">AndRegisterBeanDefintion(Set&lt;File&gt; <span class="params">classFiles</span>)</span> throws BeanDefinitionRegistException &#123;</span><br><span class="line">    <span class="keyword">for</span> (File classFile : classFiles) &#123;</span><br><span class="line">        String className = get<span class="constructor">ClassNameFromFile(<span class="params">classFile</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = this.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>.load<span class="constructor">Class(<span class="params">className</span>)</span>;</span><br><span class="line">            Component component = clazz.get<span class="constructor">Annotation(Component.<span class="params">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (component != null) &#123;<span class="comment">// 标注了@Component注解</span></span><br><span class="line">                String beanName = component.value<span class="literal">()</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">beanName</span>)</span>) &#123;</span><br><span class="line">                    beanName = this.generate<span class="constructor">BeanName(<span class="params">clazz</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                GenericBeanDefinition bd = <span class="keyword">new</span> <span class="constructor">GenericBeanDefinition()</span>;</span><br><span class="line">                bd.set<span class="constructor">BeanClass(<span class="params">clazz</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理Scope</span></span><br><span class="line">                Scope scope = clazz.get<span class="constructor">Annotation(Scope.<span class="params">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (scope != null) &#123;</span><br><span class="line">                    bd.set<span class="constructor">Scope(<span class="params">scope</span>.<span class="params">value</span>()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理primary</span></span><br><span class="line">                Primary primary = clazz.get<span class="constructor">Annotation(Primary.<span class="params">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (primary != null) &#123;</span><br><span class="line">                    bd.set<span class="constructor">Primary(<span class="params">true</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理构造方法，在构造方法上找@Autowired注解，如有，将这个构造方法set到bd;</span></span><br><span class="line">                this.handle<span class="constructor">Constructor(<span class="params">clazz</span>, <span class="params">bd</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理方法上的注解（找出初始化、销毁、工厂方法）</span></span><br><span class="line">                this.handle<span class="constructor">Method(<span class="params">clazz</span>, <span class="params">bd</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理属性依赖</span></span><br><span class="line">                this.handle<span class="constructor">PropertyDi(<span class="params">clazz</span>, <span class="params">bd</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册bean定义</span></span><br><span class="line">                this.registry.register<span class="constructor">BeanDefinition(<span class="params">beanName</span>, <span class="params">bd</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ApplicationContext"><a href="#3-ApplicationContext" class="headerlink" title="3.ApplicationContext"></a>3.ApplicationContext</h2><p>&emsp;&emsp;通过上面的设计，我们可以实现注解的方式来定义，但是给用户的整体体验还是不是很好，这时我们可以通过外观模式，为框架定义一个更简单的统一使用界面</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/f0aaa5abc9e5488c9b0f785e402ebb98.png" alt="image.png"></p><p>组合为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662446007005/8cdf22609c5e4af19b6399a46cb1dcbc.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-Bean定义配置化&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-Bean定义配置化&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-Bean定义配置化&quot;&gt;&lt;/a&gt;Spring源码手写篇-Bean定义配置化&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:21.702Z</published>
    <updated>2023-04-04T08:57:38.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-手写AOP"><a href="#Spring源码手写篇-手写AOP" class="headerlink" title="Spring源码手写篇-手写AOP"></a>Spring源码手写篇-手写AOP</h1><p>&emsp;&emsp;手写IoC和DI后已经实现的类图结构。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/f53bd24c0faa4eca911f742a9b94b9ce.png" alt="image.png"></p><h1 id="一、AOP分析"><a href="#一、AOP分析" class="headerlink" title="一、AOP分析"></a>一、AOP分析</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/8ca3b768d2f44ad19bc44eac019f362d.png" alt="image.png"></p><h2 id="1-AOP是什么"><a href="#1-AOP是什么" class="headerlink" title="1.AOP是什么?"></a>1.AOP是什么?</h2><p>&emsp;&emsp; AOP[Aspect Oriented Programming] 面向切面编程，在不改变类的代码的情况下，对类方法进行功能的增强。</p><h2 id="2-我们要做什么？"><a href="#2-我们要做什么？" class="headerlink" title="2.我们要做什么？"></a>2.我们要做什么？</h2><p>&emsp;&emsp;我们需要在前面手写IoC，手写DI的基础上给用户提供AOP功能，让他们可以通过AOP技术实现对类方法功能增强。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/674507e0830c43369642b767accba678.png" alt="image.png"></p><h2 id="3-我们的需求是什么？"><a href="#3-我们的需求是什么？" class="headerlink" title="3.我们的需求是什么？"></a>3.我们的需求是什么？</h2><p>&emsp;&emsp;提供AOP功能!,然后呢？… 没有了。关键还是得从上面的定义来理解。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/bc3ca3f0071c40a597a297e27d202289.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b0ebb450ee024684a2d619582763566b.png" alt="image.png"></p><h1 id="二、AOP概念讲解"><a href="#二、AOP概念讲解" class="headerlink" title="二、AOP概念讲解"></a>二、AOP概念讲解</h1><p>&emsp;&emsp;上面在分析AOP需求的时候，我们介绍到了相关的概念，Advice、Pointcuts和weaving等，首先我们来看看在AOP中我们会接触到的相关的概念都有哪些。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/13c2cf4ff1dd4482a0fcdfa6e3f91bfc.png" alt="image.png"></p><p>更加形象的描述</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/00653b5d08c34e6ea9f438eb2db17f87.png" alt="image.png"></p><p>然后对于上面的相关概念，我们就要考虑哪些是用户需要提供的，哪些是框架要写好的？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/43d865cfdc6c40048f321c5a741d7eaf.png" alt="image.png"></p><p>思考：Advice，Pointcuts和Weaving各自的特点</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/f40b002f19e2485cb875c52c948e7f0e.png" alt="image.png"></p><h1 id="三、切面实现"><a href="#三、切面实现" class="headerlink" title="三、切面实现"></a>三、切面实现</h1><p>&emsp;&emsp;通过上面的分析，我们要设计实现AOP功能，其实就是要设计实现上面分析的相关概念对应的组件。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/126439203e92420a9d755603a9701881.png" alt="image.png"></p><h2 id="1-Advice"><a href="#1-Advice" class="headerlink" title="1.Advice"></a>1.Advice</h2><h3 id="1-1-面向接口编程"><a href="#1-1-面向接口编程" class="headerlink" title="1.1 面向接口编程"></a>1.1 面向接口编程</h3><p>&emsp;&emsp;Advice:通知，是由用户提供的，我们来使用，主要是用户提供就突出了 <code>多变性</code>。针对这块我们应该怎么设计?这里有两个问题:</p><ol><li>我们如何能够识别用户提供的东西呢?用户在我们写好框架后使用我们的框架</li><li>如何让我们的代码隔绝用户提供的多变性呢?</li></ol><p>针对这种情况我们定义一套标准的接口，用户通过实现接口类提供他们不同的逻辑。是否可行?<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/904bde3bf689418c984ffe125aa165a9.png" alt="image.png"></p><p>这里有个重要的设计原则大家要注意: 如何应对变化，通过面向接口编程来搞定!!!</p><p>我们先定义一个空的接口,可以先思考下我们为什么定义一个空的接口呢?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/7da55a1150cb487d8d1cfdec90624813.png" alt="image.png"></p><h3 id="1-2-Advice的特点分析"><a href="#1-2-Advice的特点分析" class="headerlink" title="1.2 Advice的特点分析"></a>1.2 Advice的特点分析</h3><p>&emsp;&emsp;Advice的特点：可选时机，可选择在方法执行前、后、异常时进行功能的增强</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6ba22d8fd7424bf79d69fae54dd8a9de.png" alt="image.png"></p><p>结合上面的情况我们可以分析出Advice通知的几种情况</p><ul><li>前置增强-Before</li><li>后置增强-AfterReturn</li><li>环绕增强-Around</li><li>最终通知-After</li><li>异常通知-Throwing</li></ul><p>有这么多的情况我们应该要怎么来实现呢?我们可以定义标准的接口方法，让用户来实现它，提供各种具体的增强内容。那么这四种增强相关的方法定义是怎样的呢？我们一一来分析下。</p><h3 id="1-3-各种通知分析"><a href="#1-3-各种通知分析" class="headerlink" title="1.3 各种通知分析"></a>1.3 各种通知分析</h3><h4 id="1-3-1-前置增强"><a href="#1-3-1-前置增强" class="headerlink" title="1.3.1 前置增强"></a>1.3.1 前置增强</h4><p><strong>前置增强</strong>：在方法执行前进行增强。</p><p>问题1：它可能需要的参数?</p><p>&emsp;&emsp;目的是对方法进行增强，应该需要的是方法相关的信息，我们使用它的时候能给如它的就是当前要执行方法的相关信息了</p><p>问题2:运行时方法有哪些信息?</p><ol><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li></ol><p>问题3:前置增强的返回值是什么?</p><p>&emsp;&emsp;在方法执行前进行增强，不需要返回值!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法进行前置增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            被增强的目标对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-最终通知"><a href="#1-3-2-最终通知" class="headerlink" title="1.3.2 最终通知"></a>1.3.2 最终通知</h4><p>&emsp;&emsp;最终通知：在方法执行后进行增强</p><p>问题1:它可能需要的参数?</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li><li>方法的返回值 Object 可能没有</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法，提供后置增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue</span></span><br><span class="line"><span class="comment"> *            返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法的所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-后置通知"><a href="#1-3-3-后置通知" class="headerlink" title="1.3.3 后置通知"></a>1.3.3 后置通知</h4><p>&emsp;&emsp;后置增强：在方法执行后进行增强</p><p>问题1:他可能需要的参数</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li><li>方法的返回值 Object</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该方法，提供AfterRetun增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue</span></span><br><span class="line"><span class="comment"> *            返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法的所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-环绕通知"><a href="#1-3-4-环绕通知" class="headerlink" title="1.3.4 环绕通知"></a>1.3.4 环绕通知</h4><p>Around环绕增强：包裹方法进行增强</p><p>问题1:他可能需要的参数</p><ul><li>方法本身 Method</li><li>方法所属的对象 Object</li><li>方法的参数 Object[]</li></ul><p>问题2:它的返回值是面试?</p><p>&emsp;&emsp;方法被它包裹，即方法将由它来执行，它需要返回方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对方法进行环绕（前置、后置）增强、异常处理增强，方法实现中需调用目标方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被增强的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> *            方法所属对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Object 返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-异常通知"><a href="#1-3-5-异常通知" class="headerlink" title="1.3.5 异常通知"></a>1.3.5 异常通知</h4><p>异常通知增强：对方法执行时的异常，进行增强处理</p><p>问题1：它可能需要什么参数?</p><ul><li>一定需要Exception</li><li>可能需要方法本身 Method</li><li>可能需要方法所属的对象 Object</li><li>可能需要方法的参数 Object[]</li></ul><p>问题2:它的返回值是什么?</p><p>&emsp;&emsp;这个就需要看是否允许在After中更改返回的结果，如果规定只可用、不可修改返回值就不需要返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Exception ex)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Advice设计"><a href="#1-4-Advice设计" class="headerlink" title="1.4 Advice设计"></a>1.4 Advice设计</h3><p>&emsp;&emsp;结合上面的分析，我们就可以得出Advice的体系图了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/79db7010cc1f48a9a7d7c962bfc2a59f.png" alt="image.png"></p><h2 id="2-Pointcut"><a href="#2-Pointcut" class="headerlink" title="2.Pointcut"></a>2.Pointcut</h2><h3 id="2-1-Pointcut的特点有："><a href="#2-1-Pointcut的特点有：" class="headerlink" title="2.1 Pointcut的特点有："></a>2.1 Pointcut的特点有：</h3><ul><li>用户性：由用户指定</li><li>变化性：用户可灵活指定</li><li>多点性：用户可以选择在多个点上进行增强</li></ul><h3 id="2-2-Pointcut分析"><a href="#2-2-Pointcut分析" class="headerlink" title="2.2 Pointcut分析"></a>2.2 Pointcut分析</h3><p>&emsp;&emsp;为用户提供一个东西，让他们可以灵活地指定多个方法点，而且我们还能看懂!</p><p>思考：切入点是由用户来指定在哪些方法点上进行增强，那么这个哪些方法点如何来表示能满足上面的需求呢?</p><p>分析：</p><ol><li>指定哪些方法，是不是一个描述信息?</li><li>如何来指定一个方法?</li><li>如果有重载的情况怎么办?</li><li>123要求的其实就是一个完整的方法签名</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.boge.spring.aop.Girl.dbj(Boy,Time)</span><br><span class="line"></span><br><span class="line">com.boge.spring.aop.Girl.dbj(Boy,Girl,Time)</span><br></pre></td></tr></table></figure><p>我们还得进一步分析：如何做到多点性和灵活性，在一个描述中指定一类类的某些方法?</p><ul><li>某个包下的某个类的某个方法</li><li>某个包下的所有类中的所有方法</li><li>某个包下的所有类中的do开头的方法</li><li>某个包下的以service结尾的类中的do开头的方法</li><li>…..</li></ul><p>也就是我们需要有这样一个表达式能够灵活的描述上面的这些信息。</p><p>这个表达式表达的内容有：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d7283c3a93034785b0654137d01f782f.png" alt="image.png"></p><p>而且每个部分的要求是怎么样的呢？</p><ul><li>包名：有父子特点，要能模糊匹配</li><li>类名：要能模糊匹配</li><li>方法名:要能模糊匹配</li><li>参数类型：参数可以有多个</li></ul><p>那么我们设计的这个表达式将被我们用来决定是否需要对某个类的某个方法进行增强，这个决定过程应该是怎么样的？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/c916c51a3ca84a11b5de3f723ad30e35.png" alt="image.png"></p><p>针对需求我们的选择是：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/1b737a0982684f45b6ceb1345ed06a09.png" alt="image.png"></p><p>AspectJ官网：<a href="http://www.eclipse.org/aspectj">http://www.eclipse.org/aspectj</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6ee3a6aceb064424859144f423b2c058.png" alt="image.png"></p><p>切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名。注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/78122d7454a3467595da80fa0e0a9901.png" alt="image.png"></p><p>举例：</p><blockquote><p>execution(public <em> </em>(. .))<br>指定切入点为：任意公共方法。<br>execution(<em> set </em>(. .))<br>指定切入点为：任何一个以“set”开始的方法。<br>execution(<em> com.xyz.service.</em>.<em>(. .))<br>指定切入点为：定义在service包里的任意类的任意方法。<br>execution(</em> com.xyz.service. .<em>.</em>(. .))<br>指定切入点为：定义在service包或者子包里的任意类的任意方法。“..”出现在类名中时，<br>后面必须跟“<em>”，表示包、子包下的所有类。<br>execution(</em> <em>.service.</em>.<em>(. .))<br>指定只有一级包下的serivce子包下所有类(接口)中的所有方法为切入点<br>execution(</em> <em>. .service.</em>.*(. .))<br>指定所有包下的serivce子包下所有类(接口)中的所有方法为切入点</p></blockquote><h3 id="2-3-Pointcut设计"><a href="#2-3-Pointcut设计" class="headerlink" title="2.3 Pointcut设计"></a>2.3 Pointcut设计</h3><p>&emsp;&emsp;通过分析完成我们就该对Pointcut类设计了，接口，类。</p><p>思考1：首先考虑切入点应该具有的属性—-&gt;切入点表达式</p><p>思考2：切入点应对外提供什么行为</p><p>思考3：切入点被我们设计用来做什么？</p><p>&emsp;&emsp;对类和方法进行匹配，切入点应该提供匹配类，匹配方法的行为</p><p>思考4：如果在我们设计的框架中要能灵活的扩展切点，我们应该如何设计?</p><p>&emsp;&emsp;这又是一个要支持可多变的问题，像通知一样，我们定义一套标准接口，定义好基本行为，面向接口编程，屏蔽掉具体的实现。不管哪些方案，都实现匹配类，匹配方法的接口。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d6d11358de0143d1858561c4982b2c76.png" alt="image.png"></p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matchsClass</span><span class="params">(Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matchsMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来看看AspectJ的实现</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/55d3515a737640948fff96dc0e7cf136.png" alt="image.png"></p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">PointcutParser</span> <span class="variable">pp</span> <span class="operator">=</span> PointcutParser</span><br><span class="line">.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String expression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PointcutExpression pe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AspectJExpressionPointcut</span><span class="params">(String expression)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.expression = expression;</span><br><span class="line">pe = pp.parsePointcutExpression(expression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchsClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pe.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchsMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"><span class="type">ShadowMatch</span> <span class="variable">sm</span> <span class="operator">=</span> pe.matchesMethodExecution(method);</span><br><span class="line"><span class="keyword">return</span> sm.alwaysMatches();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getExpression</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-切面Aspect"><a href="#3-切面Aspect" class="headerlink" title="3.切面Aspect"></a>3.切面Aspect</h2><p>搞定了两个难点后，我们来看看用户该如何使用我们提供的东西</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b752948842cc48f8b3239aedd773eaca.png" alt="image.png"></p><p>为此我们需要创建对应的接口来管理。</p><h2 id="4-Advisor"><a href="#4-Advisor" class="headerlink" title="4. Advisor"></a>4. Advisor</h2><p>为用户提供更简单的外观，Advisor(通知者)组合Advice和Pointcut。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d0e7073bbf364748b4c8e55aab2e05b8.png" alt="image.png"></p><p>当然扩展的形式比较多：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/5e93b8fa9b4447f1b6f50a206b3b71e2.png" alt="image.png"></p><p>或者：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/671e360c737c4c8fb99c1dfe1fca7adb.png" alt="image.png"></p><h1 id="四、织入实现"><a href="#四、织入实现" class="headerlink" title="四、织入实现"></a>四、织入实现</h1><h2 id="1-织入的分析"><a href="#1-织入的分析" class="headerlink" title="1. 织入的分析"></a>1. 织入的分析</h2><p>&emsp;&emsp;织入要完成的是什么？织入其实就是要把用户提供的增强功能加到指定的方法上。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/952c32f23a444853896716f09d16c52e.png" alt="image.png"></p><p>思考1：在什么时候织入?</p><p>&emsp;&emsp;创建Bean实例的时候，在Bean初始化后，再对其进行增强。</p><p>思考2：如何确定bean要增强?</p><p>&emsp;&emsp;对bean类及方法挨个匹配用户配置的切面，如果有切面匹配就是要增强</p><p>思考3：如何实现织入？</p><p>&emsp;&emsp;代理方式</p><h2 id="2-织入的设计"><a href="#2-织入的设计" class="headerlink" title="2.织入的设计"></a>2.织入的设计</h2><p>&emsp;&emsp;为了更好的去设计织入的实现，先整理下AOP的使用流程。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/dac91a0adea34886956c1424d300a3a1.png" alt="image.png"></p><p>这里我们要考虑匹配、织入逻辑写到哪里？是写在BeanFactory中吗?</p><p>这时我们要考虑如果我们直接在BeanFactory中来处理，后续如果还有其他的需求是不是也要在BeanFactory中处理呢？这样操作有什么不好的地方呢？</p><ul><li>BeanFactory代码爆炸，不专情</li><li>不易扩展</li></ul><p>那我们应该要怎么来设计呢？</p><p>我们先来回顾下Bean的生产的过程</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6903c3b4a15e4b0dbd98444ce8402bf6.png" alt="image.png"></p><p>在这个过程中， 将来会有更多处理逻辑加入到Bean生产过程的不同阶段。我们现在最好是设计出能让我们后面不用再改BeanFactory的代码就能灵活的扩展。</p><p>这时我们可以考虑用观察者模式，通过在各个节点加入扩展点，加入注册机制。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/182e76a403594d458fdbcfa7116f7793.png" alt="image.png"></p><p>那么在这块我们就应用观察者模式来加入一个Bean的后置处理器 BeanPostProcessor</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/813c7b7bc10e4cdba9eec41196f8d34d.png" alt="image.png"></p><p>具体的我们在代码中来看看。</p><h2 id="3-织入的实现"><a href="#3-织入的实现" class="headerlink" title="3.织入的实现"></a>3.织入的实现</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h3><p>&emsp;&emsp;我们先定义了 BeanPostProcessor 接口，在这个接口中我们定义了相关的行为，也就是初始化之前和初始化之后要执行的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/20be9e28bbae4297b51f1005d669052b.png" alt="image.png"></p><p>&emsp;&emsp;那么在此处我们需要在BeanFactory对创建的Bean对象做初始化前后要校验是否需要做相关的增强操作。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/cfc12fead081451c91c21289be333683.png" alt="image.png"></p><p>&emsp;&emsp;在BeanFactory中我们提供了BeanPostProcessor的注册方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/d896894ce3d440879c6d0bcc1d521464.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/63797779f9bd4708910530fea1ad8909.png" alt="image.png"></p><p>那么结合BeanFactory要实现相关的Bean增强操作，我们要做的行为就是两方面</p><ol><li>创建相关的BeanPostProcessor，并注册到BeanFactory中</li><li>BeanFactory在初始化Bean前后判断是否有相关BeanPostProcessor，如果有做相关的增强处理</li></ol><p>&emsp;&emsp;有了上面的分析，那么我们要实现具体的织入就需要来看看在对应前置和后置方法中我们要实现的功能</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/9cfb5bbbd27b46fea5ae9e29d8ddd3b0.png" alt="image.png"></p><h3 id="3-2-判断是否需要增强"><a href="#3-2-判断是否需要增强" class="headerlink" title="3.2 判断是否需要增强"></a>3.2 判断是否需要增强</h3><p>&emsp;&emsp;我们如何判断Bean对象是否需要增强呢？其实就是需要判断该Bean是否满足用户定义的切入点表达式。也就是我们需要简单Bean所属的类和所有方法。然后遍历Advisor。取出advisor中的Pointcut来匹配类和方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/1e014b3ad0da491ab945fb96eca99f42.png" alt="image.png"></p><p>代码层面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*逻辑</span></span><br><span class="line"><span class="comment">1 判断Bean是否需要增强</span></span><br><span class="line"><span class="comment">2 创建代理来实现增强</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1 判断Bean是否需要增强</span></span><br><span class="line">      List&lt;Advisor&gt; matchAdvisors = getMatchedAdvisors(bean, beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2如有切面切中，创建代理来实现增强</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(matchAdvisors)) &#123;</span><br><span class="line">bean = <span class="built_in">this</span>.createProxy(bean, beanName, matchAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6588199bad1b4b5abd0223873a3893e0.png" alt="image.png"></p><h3 id="3-3-代理对象"><a href="#3-3-代理对象" class="headerlink" title="3.3 代理对象"></a>3.3 代理对象</h3><p>&emsp;&emsp;通过上面的分析如果Bean需要被增强，那么我们就需要创建Bean对应的代理对象了。代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在调用者和目标对象之间起到中介的作用；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3dc8e273c627417994e2827d558b6cf4.png" alt="image.png"></p><p>&emsp;&emsp;动态代理的实现方法有哪些?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/85ef8dd3afd943348c9962fa9268e1f4.png" alt="image.png"></p><p>JDK动态代理：</p><p>在运行时，对接口创建代理对象</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b853feeac2564e0eb56986c3fa71878a.png" alt="image.png"></p><p>cglib动态代理：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/6022f31f8e0a4970811a62905d89d915.png" alt="image.png"></p><h3 id="3-4-代理实现层设计"><a href="#3-4-代理实现层设计" class="headerlink" title="3.4 代理实现层设计"></a>3.4 代理实现层设计</h3><p>&emsp;&emsp;动态代理的实现方式有很多种，如何能够做到灵活的扩展呢？在这里我们同样可以通过 <code>抽象</code>和 <code>面向接口编程</code>来设计一套支持不同代理实现的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/b78eebb9e57a454e99dcb19191a3c786.png" alt="image.png"></p><p>&emsp;&emsp;有了上面的设计，然后就是需要考虑代理对象的创建了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/9aaf36179e6b42c4983c3f19cee46e0d.png" alt="image.png"></p><h3 id="3-5-增强逻辑实现"><a href="#3-5-增强逻辑实现" class="headerlink" title="3.5 增强逻辑实现"></a>3.5 增强逻辑实现</h3><p>&emsp;&emsp;代理对象搞定后我们需要考虑核心的问题就是怎么来实现我们要增强的逻辑呢？首先不管你用哪种方式来生成代理对象最终增强的逻辑代码是一样的。所以我们可以把这部分内容提炼出来。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3db0692f12a04b769c29616860be66a5.png" alt="image.png"></p><p>&emsp;&emsp;然后具体的应用Advice增强实现的逻辑为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/4055fce775164b0497385de84ca2cd05.png" alt="image.png"></p><p>注意此处用到了责任链模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">applyAdvices</span><span class="params">(Object target, Method method, Object[] args, List&lt;Advisor&gt; matchAdvisors,</span></span><br><span class="line"><span class="params">Object proxy, BeanFactory beanFactory)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 这里要做什么？   需要获取相关案例代码的+V：boge3306 备注:手写Spring</span></span><br><span class="line"><span class="comment">// 1、获取要对当前方法进行增强的advice</span></span><br><span class="line">List&lt;Object&gt; advices = AopProxyUtils.getShouldApplyAdvices(target.getClass(), method, matchAdvisors,</span><br><span class="line">beanFactory);</span><br><span class="line"><span class="comment">// 2、如有增强的advice，责任链式增强执行</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(advices)) &#123;</span><br><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 责任链式执行增强</span></span><br><span class="line"><span class="type">AopAdviceChainInvocation</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AopAdviceChainInvocation</span>(proxy, target, method, args, advices);</span><br><span class="line"><span class="keyword">return</span> chain.invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们前面的Creator要怎么使用AopProxy呢？这块我们可以通过工厂模式来处理</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1662118491062/3d68ad51c8834af6afa97f28cf482ac1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">AopProxy <span class="title function_">createAopProxy</span><span class="params">(Object bean, String beanName, List&lt;Advisor&gt; matchAdvisors, BeanFactory beanFactory)</span></span><br><span class="line"><span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得默认的AopProxyFactory实例</span></span><br><span class="line"><span class="comment"> *    需要获取相关案例代码的+V：boge3306 备注:手写Spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> AopProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> AopProxyFactory <span class="title function_">getDefaultAopProxyFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAopProxyFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这儿，完整的增强逻辑就梳理通了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-手写AOP&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-手写AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-手写AOP&quot;&gt;&lt;/a&gt;Spring源码手写篇-手写AOP&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;ems</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:18.977Z</published>
    <updated>2023-04-04T08:57:38.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码手写篇-手写DI"><a href="#Spring源码手写篇-手写DI" class="headerlink" title="Spring源码手写篇-手写DI"></a>Spring源码手写篇-手写DI</h1><p>&emsp;&emsp;简单回顾前面的手写IoC的内容。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/2ff7d10e3c694d35a5a5643826198a44.png" alt="image.png"></p><h1 id="一、DI介绍"><a href="#一、DI介绍" class="headerlink" title="一、DI介绍"></a>一、DI介绍</h1><p>&emsp;&emsp;DI(Dependency injection)依赖注入。对象之间的依赖由容器在运行期决定，即容器动态的将某个依赖注入到对象之中。说的直白点就是给Bean对象的成员变量赋值。</p><p>&emsp;&emsp;在这里我们就需要明白几个问题。</p><h2 id="1-哪些地方会有依赖"><a href="#1-哪些地方会有依赖" class="headerlink" title="1. 哪些地方会有依赖"></a>1. 哪些地方会有依赖</h2><ul><li>构造参数依赖</li><li>属性依赖</li></ul><h2 id="2-依赖注入的本质是什么？"><a href="#2-依赖注入的本质是什么？" class="headerlink" title="2. 依赖注入的本质是什么？"></a>2. 依赖注入的本质是什么？</h2><p>&emsp;&emsp;依赖注入的本质是 <code>赋值</code>。赋值有两种情况</p><ol><li>给有参构造方法赋值</li><li>给属性赋值</li></ol><h2 id="3-参数值、属性值有哪些？"><a href="#3-参数值、属性值有哪些？" class="headerlink" title="3. 参数值、属性值有哪些？"></a>3. 参数值、属性值有哪些？</h2><p>&emsp;&emsp;具体赋值有两种情况：直接值和Bean依赖。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> clsss Girl&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">char</span> cup,Boy boyfriend)</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-直接赋值有哪些？"><a href="#4-直接赋值有哪些？" class="headerlink" title="4.  直接赋值有哪些？"></a>4.  直接赋值有哪些？</h2><ul><li>基本数据类型：String、int 等</li><li>数组，集合</li><li>map</li></ul><h1 id="二、构造注入"><a href="#二、构造注入" class="headerlink" title="二、构造注入"></a>二、构造注入</h1><p>&emsp;&emsp;我们先来看看构造参数注入的情况应该要如何解决。</p><h2 id="1-构造注入分析"><a href="#1-构造注入分析" class="headerlink" title="1.构造注入分析"></a>1.构造注入分析</h2><p>&emsp;&emsp;我们应该如何定义构造参数的依赖？也就是我们需要通过构造方法来创建实例，然后对应的构造方法我们需要传入对应的参数。如果不是通过IoC来处理，我们可以直接通过如下的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;小丽&quot;</span>,<span class="number">20</span>,<span class="string">&#x27;C&#x27;</span>,boy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过直接赋值的方式就可以了。但是在IoC中我们需要通过反射的方式来处理。那么我们在通过反射操作的时候就需要能获取到对应的构造参数的依赖了，这时我们得分析怎么来存储我们的构造参数的依赖了。构造参数的依赖有两个特点：</p><ul><li>数量</li><li>顺序</li></ul><p>&emsp;&emsp;上面的例子中的参数</p><ol><li>小丽</li><li>20</li><li>‘C’</li><li>boy,是一个依赖Bean</li></ol><p>&emsp;&emsp;参数可以有多个，我们完全可以通过List集合来存储，而且通过添加数据的顺序来决定构造参数的顺序了。但是这里有一个问题，如何表示Bean依赖呢？直接值我们直接添加到集合中就可以了，但是Bean依赖，我们还没有创建对应的对象，这时我们可以维护一个自定义对象，来绑定相关的关系。</p><h2 id="2-BeanReference"><a href="#2-BeanReference" class="headerlink" title="2. BeanReference"></a>2. BeanReference</h2><p>&emsp;&emsp;BeanReference就是用来说明bean依赖的：也就是这个属性依赖哪个类型的Bean</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/446cfe8bf3d8430aa0453b7bac9ce761.png" alt="image.png"></p><p>&emsp;&emsp;可以根据name来依赖，也可以按照Type来依赖。当然我们的程序中还有一点需要考虑，就是如何来区分是直接值还是Bean依赖呢？有了上面的设计其实就很容易判断了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( obj instance BeanReference)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然还有一种比较复杂的情况如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/0f3a742092ff4d3ab8dad9c93971befc.png" alt="image.png"></p><p>&emsp;&emsp;直接值是数组或者集合等，同时容器中的元素是Bean依赖，针对这种情况元素值还是需要用BeanReference来处理的。Bean工厂在处理时需要遍历替换。</p><h2 id="3-BeanDefinition实现"><a href="#3-BeanDefinition实现" class="headerlink" title="3. BeanDefinition实现"></a>3. BeanDefinition实现</h2><p>&emsp;&emsp;接下来我们看看如何具体的来实现DI基于构造参数依赖的相关操作。首先是定义的相关处理了。我们需要在 <code>BeanDefinition</code>中增加构造参数的获取的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/35d2d357b2834371a1e61ec65a30de64.png" alt="image.png"></p><p>&emsp;&emsp;然后我们需要在默认的实现GenericBeanDefinition中增加对应的方法来处理。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/9ae87b696cd247178bb994c416022445.png" alt="image.png"></p><p>&emsp;&emsp;定义后我们可以测试下对应的应用，定义个ABean，依赖了CBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABean</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CBean cb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(String name, CBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了含有CBean参数的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(String name, CCBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了含有CCBean参数的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(CBean cb)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.cb = cb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomthing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Abean.doSomthing(): &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; cb.name=&quot;</span> + <span class="built_in">this</span>.cb.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ABean.init() 执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ABean.destroy() 执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在实例化时我们需要做相关的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">bd.setBeanClass(ABean.class);</span><br><span class="line"><span class="comment">// 定义的构造参数的依赖</span></span><br><span class="line">List&lt;Object&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">args.add(<span class="string">&quot;abean01&quot;</span>);</span><br><span class="line"><span class="comment">// Bean依赖 通过BeanReference 来处理</span></span><br><span class="line">args.add(<span class="keyword">new</span> <span class="title class_">BeanReference</span>(<span class="string">&quot;cbean&quot;</span>));</span><br><span class="line">bd.setConstructorArgumentValues(args);</span><br><span class="line">bf.registerBeanDefinition(<span class="string">&quot;abean&quot;</span>, bd);</span><br></pre></td></tr></table></figure><p>构造参数传递后，接下来其实我们就需要要在 <code>BeanFactory</code>中来实现构造参数的注入了</p><h2 id="4-BeanFactory实现"><a href="#4-BeanFactory实现" class="headerlink" title="4.BeanFactory实现"></a>4.BeanFactory实现</h2><p>&emsp;&emsp;前面我们在BeanFactory中实现Bean对象的创建有几种方式</p><ul><li>构造方法创建</li><li>工厂静态方法</li><li>工厂成员方法</li></ul><p>&emsp;&emsp;我们在通过构造方法创建其实是通过无参构造方法来处理的，这时我们需要改变这块的逻辑，通过有参构造方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByConstructor</span><span class="params">(BeanDefinition bd)</span></span><br><span class="line"><span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bd.getBeanClass().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e1) &#123;</span><br><span class="line">log.error(<span class="string">&quot;创建bean的实例异常,beanDefinition：&quot;</span> + bd, e1);</span><br><span class="line"><span class="keyword">throw</span> e1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们就需要对上面的方法做出改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByConstructor</span><span class="params">(BeanDefinition bd)</span></span><br><span class="line"><span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">       <span class="comment">// 1. 得到真正的参数值</span></span><br><span class="line">List&lt;?&gt; constructorArgumentValues = bd.getConstructorArgumentValues(); </span><br><span class="line">       <span class="comment">// 2.根据对应的构造参数依赖获取到对应的 Constructor </span></span><br><span class="line">       <span class="type">Constructor</span>  <span class="variable">constructor</span> <span class="operator">=</span> 得到对应的构造方法</span><br><span class="line">       <span class="comment">// 3.用实际参数值调用构造方法创建对应的对象</span></span><br><span class="line">       <span class="keyword">return</span> constructor.newInstance(Object ... 实参值); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的分析我们需要获取对应的构造器。这块我们需要通过反射来获取了。下面是具体的实现逻辑</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/7a6313aa1834481b9335c5759677363b.png" alt="image.png"></p><p>&emsp;&emsp;根据上面的分析，我们实现的逻辑分为两步</p><ol><li>先根据参数的类型进行精确匹配查找，如果没有找到，继续执行第二步操作</li><li>获得所有的构造方法，遍历构造方法，通过参数数量过滤，再比对形参与实参的类型</li></ol><p>&emsp;&emsp;因为这里有个情况，实参是Boy，构造方法的形参是Person，第一种精确匹配就没有办法关联了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/4a045636aa6147a6a72f42bedcf2c312.png" alt="image.png"></p><p>具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; determineConstructor(BeanDefinition bd, Object[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*判定构造方法的逻辑应是怎样的？</span></span><br><span class="line"><span class="comment">    1 先根据参数的类型进行精确匹配查找，如未找到，则进行第2步查找；</span></span><br><span class="line"><span class="comment">    2获得所有的构造方法，遍历，通过参数数量过滤，再比对形参类型与实参类型。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; ct = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有参数，则用无参构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bd.getBeanClass().getConstructor(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 先根据参数的类型进行精确匹配查找</span></span><br><span class="line">    Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[args.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object p : args) &#123;</span><br><span class="line">        paramTypes[j++] = p.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ct = bd.getBeanClass().getConstructor(paramTypes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 这个异常不需要处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2 没有精确参数类型匹配的，获得所有的构造方法，遍历，通过参数数量过滤，再比对形参类型与实参类型。</span></span><br><span class="line">        <span class="comment">// 判断逻辑：先判断参数数量，再依次比对形参类型与实参类型</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; ct0 : bd.getBeanClass().getConstructors()) &#123;</span><br><span class="line">            Class&lt;?&gt;[] paramterTypes = ct0.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (paramterTypes.length == args.length) &#123;   <span class="comment">//通过参数数量过滤</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramterTypes.length; i++) &#123; <span class="comment">//再依次比对形参类型与实参类型是否匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (!paramterTypes[i].isAssignableFrom(args[i].getClass())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span> outer; <span class="comment">//参数类型不可赋值（不匹配），跳到外层循环，继续下一个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ct = ct0;  <span class="comment">//匹配上了</span></span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ct;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;不存在对应的构造方法！&quot;</span> + bd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们考虑的是BeanFactory通过构造器来获取对象的逻辑，那如果我们是通过静态工厂方法或者成员工厂方法的方式来处理的，那么构造参数依赖的处理是否和前面的是一样的呢？其实是差不多的，我们需要根据对应的构造参数来推断对应的工厂方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态工厂方法</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByStaticFactoryMethod</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    Object[] realArgs = <span class="built_in">this</span>.getConstructorArgumentValues(bd);</span><br><span class="line">    Class&lt;?&gt; type = bd.getBeanClass();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.determineFactoryMethod(bd, realArgs, type);</span><br><span class="line">    <span class="keyword">return</span> m.invoke(type, realArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂bean方式来构造对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createInstanceByFactoryBean</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    Object[] realArgs = <span class="built_in">this</span>.getConstructorArgumentValues(bd);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.determineFactoryMethod(bd, realArgs, <span class="built_in">this</span>.getType(bd.getFactoryBeanName()));</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="built_in">this</span>.doGetBean(bd.getFactoryBeanName());</span><br><span class="line">    <span class="keyword">return</span> m.invoke(factoryBean, realArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-缓存功能"><a href="#5-缓存功能" class="headerlink" title="5.缓存功能"></a>5.缓存功能</h2><p>&emsp;&emsp;对于上面的处理过程相信大家应该清楚了，我们通过推断也得到了对应的构造方法或者对应的工厂方法，那么我们可以不可以在下次需要再次获取的时候省略掉推导的过程呢？显然我们可以在BeanDefinition中增加缓存方法可以实现这个需求。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/f57d7f7cf8dc47cfb7a95e09bc26afb0.png" alt="image.png"></p><h2 id="6-循环依赖问题"><a href="#6-循环依赖问题" class="headerlink" title="6. 循环依赖问题"></a>6. 循环依赖问题</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/8a8ff504fe7a43b3a7d0e16d06917211.png" alt="image.png"></p><p>&emsp;&emsp;上图是循环依赖的三种情况，虽然方式有点不一样，但是循环依赖的本质是一样的，就你的完整创建要依赖与我，我的完整创建也依赖于你。相互依赖从而没法完整创建造成失败。</p><p>&emsp;&emsp;我们通过构造参数依赖是完全可能出现上面的情况的，那么这种情况我们能解决吗？构造依赖的情况我们是解决不了的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestService1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestService1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TestService2</span> <span class="variable">testService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestService2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestService2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">TestService1</span> <span class="variable">testService1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestService1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;既然解决不了，那么我们在程序中如果出现了，应该要怎么来解决呢？其实我们可以在创建一个Bean的时候记录下这个Bean，当这个Bean创建完成后我们在移除这个Bean，然后我们在getBean的时候判断记录中是否有该Bean，如果有就判断为循环依赖，并抛出异常。数据结构我们可以通过Set集合来处理。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/a3b95f3dfbca49ee8ff576908a30e2dd.png" alt="image.png"></p><p>到此构造注入的实现我们就搞定了。</p><h1 id="三、属性注入"><a href="#三、属性注入" class="headerlink" title="三、属性注入"></a>三、属性注入</h1><p>&emsp;&emsp;上面搞定了构造注入的方式。接下来我们再看看属性注入的方式有什么需要注意的地方。</p><h2 id="1-属性依赖分析"><a href="#1-属性依赖分析" class="headerlink" title="1. 属性依赖分析"></a>1. 属性依赖分析</h2><p>&emsp;&emsp;属性依赖就是某个属性依赖某个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cup;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Boy&gt; boyFriends;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在获取实例对象后如何根据相关的配置来给对应的属性来赋值呢？这时我们可以定义一个实体类 <code>PropertyValue</code>来记录相关的属性和值。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/9bd0d13f60344e41b20e45cec45dcb24.png" alt="image.png"></p><h2 id="2-BeanDefinition实现"><a href="#2-BeanDefinition实现" class="headerlink" title="2.BeanDefinition实现"></a>2.BeanDefinition实现</h2><p>&emsp;&emsp;这时我们就需要在BeanDefinition中关联相关属性信息了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/6f9341b7eb264f0399e8d6add384d081.png" alt="image.png"></p><h2 id="3-BeanFactory实现"><a href="#3-BeanFactory实现" class="headerlink" title="3.BeanFactory实现"></a>3.BeanFactory实现</h2><p>&emsp;&emsp;然后我们在BeanFactory的默认实现DefaultBeanFactory中实现属性值的依赖注入。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建好实例对象</span></span><br><span class="line"><span class="comment">// 给属性依赖赋值</span></span><br><span class="line">this.set<span class="constructor">PropertyDIValues(<span class="params">bd</span>,<span class="params">instance</span>)</span>;</span><br><span class="line"><span class="comment">// 执行初始化相关方法</span></span><br><span class="line">this.<span class="keyword">do</span><span class="constructor">Init(<span class="params">bd</span>,<span class="params">instance</span>)</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给入属性依赖</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPropertyDIValues</span><span class="params">(BeanDefinition bd, Object instance)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(bd.getPropertyValues())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : bd.getPropertyValues()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(pv.getName())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = instance.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">p</span> <span class="operator">=</span> clazz.getDeclaredField(pv.getName());</span><br><span class="line">        <span class="comment">//暴力访问  private</span></span><br><span class="line">        p.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        p.set(instance, <span class="built_in">this</span>.getOneArgumentRealValue(pv.getValue()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-循环依赖问题"><a href="#4-循环依赖问题" class="headerlink" title="4.循环依赖问题"></a>4.循环依赖问题</h2><p>&emsp;&emsp;在构造参数依赖中我们发现没有办法解决，在属性依赖中同样会存在循环依赖的问题，这时我们能解决吗？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/f33309e8d2784205b86197b344f02512.png" alt="image.png"></p><p>&emsp;&emsp;其实这种情况我们不在IoC场景下非常好解决。如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boy b = <span class="keyword">new</span> <span class="constructor">Boy()</span>;</span><br><span class="line">Girl g = <span class="keyword">new</span> <span class="constructor">Girl()</span>;</span><br><span class="line">b.set<span class="constructor">Girl(<span class="params">g</span>)</span>;</span><br><span class="line">g.set<span class="constructor">Boy(<span class="params">b</span>)</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是在IoC好像不是太好解决：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/7dbe9a7686d34038b76f9a64e4e1b765.png" alt="image.png"></p><p>&emsp;&emsp;针对这种情况我们需要通过 <code>提前暴露</code>来解决这个问题，具体看代码!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doEarlyExposeBuildingBeans</span><span class="params">(String beanName, Object instance)</span> &#123;</span><br><span class="line">    Map&lt;String,Object&gt; earlyExposeBuildingBeansMap = earlyExposeBuildingBeans.get();</span><br><span class="line">    <span class="keyword">if</span>(earlyExposeBuildingBeansMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        earlyExposeBuildingBeansMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        earlyExposeBuildingBeans.set(earlyExposeBuildingBeansMap);</span><br><span class="line">    &#125;</span><br><span class="line">    earlyExposeBuildingBeansMap.put(beanName,instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后现阶段已经实现的类图结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661430376021/6122a088f15f455993b9dff1113bd255.png" alt="image.png"></p><p>扩展作业：加入Bean配置的条件依赖生效的支持</p><p>在Bean定义配置中可以指定它条件依赖某些Bean或类，当这些Bean或类存在时，这个bean的配置才能生效!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码手写篇-手写DI&quot;&gt;&lt;a href=&quot;#Spring源码手写篇-手写DI&quot; class=&quot;headerlink&quot; title=&quot;Spring源码手写篇-手写DI&quot;&gt;&lt;/a&gt;Spring源码手写篇-手写DI&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;简单</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T11:42:17.698Z</published>
    <updated>2023-04-04T08:57:38.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手写篇-手写IoC"><a href="#手写篇-手写IoC" class="headerlink" title="手写篇-手写IoC"></a>手写篇-手写IoC</h1><h1 id="一、IoC分析"><a href="#一、IoC分析" class="headerlink" title="一、IoC分析"></a>一、IoC分析</h1><h2 id="1-Spring的核心"><a href="#1-Spring的核心" class="headerlink" title="1.Spring的核心"></a>1.Spring的核心</h2><p>&emsp;&emsp;在Spring中非常核心的内容是 <code>IOC</code>和 <code>AOP</code>.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/cd57c59d998e49eb87a2272f0f4da099.png" alt="image.png"></p><h2 id="2-IoC的几个疑问"><a href="#2-IoC的几个疑问" class="headerlink" title="2.IoC的几个疑问?"></a>2.IoC的几个疑问?</h2><h3 id="2-1-IoC是什么？"><a href="#2-1-IoC是什么？" class="headerlink" title="2.1 IoC是什么？"></a>2.1 IoC是什么？</h3><p>&emsp;&emsp;IoC:Inversion of Control 控制反转，简单理解就是：依赖对象的获得被反转了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/80310b140f9342a8b6001e1f456eb8a3.png" alt="image.png"></p><h3 id="2-2-IoC有什么好处"><a href="#2-2-IoC有什么好处" class="headerlink" title="2.2 IoC有什么好处?"></a>2.2 IoC有什么好处?</h3><p>IoC带来的好处：</p><ol><li>代码更加简洁，不需要去new 要使用的对象了</li><li>面向接口编程，使用者与具体类，解耦，易扩展、替换实现者</li><li>可以方便进行AOP编程</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/7ad2ade8947b4113a4dac3f3395e715f.png" alt="image.png"></p><h3 id="2-3-IoC容器做了什么工作"><a href="#2-3-IoC容器做了什么工作" class="headerlink" title="2.3 IoC容器做了什么工作?"></a>2.3 IoC容器做了什么工作?</h3><p>&emsp;&emsp;IoC容器的工作：负责创建，管理类实例，向使用者提供实例。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/7cc654e667b34e2bb05003b4c320b6e5.png" alt="image.png"></p><h3 id="2-4-IoC容器是否是工厂模式的实例"><a href="#2-4-IoC容器是否是工厂模式的实例" class="headerlink" title="2.4 IoC容器是否是工厂模式的实例?"></a>2.4 IoC容器是否是工厂模式的实例?</h3><p>&emsp;&emsp;是的，IoC容器负责来创建类实例对象，需要从IoC容器中get获取。IoC容器我们也称为Bean工厂。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/480d5fa007b44e648d49d34c77aeb4cd.png" alt="image.png"></p><p>&emsp;&emsp;那么我们一直说的Bean是什么呢？bean：组件，也就是类的对象!!!</p><h1 id="二、IoC实现"><a href="#二、IoC实现" class="headerlink" title="二、IoC实现"></a>二、IoC实现</h1><p>&emsp;&emsp;通过上面的介绍我们也清楚了IoC的核心就是Bean工厂，那么这个Bean工厂我们应该要如何来设计实现它呢？我们来继续分析。</p><h2 id="1-Bean工厂的作用"><a href="#1-Bean工厂的作用" class="headerlink" title="1.Bean工厂的作用"></a>1.Bean工厂的作用</h2><p>&emsp;&emsp;首先Bean工厂的作用我们上面也分析了就是创建，管理Bean，并且需要对外提供Bean的实例。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/521438fa1977428c8765207d9c0130e5.png" alt="image.png"></p><h2 id="2-Bean工厂的初步设计"><a href="#2-Bean工厂的初步设计" class="headerlink" title="2.Bean工厂的初步设计"></a>2.Bean工厂的初步设计</h2><p>&emsp;&emsp;基于Bean工厂的基本作用，我们可以来分析Bean工厂应该具备的相关行为。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/1378defbcd8147c1ae53601cef61349e.png" alt="image.png"></p><p>&emsp;&emsp;首先Bean工厂应该要对外提供获取bean实例的方法，所以需要定义一个getBean()方法。同时工厂需要知道生产的bean的类型，所以getBean()方法需要接受对应的参数，同时返回类型这块也可能有多个类型，我们就用Object来表示。这样Bean工厂的定义就出来了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/e9e8f44a98fd46779a75543398b806ad.png" alt="image.png"></p><p>&emsp;&emsp;上面定义了Bean工厂对外提供bean实例的方法，但是Bean工厂如何知道要创建上面对象，怎么创建该对象呢？</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/d076f40b527e433982299f233a9dc404.png" alt="image.png"></p><p>&emsp;&emsp;所以在这里我们得把Bean的定义信息告诉BeanFactory工厂，然后BeanFactory工厂根据Bean的定义信息来生成对应的bean实例对象。所以在这儿我们要考虑两个问题</p><ol><li>我们需要定义一个模型来表示该如何创建Bean实例的信息，也就是Bean定义。</li><li>Bean工厂需要提供行为来接收这些Bean的定义信息。</li></ol><h2 id="3-Bean的定义"><a href="#3-Bean的定义" class="headerlink" title="3.Bean的定义"></a>3.Bean的定义</h2><p>&emsp;&emsp;根据上面的接收我们就清楚了Bean定义的意义了。那么我们来定义Bean定义的模型要考虑几个问题。</p><h3 id="3-1-Bean定义的作用是什么"><a href="#3-1-Bean定义的作用是什么" class="headerlink" title="3.1 Bean定义的作用是什么?"></a>3.1 Bean定义的作用是什么?</h3><p>&emsp;&emsp;作用肯定是告诉Bean工厂应该如何来创建某类的Bean实例</p><h3 id="3-2-获取实例的方式有哪些"><a href="#3-2-获取实例的方式有哪些" class="headerlink" title="3.2 获取实例的方式有哪些?"></a>3.2 获取实例的方式有哪些?</h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/364e061785e5406eae76cdba339a2248.png" alt="image.png"></p><h3 id="3-3-我们需要在BeanDefinition中给Bean工厂提供哪些信息"><a href="#3-3-我们需要在BeanDefinition中给Bean工厂提供哪些信息" class="headerlink" title="3.3 我们需要在BeanDefinition中给Bean工厂提供哪些信息?"></a>3.3 我们需要在BeanDefinition中给Bean工厂提供哪些信息?</h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2276051d92ac46eda9e758efea531bf3.png" alt="image.png"></p><p>在BeanDefinition顶级接口里，我们需要提供第一种传入bean类型通过反射得到bean，第二种通过工厂方法返回一个bean，第三种通过得到一个工厂对象，然后通过工厂对象去得到一个bean。</p><p>这样一来我们就清楚了BeanDefinition应该要具有的基本功能了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/d40a838ed1094dca8de7be1d74b49d58.png" alt="image.png"></p><h3 id="3-4-增强功能要求"><a href="#3-4-增强功能要求" class="headerlink" title="3.4 增强功能要求"></a>3.4 增强功能要求</h3><p>&emsp;&emsp;当然我们可以在现有的基础上增强要求，比如Bean工厂创建的是单例对象，具有特定的初始化方法和销毁逻辑的方法。</p><p> <img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2e5875faa8204904b132ce9fe29d57c9.png" alt="image.png"></p><p>&emsp;&emsp;同时创建BeanDefinition的一个通用实现类：GenericBeanDefinition。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/2bbd7cd1aa7f479cad6d99d793d1ded8.png" alt="image.png"></p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_SINGLETION</span> <span class="operator">=</span> <span class="string">&quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> <span class="string">&quot;prototype&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; getBeanClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Scope</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否原型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂bean名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getInitMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getDestroyMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验bean定义的合法性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 没定义class,工厂bean或工厂方法没指定，则不合法。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getBeanClass() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(getFactoryBeanName()) || StringUtils.isBlank(getFactoryMethodName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了类，又定义工厂bean，不合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getBeanClass() != <span class="literal">null</span> &amp;&amp; StringUtils.isNotBlank(getFactoryBeanName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Bean的注册-BeanDefinitionRegistry"><a href="#4-Bean的注册-BeanDefinitionRegistry" class="headerlink" title="4.Bean的注册-BeanDefinitionRegistry"></a>4.Bean的注册-BeanDefinitionRegistry</h2><p>&emsp;&emsp;Bean的定义清楚后，我们要考虑的就是如何实现BeanDefinition和BeanFactory的关联了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/ba1ed12a2ce845d090f600a84a9eaca9.png" alt="image.png"></p><p>&emsp;&emsp;在这儿我们可以专门定义一个 <code>BeanDefinitionRegistry</code>来实现Bean定义的注册功能。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/8a4e48e221b245998c1d4197185bf466.png" alt="image.png"></p><p>&emsp;&emsp;那么我们需要考虑 BeanDefinitionRegistry 应该具备的功能，其实也简单就两个：</p><ol><li>注册BeanDefinition - 注册</li><li>获取BeanDefinition - 发现</li></ol><p>&emsp;&emsp;同时为了保证能够区分每个BeanDefinition的定义信息，我们得给每一个Bean定义一个唯一的名称。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/6132d08636ae4161899f801b90af16eb.png" alt="image.png"></p><p>具体实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionRegistException;</span><br><span class="line"><span class="comment">//根据名称去获取</span></span><br><span class="line">BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line"><span class="comment">// 判断当前这个注册器有没有这个bean定义</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(String beanName)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-BeanFactory实现-DefaultBeanFactory"><a href="#5-BeanFactory实现-DefaultBeanFactory" class="headerlink" title="5.BeanFactory实现 - DefaultBeanFactory"></a>5.BeanFactory实现 - DefaultBeanFactory</h2><p>&emsp;&emsp;到现在为止我们来看看已经实现的相关设计功能：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/fe3fdeaf5ee54ab3831bedec83c22c68.png" alt="image.png"></p><p>&emsp;&emsp;通过上面的分析我们接下来就要考虑BeanFactory的功能实现了。我们先来实现一个最基础的默认的Bean工厂：DefaultBeanFactory。需要DefaultBeanFactory实现如下的5个功能</p><ol><li>实现Bean定义信息的注册</li><li>实现Bean工厂定义的getBean方法</li><li>实现初始化方法的执行</li><li>实现单例的要求</li><li>实现容器关闭是执行单例的销毁操作</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/4541d5156de04e888f34458ab920f8f1.png" alt="image.png"></p><p>具体看代码的案例代码，代码太多就不贴出来了。</p><p>思考：对于单例bean，我们可否提前实例化?</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/96597cfe7982448f96c3e68b8f6e6800.png" alt="image.png"></p><h1 id="三、IoC增强"><a href="#三、IoC增强" class="headerlink" title="三、IoC增强"></a>三、IoC增强</h1><p>&emsp;&emsp;上面第一版本的IoC容器我们已经实现了，我们可以在这个基础上来基础迭代增强IoC的功能</p><h2 id="1-Bean别名的增强"><a href="#1-Bean别名的增强" class="headerlink" title="1.Bean别名的增强"></a>1.Bean别名的增强</h2><p>&emsp;&emsp;Bean除了标识唯一的名称外，还可以有任意个别名，别名也是唯一的。别名的特点</p><ol><li>可以有多个别名</li><li>也可以是别名的别名</li><li>别名也是唯一的</li></ol><p>&emsp;&emsp;&emsp;实现的时候我们需要考虑的问题</p><ol><li>数据结构</li><li>功能点</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/a6221d511b6847a9ba05b30421b3e757.png" alt="image.png"></p><p>具体代码交给大家课后尝试实现。</p><h2 id="2-Type类型的增强"><a href="#2-Type类型的增强" class="headerlink" title="2. Type类型的增强"></a>2. Type类型的增强</h2><p>&emsp;&emsp;上面实现的是根据 bean的 <code>name</code>来获取Bean实例，我们还希望能扩展通过 <code>Type</code>来获取实例对象。这时对应的接口为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/8434bdc7e07b43c18721eb9a7deb65ec.png" alt="image.png"></p><p>&emsp;&emsp;也就是需要实现根据Type找到Bean对象的功能。正常的实例逻辑为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/1297dc776e044ca387c942d3a2b0468b.png" alt="image.png"></p><p>&emsp;&emsp;但是上面的实现方案有点吃性能，我们可以尝试优化下，我们可以提前把Type和Bean的对应关系找出来，然后用Map缓存起来处理。对应的存储方式通过Map来处理</p><p>我们需要考虑几个问题：</p><ol><li>Map中存储的数据用什么合适？</li><li>type和bean是一对一的关系吗？</li><li>何时建立该关系呢？</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/ac42f182995f48f09be17df34fd3f1f1.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; typeMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具体的实现我们可以在DefaultBeanFactory中添加一个buildTypeMap()方法来处理这个事情</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/da4b3e769f9a413d88db94a377ab501e.png" alt="image.png"></p><p>&emsp;&emsp;buildTypeMap()方法处理的逻辑如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/373378375858412e928714a1c49dc5d4.png" alt="image.png"></p><p>&emsp;&emsp;然后我们在BeanFactory中添加一个getType方法，封装获取Bean的Type的逻辑，方便buildTypeMap()方法的使用。最后就是getBean(Class<T>) 方法的实现了。因为Class对应的类型可能有多个，这时需要通过Primary来处理了。</T></p><p>IoC容器-核心部分类图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1661244485026/f48e4223891a4d63ad6357b959a94388.png" alt="image.png"></p><p>总结：应用设计的原则：</p><ol><li>抽象，行为抽象分类处理(接口)</li><li>继承，扩展功能</li><li>面向接口编程</li><li>单一职责原则</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手写篇-手写IoC&quot;&gt;&lt;a href=&quot;#手写篇-手写IoC&quot; class=&quot;headerlink&quot; title=&quot;手写篇-手写IoC&quot;&gt;&lt;/a&gt;手写篇-手写IoC&lt;/h1&gt;&lt;h1 id=&quot;一、IoC分析&quot;&gt;&lt;a href=&quot;#一、IoC分析&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-03-30T09:53:47.431Z</published>
    <updated>2023-04-04T08:57:38.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-spring整合"><a href="#mybatis-spring整合" class="headerlink" title="mybatis-spring整合"></a>mybatis-spring整合</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis-spring整合&quot;&gt;&lt;a href=&quot;#mybatis-spring整合&quot; class=&quot;headerlink&quot; title=&quot;mybatis-spring整合&quot;&gt;&lt;/a&gt;mybatis-spring整合&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://eizo01.github.io/posts/0.html"/>
    <id>https://eizo01.github.io/posts/0.html</id>
    <published>2023-01-13T12:00:00.000Z</published>
    <updated>2023-03-18T14:10:02.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ 都提供了事务相关功能） 、Saga 等等。</p><p>2PC、3PC 属于业务代码无侵入方案，都是基于 XA 规范衍生出来的实现，XA 规范是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。TCC、Saga 属于业务侵入方案，MQ 事务依赖于使用消息队列的场景，本地消息表不支持回滚。</p><p>开始介绍 2PC 和 3PC 之前，我们先来介绍一下 2PC 和 3PC 涉及到的一些角色（XA 规范的角色组成）：<br><img src="HTTP://zdwtop.cn/blog/image-20230314214742411.png" alt="分布式"><br>  ● AP（Application Program）：应用程序本身。<br>  ● RM（Resource Manager） ：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库（后文会以关系型数据库为例），一个分布式事务往往涉及到多个 RM。<strong>DB</strong><br>● TM（Transaction Manager） ：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</p><h2 id="2PC（两阶段提交协议）"><a href="#2PC（两阶段提交协议）" class="headerlink" title="2PC（两阶段提交协议）"></a>2PC（两阶段提交协议）</h2><p><img src="HTTPs://zdwtop.cn/blog/1666839398805-8d026011-316f-497a-9c11-e5a2e4a4b669.png" alt="2pc"></p><p>2PC（Two-Phase Commit）这三个字母的含义:</p><p>● 2 -&gt; 指代事务提交的 2 个阶段<br>● P-&gt; Prepare (准备阶段)<br>● C -&gt;Commit（提交阶段）</p><p>2PC 将事务的提交过程分为 2 个阶段：<strong>准备阶段</strong> 和 <strong>提交阶段</strong> 。</p><h4 id="准备阶段-Prepare"><a href="#准备阶段-Prepare" class="headerlink" title="准备阶段(Prepare)"></a><strong>准备阶段(Prepare)</strong></h4><p>准备阶段的核心是“询问”事务参与者执行本地数据库事务操作是否成功。</p><p>准备阶段的工作流程：</p><p>1、 <strong>事务协调者/管理者（后文简称 TM）</strong>： 向所有涉及到的 <strong>事务参与者（后文简称 RM）</strong> 发送消息询问：“你是否可以执行事务操作呢？”，并等待其答复。<br>2 、<strong>RM</strong> 接收到消息之后，开始执行本地数据库事务预操作比如写 redo log/undo log 日志，<strong>此时并不会提交事务 。</strong><br>3 、RM 如果执行本地数据库事务操作成功，那就回复“Yesdb”表示我已就绪，否则就回复“No”表示我未就绪。</p><h4 id="提交阶段-Commit"><a href="#提交阶段-Commit" class="headerlink" title="提交阶段(Commit)"></a><strong>提交阶段(Commit)</strong></h4><p>提交阶段的核心是“询问”事务参与者提交本地事务是否成功。</p><p>当所有事务参与者都是“就绪”状态的话：</p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以提交事务啦！”（Commit 消息）<br>2、<strong>RM</strong> 接收到 <strong>Commit 消息</strong> 后执行 <strong>提交本地数据库事务</strong> 操作，执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经提交” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>事务参与者</strong> 的 ACK 消息 之后，整个分布式事务过程正式结束。</p><p><strong>当任一事务参与者是“未就绪”状态的话：</strong></p><p>1、<strong>TM</strong> 向所有参与者发送消息：“你们可以执行回滚操作了！”<strong>（Rollback 消息）。</strong><br>2、<strong>RM</strong> 接收到 Rollback 消息 后执行 <strong>本地数据库事务回滚</strong> 执行完成之后 <strong>释放整个事务期间所占用的资源。</strong><br>3、<strong>RM</strong> 回复：“事务已经回滚” <strong>（ACK 消息）。</strong><br>4、<strong>TM</strong> 收到所有 <strong>RM 的 ACK 消息</strong> 之后，中断事务。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下 2PC 两阶段中比较重要的一些点：</p><p>1、<strong>准备阶段</strong> 的主要目的是<strong>测试 RM</strong> 能否执行 <strong>本地数据库事务</strong> 操作（!!!注意：<strong>这一步并不会提交事务</strong>）。<br>2、<strong>提交阶段</strong> 中 <strong>TM</strong> 会根据 <strong>准备阶段 中 RM 的消息</strong>来决定是执行<strong>事务提交</strong>还是<strong>回滚操作</strong>。<br>3、提交阶段 之后一定会结束当前的分布式事务</p><h5 id="2PC-的优点："><a href="#2PC-的优点：" class="headerlink" title="2PC 的优点："></a><strong>2PC 的优点：</strong></h5><p>● 实现起来非常简单，各大主流数据库比如 MySQL、Oracle 都有自己实现。<br>● 针对的是数据强一致性。不过，仍然可能存在数据不一致的情况。</p><h5 id="2PC-存在的问题："><a href="#2PC-存在的问题：" class="headerlink" title="2PC 存在的问题："></a><strong>2PC 存在的问题：</strong></h5><p>● <strong>同步阻塞</strong> ：事务参与者会在正式提交事务之前会一直占用相关的资源。比如用户小明转账给小红，那其他事务也要操作用户小明或小红的话，就会阻塞。<br>● <strong>数据不一致</strong> ：由于网络问题或者TM宕机都有可能会造成数据不一致的情况。比如在第2阶段（提交阶段），部分网络出现问题导致部分参与者收不到 Commit/Rollback 消息的话，就会导致数据不一致。<br>● <strong>单点问题</strong> ： TM在其中也是一个很重要的角色，如果TM在准备(Prepare)阶段完成之后挂掉的话，事务参与者就会一直卡在提交(Commit)阶段。</p><h2 id="3PC（三阶段提交协议）"><a href="#3PC（三阶段提交协议）" class="headerlink" title="3PC（三阶段提交协议）"></a>3PC（三阶段提交协议）</h2><p>3PC 是人们在 2PC 的基础上做了一些优化得到的。3PC 把 2PC 中的 准备阶段(Prepare) 做了进一步细化，分为 2 个阶段：</p><p>● 准备阶段(CanCommit)<br>● 预提交阶段(PreCommit)</p><h4 id="准备阶段-CanCommit"><a href="#准备阶段-CanCommit" class="headerlink" title="准备阶段(CanCommit)"></a>准备阶段(CanCommit)</h4><p>这一步不会执行事务操作，只是向 <strong>RM 发送 准备请求</strong> ，顺便询问一些信息比如事务参与者能否执行本地数据库事务操作。RM 回复“Yes”、“No”或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有参与者发送“Abort”消息），否则进入 <strong>预提交阶段(PreCommit) 。</strong></p><h4 id="预提交阶段-PreCommit"><a href="#预提交阶段-PreCommit" class="headerlink" title="预提交阶段(PreCommit)"></a>预提交阶段(PreCommit)</h4><p><strong>TM</strong> 向所有涉及到的 RM 发送 <strong>预提交请求</strong> ，RM 回复“Yes”、“No”（最后的反悔机会）或者直接超时。</p><p>如果<strong>任一 RM 回复“No”或者直接超时的话</strong>，就中断事务（向所有事务参与者发送“abort”消息），否则进入 <strong>执行事务提交阶段</strong>（DoCommit） 。</p><p>当所有 RM 都返回“Yes”之后， RM 才会执行本地数据库事务预操作比如写 <strong>redo log/undo log</strong> 日志。</p><h4 id="执行事务提交阶段（DoCommit）"><a href="#执行事务提交阶段（DoCommit）" class="headerlink" title="执行事务提交阶段（DoCommit）"></a>执行事务提交阶段（DoCommit）</h4><p>执行事务提交（DoCommit） 阶段就开始进行真正的事务提交。</p><p>TM 向所有涉及到的 RM 发送 <strong>执行事务提交请求</strong> ，<strong>RM 收到消息后开始正式提交事务</strong>，并在完成事务提交后释放占用的资源。</p><p>如果 TM 收到所有 RM 正确提交事务的消息的话，表示事务正常完成。如果任一 RM 没有正确提交事务或者超时的话，就中断事务，TM 向所有 RM 发送“Abort”消息。RM 接收到 Abort 请求后，执行本地数据库事务回滚，后面的步骤就和 2PC 中的类似了。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>3PC 除了将2PC 中的准备阶段(Prepare) 做了进一步细化之外，还做了哪些改进？</strong></p><p>3PC 还同时在事务管理者和事务参与者中引入了 <strong>超时机制</strong> ，如果在一定时间内没有收到事务参与者的消息就默认失败，进而避免事务参与者一直阻塞占用资源。2PC 中只有事务管理者才拥有超时机制，当事务参与者长时间无法与事务协调者通讯的情况下（比如协调者挂掉了），就会导致无法释放资源阻塞的问题。</p><p>不过，3PC 并没有完美解决 2PC 的阻塞问题，引入了一些新问题比如性能糟糕，而且，依然存在数据不一致性问题。因此，3PC 的实际应用并不是很广泛，<strong>多数应用会选择通过复制状态机解决 2PC 的阻塞问题。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;p&gt;分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ 事务（Kafka 和 RocketMQ </summary>
      
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论</title>
    <link href="https://eizo01.github.io/posts/41166861.html"/>
    <id>https://eizo01.github.io/posts/41166861.html</id>
    <published>2023-01-09T12:00:00.000Z</published>
    <updated>2023-03-11T14:00:04.564Z</updated>
    
    <content type="html"><![CDATA[<h1>1、CAP 理论</h1><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" alt="cap"><br>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性</strong>（Consistency） : 所有节点访问同一份最新的数据副本</li><li><strong>可用性</strong>（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性</strong>（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>插入一个小知识：网络分区<br>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p><blockquote><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。<br>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性C。<br>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</p></blockquote><p>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。<br>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。<br>这些特性将会在注册中心体现：常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos…。</p><ol><li><strong>ZooKeeper 保证的是 CP</strong>。任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li><li><strong>Eureka 保证的则是 AP</strong>。 Eureka 在设计的时候就是<strong>优先保证 A （可用性）</strong>。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。所以它不能保证数据到来就能同步所有节点，是弱一致性。</li><li><strong>Nacos 不仅支持 CP 也支持 AP</strong>。还可以作为配置中心，这是nacos提供的新特性。</li></ol><h1>2、BASE 理论</h1><p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h2 id="BASE-理论的核心思想">BASE 理论的核心思想</h2><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。<br>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。<br>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p><h2 id="基本可用">基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。<br><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h2 id="软状态">软状态</h2><p>软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h2 id="最终一致性">最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。<br><strong>分布式一致性的 3 种级别</strong>：<br><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。<br><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。<br><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。<br>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。<br>那实现最终一致性的具体方式是什么呢? 《分布式协议与算法实战》open in new window 中是这样介绍：<br><strong>读时修复</strong> :  在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。<br><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。<br><strong>异步修复 :</strong> 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</p>]]></content>
    
    
    <summary type="html">🥧详细介绍分布式领域中的理论，为分布式系统打下基础</summary>
    
    
    
    <category term="分布式" scheme="https://eizo01.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式理论" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
    <category term="分布式" scheme="https://eizo01.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>5、垃圾回收算法</title>
    <link href="https://eizo01.github.io/posts/525a714.html"/>
    <id>https://eizo01.github.io/posts/525a714.html</id>
    <published>2023-01-08T12:00:00.000Z</published>
    <updated>2023-05-19T13:02:58.239Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>1、标记清除算法</strong></h1><p>-首次适应算法</p><p>标记的是存活对象，分别标记可用对象和不可达对象，从gcroot出发只能找到引用链的对象，垃圾是标记不到的。然后从堆节点遍历开始清除标记的对象，也就是不可达对象。它是最基础的收集算法，后续算法都是以此为基础，对其缺点改进的。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519205156302.png" alt="image-20230519205156302"></p><p>缺点：</p><p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p>(1)  标记和清除两个过程都比较耗时，效率不高</p><p>(2)  会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h2 id="1-2、标记清除算法的衍生规则之分配（动态分区分配策略）"><strong>1.2、标记清除算法的衍生规则之分配（动态分区分配策略）</strong></h2><h3 id="首次适应算法（Fisrt-fit）"><strong>首次适应算法（Fisrt-fit）</strong></h3><p>首次适应算法（Fisrt-fit）就是在遍历空闲链表的时候，一旦发现有大小等于需要的大小之后，就立即把该块分配给对象，并立即返回。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分表)，找到大小能满足要求的第一个空闲分区。</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205218391.png" alt="image-20230519205218391"></p><h3 id="最佳适应算法（Best-fit）"><strong>最佳适应算法（Best-fit）</strong></h3><p>最佳适应算法（Best-fit）就是在遍历空闲链表的时候，返回刚好等于需要大小的块。</p><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205342058.png" alt="image-20230519205342058"></p><h3 id="最差适应算法（Worst-fit）"><strong>最差适应算法（Worst-fit）</strong></h3><p>最差适应算法（Worst-fit）就是在遍历空闲链表的时候，找出空闲链表中最大的分块，将其分割给申请的对象，其目的就是使得分割后分块的最大化，以便下次好分配，不过这种分配算法很容易产生很多很小的分块，这些分块也不能被使用。</p><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)</td><td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h1><strong>2、标记复制算法</strong></h1><p>– 为了解决效率问题，“<strong>标记-复制</strong>”收集算法出现了。</p><p>将内存划分为两块相等的区域，每次只使用其中一块。</p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉。</p><p>不会产生内存碎片</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205424478.png" alt="image-20230519205424478"></p><p>缺点：空间利用率降低</p><h1><strong>3、标记整理（压缩）算法</strong></h1><p>标记整理算法严格意义应该叫做标记清除整理算法或者标记清除压缩算法</p><p>因为他的本质就是在标记清除的基础在进行再整理</p><p><strong>标记过程：</strong></p><p><img src="/posts/525a714.htm/E:%5Cbolg-zdw%5Chexo-theme-Fomalhaut-main%5Csource_posts%5CJVM%5C5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.assets%5Cimage-20230519205436020.png" alt="image-20230519205436020"></p><p><strong>清除过程：</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519205443295.png" alt="image-20230519205443295"></p><p>整理过程：</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205449981.png" alt="image-20230519205449981"></p><h2 id="整理（压缩）算法分类"><strong>整理（压缩）算法分类</strong></h2><ul><li><strong>随机整理</strong>：对象的移动方式 和 它们初始的对象排列及引用关系无关</li></ul><p>任意顺序整理实现简单，且执行速度快，但任意顺序可能会将原本相邻的对象打乱到不同的高速缓存行或者是虚拟内存页中（理解为打乱到内存各个地方），会降低赋值器的局部性。包括他只能处理固定大小的对象，一旦对象大小不固定，就会增加其他的逻辑。</p><ul><li><strong>滑动顺序</strong>：将对象“滑动”到堆的一端，从而“挤出”垃圾，可以保持对象在堆中原有的顺序</li><li>线性顺序：将具有关联关系的对象排列在一起</li></ul><p>相关的对象会进行整理，整理成一块块小区域，无法避免内存碎片</p><h2 id="整理算法："><strong>整理算法：</strong></h2><h3 id="双指针回收算法"><strong>双指针回收算法</strong></h3><p>实现简单且速度快，但会打乱对象的原有布局，属于随机整理</p><p><strong>第一次遍历 -移动位置但是并不更新标记</strong></p><p>free指针在开头，scan指针在结尾，free指针往后找到空闲位置，scan往前找存活对象，并且交换。当指针相撞时，停止第一次遍历</p><p><strong>第二次遍历-更新标记</strong></p><p>由一个指针往后遍历，更新内存地址比当前scan指针的内存地址大的引用地址，这是引用地址更新的是更新gcroot的引用关系，经历过第一次遍历交换之后，引用地址的关系已经改变了，所以要让gcroot指到对应交换的内存</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205540019.png" alt="image-20230519205540019"></p><p><strong>双指针如何解决大对象的存储？</strong></p><p>end（scan）指针遍历到大对象会停下来，直到free指针找到可以存储大对象的空间。小对象空间漏掉怎么办？可以增加逻辑，用一张表来记录空闲地址，方便以后对象存储。缺点会增加开销。</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205553251.png" alt="image-20230519205553251"></p><h3 id="Lisp2算法（滑动整理算法）"><strong>Lisp2算法</strong>（滑动整理算法）</h3><p><strong>整理前：他是一个三指针算法，并且可以处理不同大小的对象。但是需要三次遍历，并且由于对象大小不一样，所以需要额外的空间存储，而不是直接移动</strong></p><p>第一次遍历：Free指针是为了留位置，而Scan对象是为了找存活对象，end指针是等待碰撞指针</p><p>指针移动规则：scan扫描指针往前走，遇到第一个对象，free指针移动需要计算公式，根据scan指的对象大小，free往前走scan对象大小。例如scan指针占两个对象格子，那么free要 1 + 2走到2这个位置（注意下标是从0开始的）</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205802006.png" alt="image-20230519205802006"></p><p>第二次遍历：更新对象地址 修改root的引用地址</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205810796.png" alt="image-20230519205810796"></p><p>第三次遍历：移动对象</p><p>​    <img src="HTTPs://zdwtop.cn/blog/image-20230519205820180.png" alt="image-20230519205820180"></p><p><strong>缺点：是具有破坏性的整理算法，它是原有对象是覆盖其他对象的。牵引信息是记录到对象里面的。</strong></p><h3 id="引线整理算法"><strong>引线整理算法</strong></h3><p>可以在不引入额外空间开销的情况下实现滑动整理，但需要2次遍历堆，且遍历成本较高</p><h3 id="单次遍历算法"><strong>单次遍历算法</strong></h3><p>滑动回收，实时计算出对象的转发地址而不需要额外的开销，偏移向量，标记向量以及内存索引号</p><h1><strong>总结</strong></h1><p>所有现代的标记-整理回收器均使用滑动整理，它不会改变对象的相对顺序，也就不会影响赋值器的空间局部性。复制式回收器甚至可以通过改变对象布局的方式，将对象与其父节点或者兄弟节点排列的更近以提高赋值器的空间局部性。</p><p>整理算法的限制，如任意顺序算法只能处理单一大小的对象，或者针对大小不同的对象需要分批处理；整理过程需要2次或者3次遍历堆空间；对象头部可能需要一个额外的槽来保存迁移的信息。</p><h1><strong>分代收集理论</strong></h1><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>弱分代假说：绝大多数对象朝生夕死</strong></p><p><strong>强分代假说：活得越久的对象，也就是熬过很多次垃圾回收的对象是越来越难以消亡的</strong></p><p><strong>跨代引用假说</strong></p><p>下面用一张图来解释</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519205906500.png" alt="image-20230519205906500"></p><p><strong>young区的对象有可能引用到老年区的对象。这样会产生垃圾该回收的没有回收，解决方法是在新生代建立一个记忆集，这个结构会把老年代分成小块小块，来记录老年代那块内存存在跨代引用。当gcroot扫描的时候只有包含跨代引用的内存加入扫描。</strong></p><p>详解可以看《深入理解JVM虚拟机》77页</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;1、标记清除算法&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;-首次适应算法&lt;/p&gt;
&lt;p&gt;标记的是存活对象，分别标记可用对象和不可达对象，从gcroot出发只能找到引用链的对象，垃圾是标记不到的。然后从堆节点遍历开始清除标记的对象，也就是不可达对象。它是最基础的收</summary>
      
    
    
    
    <category term="JVM" scheme="https://eizo01.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://eizo01.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4、Java对象的生命周期</title>
    <link href="https://eizo01.github.io/posts/1eed6375.html"/>
    <id>https://eizo01.github.io/posts/1eed6375.html</id>
    <published>2023-01-08T12:00:00.000Z</published>
    <updated>2023-05-19T13:02:40.252Z</updated>
    
    <content type="html"><![CDATA[<h1>对象的生命周期</h1><p><img src="HTTPs://zdwtop.cn/blog/image-20230519172151183.png" alt="image-20230519172151183"></p><h2 id="创建阶段"><strong>创建阶段</strong></h2><p>（1）为对象分配存储空间</p><p>（2）开始构造对象</p><p>（3）从超类到子类对static成员进行初始化</p><p>（4）超类成员变量按顺序初始化，递归调用超类的构造方法</p><p>（5）子类成员变量按顺序初始化，子类构造方法调用，并且一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段</p><h2 id="应用阶段"><strong>应用阶段</strong></h2><p>（1）系统至少维护着对象的一个强引用（Strong Reference）</p><p>（2）所有对该对象的引用全部是强引用（除非我们显式地使用了：软引用（Soft Reference）、弱引用（Weak Reference）或虚引用（Phantom Reference））</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519203636839.png" alt="image-20230519203636839"></p><ol><li><p><strong>强引用</strong>：JVM内存管理器从根引用集合（Root Set）出发遍寻堆中所有到达对象的路径。当到达某对象的任意路径都不含有引用对象时，对这个对象的引用就被称为强引用</p></li><li><p><strong>软引用：</strong> 软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。</p><p>（当你去处理占用内存较大的对象  并且生命周期比较长的，不是频繁使用的）问题：软引用可能会降低应用的运行效率与性能。比如：软引用指向的对象如果初始化很耗时，或者这个对象在进行使用的时候被第三方施加了我们未知的操作。</p></li><li><p>**弱引用：**弱引用（Weak Reference）对象与软引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于Weak引用对象， GC总是进行回收。因此Weak引用对象会更容易、更快被GC回收</p></li><li><p><strong>虚引用：</strong> 也叫幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一<strong>个系统通知。也就是说,如果一个对象被设置上了一个虚引用,实际上跟没有设置引用没有</strong>任何的区别</p></li></ol><p>软引用代码Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//。。。一堆业务代码</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"><span class="comment">//。。业务代码使用到了我们的Worker实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用完了a，将它设置为soft 引用类型，并且释放强引用；</span></span><br><span class="line">        <span class="type">SoftReference</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//这个时候他是有可能执行一次GC的</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下次使用时</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>) &#123;</span><br><span class="line">            a = (Worker) sr.get();</span><br><span class="line">            System.out.println(a );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// GC由于内存资源不足，可能系统已回收了a的软引用，</span></span><br><span class="line">            <span class="comment">// 因此需要重新装载。</span></span><br><span class="line">            a = <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">            sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用代码Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//100M的缓存数据</span></span><br><span class="line">        <span class="type">byte</span>[] cacheData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//将缓存数据用软引用持有</span></span><br><span class="line">        WeakReference&lt;<span class="type">byte</span>[]&gt; cacheRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(cacheData);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC前&quot;</span> + cacheData);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC前&quot;</span> + cacheRef.get());</span><br><span class="line">        <span class="comment">//进行一次GC后查看对象的回收情况</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为我们不确定我们的System什么时候GC</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC后&quot;</span> + cacheData);</span><br><span class="line">       System.out.println(<span class="string">&quot;第一次GC后&quot;</span> + cacheRef.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将缓存数据的强引用去除</span></span><br><span class="line">        cacheData = <span class="literal">null</span>;</span><br><span class="line">        System.gc();    <span class="comment">//默认通知一次Full  GC</span></span><br><span class="line">        <span class="comment">//等待GC</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC后&quot;</span> + cacheData);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC后&quot;</span> + cacheRef.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 弱引用Map</span></span><br><span class="line"><span class="comment">//        WeakHashMap&lt;String, String&gt; whm = new WeakHashMap&lt;String,String&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚引用代码Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                WeakReference&lt;<span class="type">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span> ((k = (WeakReference) referenceQueue.remove()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">&quot;回收了:&quot;</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes, referenceQueue);</span><br><span class="line">            map.put(weakReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;map.size-&gt;&quot;</span> + map.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可见阶段"><strong>不可见阶段</strong></h2><p>不可见阶段的对象在虚拟机的对象根引用集合中再也找不到直接或者间接的强引用，最常见的就是线程或者函数中的临时变量。程序不在持有对象的强引用。  （但是某些类的静态变量或者JNI是有可能持有的 ）</p><h2 id="不可达阶段"><strong>不可达阶段</strong></h2><p>指对象不再被任何强引用持有，GC发现该对象已经不可达。</p><h3 id="如何确定一个对象是垃圾？"><strong>如何确定一个对象是垃圾？</strong></h3><p><strong>要想进行垃圾回收，得先知道什么样的对象是垃圾。</strong></p><h3 id="引用计数法"><strong>引用计数法</strong></h3><p><strong>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</strong></p><p>弊端:如果AB相互持有引用（循环引用），导致永远不能被回收。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519204805556.png" alt="image-20230519204805556"></p><h3 id="可达性分析"><strong>可达性分析</strong></h3><p><strong>通过GC Root的对象，开始向下寻找，看某个对象是否可达根对象（错误的）</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519204836924.png" alt="image-20230519204836924"></p><p><strong>能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。GC Roots本质上一组活跃的引用</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">虚拟机栈（栈帧中的本地变量表）中引用的对象。</span><br><span class="line">方法区中类静态属性引用的对象。</span><br><span class="line">方法区中常量引用的对象。</span><br><span class="line">本地方法栈中JNI（即一般说的<span class="keyword">Native</span>方法）引用的对象。</span><br></pre></td></tr></table></figure><h2 id="收集阶段（Collected）"><strong>收集阶段（Collected）</strong></h2><p>GC发现对象处于不可达阶段并且GC已经对该对象的内存空间重新分配做好准备，对象进程收集阶段。如果，该对象的finalize()函数被重写，则执行该函数。</p><ol><li><p>会影响到JVM的对象以及分配回收速度</p></li><li><p>可能造成对象再次复活（诈尸）</p></li></ol><p>finalize方法代码Demo：这个对象拯救自己的生命的故事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Finalize</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Finalize</span> <span class="variable">save_hook</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我还活着&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize方法被执行&quot;</span>);</span><br><span class="line">        Finalize.save_hook = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        save_hook = <span class="keyword">new</span> <span class="title class_">Finalize</span>();<span class="comment">//对象</span></span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        save_hook = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//暂停0.5秒等待他</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (save_hook != <span class="literal">null</span>) &#123;</span><br><span class="line">            save_hook.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;好了，现在我死了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第二次拯救自己</span></span><br><span class="line">        save_hook = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//暂停0.5秒等待他</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (save_hook != <span class="literal">null</span>) &#123;</span><br><span class="line">            save_hook.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我终于死亡了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finalize-方法最终判定对象是否存活"><strong>finalize()方法最终判定对象是否存活</strong></h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p><h3 id="1-第一次标记并进行一次筛选。"><strong>1. 第一次标记并进行一次筛选。</strong></h3><p>筛选的条件是此对象是否有必要执行finalize()方法。</p><p>当对象没有覆盖finalize方法，对象将直接被回收。</p><h3 id="2-第二次标记"><strong>2. 第二次标记</strong></h3><p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p><p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p><p>finalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， <strong>如今已被官方明确声明为不推荐使用的语法。</strong> 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。</p><h2 id="终结阶段（Finalized）"><strong>终结阶段（Finalized）</strong></h2><p>对象的finalize()函数执行完成后，对象仍处于不可达状态，该对象进程终结阶段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;对象的生命周期&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;HTTPs://zdwtop.cn/blog/image-20230519172151183.png&quot; alt=&quot;image-20230519172151183&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建阶段&quot;&gt;&lt;strong&gt;创</summary>
      
    
    
    
    <category term="JVM" scheme="https://eizo01.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://eizo01.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>3、Java对象内存布局模型</title>
    <link href="https://eizo01.github.io/posts/8c1ea857.html"/>
    <id>https://eizo01.github.io/posts/8c1ea857.html</id>
    <published>2023-01-06T12:00:00.000Z</published>
    <updated>2023-05-19T13:02:17.228Z</updated>
    
    <content type="html"><![CDATA[<h1>Java对象内存布局</h1><p><strong>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519155050100.png" alt="image-20230519155050100"></p><p>数据 从 内存 –  CPU  会放在寄存器（32个字节）</p><p>这里需要提及一下对象在机器码中应该怎么存储的？</p><p>假设我们有int的a变量。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519155859976.png" alt="image-20230519155859976"></p><p><strong>小端存储</strong> :便于数据之间的类型转换，例如:long类型转换为int类型时，高地址部分的数据可以直接截掉。</p><p><strong>大端存储</strong> :便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。</p><blockquote><p>java中使用的是大端存储。</p></blockquote><p>-127在计算机是用补码 表示的：     10000001（-127）~ 00000000（0）        32位的处理器</p><p>一次能够去处理32个二进制位      4字节的数据      64位操作系统    8字节    2的64次方的寻址空间</p><p>指针压缩技术：JDK1.6出现的     开启了指针压缩      什么时候指针压缩会无效  ？？</p><p>超过32G指针压缩无效</p><h2 id="内存模型设计之–Class-Pointer指针"><strong>内存模型设计之–Class Pointer指针</strong></h2><p>两种模式：</p><p>句柄池访问：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519161144469.png" alt="image-20230519161144469"></p><p>直接指针访问对象图解:</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519161155183.png" alt="image-20230519161155183"></p><p><strong>区别:</strong></p><p><strong>句柄池:</strong></p><p>使用句柄访问对象，会在堆中开辟一块内存作为句柄池，句柄中储存了对象实例数据(属性值结构体) 的内存地址，访问类型数据的内存地址(类信息，方法类型信息)，对象实例数据一般也在heap中开 辟，类型数据一般储存在方法区中。</p><p><strong>优点</strong> :reference存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为) 时只会改变句柄中的实例数据指针，而reference本身不需要改变。</p><p><strong>缺点</strong> :增加了一次指针定位的时间开销。</p><p><strong>直接访问:</strong></p><p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要 在实例中存储。</p><p><strong>优点</strong> :节省了一次指针定位的开销。</p><p><strong>缺点</strong> :在对象被移动时(如进行GC后的内存重新排列)，reference本身需要被修改</p><h2 id="内存模型设计之–指针压缩"><strong>内存模型设计之–指针压缩</strong></h2><p>指针压缩的目的：</p><ol><li><p>为了保证CPU普通对象指针(oop)缓存，一次性是读取8字节的。</p></li><li><p>为了减少GC的发生，因为指针不压缩是8字节，这样在64位操作系统的堆上其他资源空间就少了。</p></li></ol><p>64位操作系统中 内存 <strong>&gt; 4G</strong> 默认开启指针压缩技术，内存 <strong>&lt; 4G</strong>，默认是32位系统默认不开启。</p><p><strong>为什么要进行指针压缩？</strong></p><p>1.在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，<strong>占用较大宽带，同时GC也会承受较大压力</strong></p><p>2.为了减少64位平台下内存的消耗，启用指针压缩功能</p><p>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入<strong>堆内存</strong>时压缩编码、取出到<strong>cpu寄存器</strong>后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</p><p>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p><p>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p><h2 id="内存模型设计之–对齐填充"><strong>内存模型设计之–对齐填充</strong></h2><p>对齐填充的意义是 <strong>提高CPU访问数据的效率</strong> ，主要针对会存在<strong>该实例对象数据跨内存地址区域存储</strong>的情况。</p><p>例如：在没有对齐填充的情况下，内存地址存放情况如下:</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519162538956.png" alt="image-20230519162538956"></p><p>因为处理器只能0x00-0x07，0x08-0x0F这样读取数据，所以当我们想获取这个long型的数据时，处理 器必须要读两次内存，第一次(0x00-0x07)，第二次(0x08-0x0F)，然后将两次的结果才能获得真正的数值。</p><p>那么在有对齐填充的情况下，内存地址存放情况是这样的:</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519162550588.png" alt="image-20230519162550588"></p><p>空间换时间。</p><p>现在处理器只需要直接一次读取(0x08-0x0F)的内存地址就可以获得我们想要的数据了。</p><p><strong>当我们的策略为0时，这个时候我们的排序是  基本类型&gt;填充字段&gt;引用类型</strong></p><p><strong>当我们策略为1时，引用类型&gt;基本类型&gt;填充字段</strong> （默认是1）</p><p><strong>策略为2时，父类中的引用类型跟子类中的引用类型放在一起   父类采用策略0   子类采用策略1 — 这样操作可以降低空间的开销 ，</strong></p><p>采用2就是优化cg垃圾回收空间的优化。</p><h1><strong>JVM内存模型</strong></h1><p><strong>图形展示</strong></p><p>一块是非堆区，一块是堆区 堆区分为两大块，一个是Old区，一个是Young区 Young区分为两大块，一个是Survivor区（S0+S1），一块是Eden区 S0和S1一样大，也可以叫From和To</p><p><strong>默认比例：年轻代与老年代比例为1:2。</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519163837833.png" alt="image-20230519163837833"></p><h1><strong>对象创建过程</strong></h1><p><img src="HTTPs://zdwtop.cn/blog/image-20230519163937178.png" alt="image-20230519163937178"></p><p><strong>一般情况下，新创建的对象都会被分配到Eden区，一些特殊的大的对象会直接分配到Old区。</strong></p><blockquote><p>一个小故事理解对象创建：我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯了。于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的。</p></blockquote><h2 id="1-类加载检查"><strong>1.类加载检查</strong></h2><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p><h2 id="2-分配内存"><strong>2.分配内存</strong></h2><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p><p>这个步骤有两个问题：</p><ol><li><p>如何划分内存。</p></li><li><p>在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p></li></ol><p><strong>划分内存的方法：</strong></p><ul><li><strong>“指针碰撞”</strong>（Bump the Pointer）(默认用指针碰撞)</li></ul><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><ul><li>“空闲列表”（Free List）</li></ul><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</p><p><strong>解决并发问题的方法：</strong></p><ul><li>CAS（compare and swap）</li></ul><p>虚拟机采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p><ul><li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</li></ul><p>在Eden区为每个线程开辟一个缓冲空间，线程创建对象如果该缓冲区的大小能够承载对象大小的话，则在该区域直接划分，可以避免多个线程同时创建对象时由于竞争同一块堆内存而产生的资源消耗。</p><p>通过**-XX:+/-** <strong>UseTLAB</strong>参数来设定虚拟机是否使用TLAB。</p><p><strong>(JVM会默认开启</strong>-XX:+UseTLAB)，-XX:TLABSize 指定TLAB大小。</p><h2 id="3-初始化零值"><strong>3.初始化零值</strong></h2><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， <strong>如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行</strong>。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id="4-设置对象头"><strong>4.设置对象头</strong></h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。</p><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h2 id="5-执行方法"><strong>5.执行方法</strong></h2><p>执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p><p><strong>详细总结：</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519165530055.png" alt="image-20230519165530055"></p><p>对象创建过程的第二步我们需要详细说明一下，这个也是对象分配的重要知识点。</p><h1><strong>对象内存分配</strong></h1><h4 id="对象内存分配流程图"><strong>对象内存分配流程图</strong></h4><p>这个也叫内存担保机制</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519170246018.png" alt="image-20230519170246018"></p><p>Full G= young gc + old gc + MetaSpace gc</p><p>方法区: 类信息   静态变量    常量    即时编译过后的代码    运行时常量池</p><p>JDK1.7之前      Perm  space    永久代   持久代       JVM自己的内存   线性整理    会增加垃圾回收的时间</p><p>JDK1.8    Meta Space    元空间   元数据区       直接内存   减少内存碎片        节省压缩时间</p><h4 id="老年代空间分配担保机制"><strong>老年代空间分配担保机制</strong></h4><p>年轻代每次<strong>young gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong></p><p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>)</p><p>就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了</p><p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次young gc后进入老年代的对象的<strong>平均大小</strong>。</p><p>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生&quot;OOM&quot;</p><p>当然，如果young gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放young gc之后的存活对象，则也会发生“OOM”。</p><p><img src="/posts/8c1ea857.htm/E:%5Cbolg-zdw%5Chexo-theme-Fomalhaut-main%5Csource_posts%5CJVM%5C3%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets%5Cimage-20230519171328082.png" alt="image-20230519171328082"></p><h4 id="对象动态年龄判断"><strong>对象动态年龄判断</strong></h4><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以<strong>直接进入老年代</strong>了.</p><p>这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在young gc之后触发的。</strong></p><h4 id="什么时候会触发Full-GC？"><strong>什么时候会触发Full   GC？</strong></h4><ol><li><p>之前每次晋升的对象的平均大小   &gt;  老年代的剩余空间          基于历史平均水平</p></li><li><p>young  GC之后      存活对象超过了老年代的剩余空间  jvm会认为剩下的对象会进入老年代空间         基于下一次可能的剩余空间</p></li><li><p>Meta Space区域空间不足</p></li><li><p>System.gc（）；</p></li></ol><h4 id="对象栈上分配"><strong>对象栈上分配</strong></h4><p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。</p><p>JVM对于这种情况可以通过开启逃逸分析参数(<code>-XX:+DoEscapeAnalysis</code>)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)。</p><p><strong>JDK7之后默认开启逃逸分析</strong>，如果要关闭使用参数(<code>-XX:-DoEscapeAnalysis</code>)</p><p>**标量替换：**通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(<code>-XX:+EliminateAllocations</code>)，<strong>JDK7之后默认开启</strong>。</p><p><strong>标量与聚合量：<strong>标量即不可被进一步分解的量，而</strong>JAVA的基本数据类型就是标量</strong>（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p><p>**结论： ** <strong>栈上分配依赖于逃逸分析和标量替换</strong></p><h1><strong>常见问题</strong></h1><ul><li>如何理解Minor/Major/Full GC</li></ul><p>Minor GC:新生代</p><p>Major GC:老年代</p><p>Full GC:新生代+老年代</p><ul><li>为什么需要Survivor区?只有Eden不行吗？</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果没有<span class="variable">Survivor</span><span class="operator">,</span><span class="variable">Eden</span>区每进行一次<span class="variable">Minor</span> <span class="variable">GC</span><span class="operator">,</span>存活的对象就会被送到老年代。 这样一来，老年代很快被填满<span class="operator">,</span>触发<span class="variable">Major</span> <span class="variable">GC</span><span class="punctuation">(</span>因为<span class="variable">Major</span> <span class="variable">GC</span>一般伴随着<span class="variable">Minor</span> <span class="variable">GC</span><span class="operator">,</span>也可以看做触发了<span class="built_in">Full</span> <span class="variable">GC</span><span class="punctuation">)</span>。 老年代的内存空间远大于新生代<span class="operator">,</span>进行一次<span class="built_in">Full</span> <span class="variable">GC</span>消耗的时间比<span class="variable">Minor</span> <span class="variable">GC</span>长得多。 </span><br><span class="line">执行时间长有什么坏处<span class="operator">?</span></span><br><span class="line">频发的<span class="built_in">Full</span> <span class="variable">GC</span>消耗的时间很长<span class="operator">,</span>会影响大型程序的执行和响应速度。  可能你会说，那就对老年代的空间进行增加或者较少咯。 假如增加老年代空间，更多存活对象才能填满老年代。虽然降低<span class="built_in">Full</span> <span class="variable">GC</span>频率，但是随着老年代空间加大<span class="operator">,</span>一旦发生<span class="built_in">Full</span> <span class="variable">GC</span><span class="operator">,</span>执行所需要的时间更长。 假如减少老年代空间，虽然<span class="built_in">Full</span> <span class="variable">GC</span>所需时间减少，但是老年代很快被存活对象填满<span class="operator">,</span><span class="built_in">Full</span> <span class="variable">GC</span>频率增加。 </span><br><span class="line">   所以<span class="variable">Survivor</span>的存在意义<span class="operator">,</span>就是减少被送到老年代的对象<span class="operator">,</span>进而减少<span class="built_in">Full</span> <span class="variable">GC</span>的发生<span class="operator">,</span><span class="variable">Survivor</span>的预筛选保证<span class="operator">,</span>只有经历<span class="number">16</span>次<span class="variable">Minor</span> <span class="variable">GC</span>还能在新生代中存活的对象<span class="operator">,</span>才会被送到老年代。</span><br></pre></td></tr></table></figure><ul><li>为什么需要两个Survivor区？</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个Survivor区,我们来模拟一下流程: 刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。 永远有一个Survivor <span class="literal">space</span>是空的,另一个非空的Survivor <span class="literal">space</span>无碎片。</span><br></pre></td></tr></table></figure><ul><li>新生代中Eden:S1:S2为什么是8:1:1？</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新生代中的可用内存：复制算法用来担保的内存为<span class="number">9</span>:<span class="number">1</span> 可用内存中Eden：<span class="built_in">S1</span>区为<span class="number">8</span>:<span class="number">1</span> 即新生代中Eden:<span class="built_in">S1</span>:<span class="built_in">S2</span> = <span class="number">8</span>:<span class="number">1</span>:<span class="number">1</span> 现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象大概<span class="number">98</span>%是“朝生夕死”的</span><br></pre></td></tr></table></figure><ul><li>堆内存中都是线程共享的区域吗？</li></ul><p>JVM默认为每个线程在Eden上开辟一个buffer区域，用来加速对象的分配，称之为TLAB，全称:Thread Local Allocation Buffer。 对象优先会在TLAB上分配，但是TLAB空间通常会比较小，如果对象比较大，那么还是在共享区域分配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java对象内存布局&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;HTTPs://zdwtop.cn/blog/image-20230519155050100.png</summary>
      
    
    
    
    <category term="JVM" scheme="https://eizo01.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://eizo01.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2、运行时数据区</title>
    <link href="https://eizo01.github.io/posts/cd99953c.html"/>
    <id>https://eizo01.github.io/posts/cd99953c.html</id>
    <published>2023-01-04T12:00:00.000Z</published>
    <updated>2023-05-19T12:59:53.454Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>计算机体系结构</strong></h1><p><strong>JVM的设计实际上遵循了遵循冯诺依曼计算机结构</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519114844714.png" alt="image-20230519114844714"></p><h1><strong>CPU与内存交互图：</strong></h1><p><img src="HTTPs://zdwtop.cn/blog/image-20230519114854436.png" alt="image-20230519114854436"></p><h1><strong>硬件一致性协议：</strong></h1><p>MSI、<strong>MESI</strong>、MOSI、Synapse、Firely、DragonProtocol</p><p><a href="https://note.youdao.com/s/5M74dGUO">缓存讲解</a></p><h1><strong>常量池分类：</strong></h1><h2 id="1-静态常量池"><strong>1.静态常量池</strong></h2><p>静态常量池是相对于运行时常量池来说的，属于描述class文件结构的一部分</p><p>由<strong>字面量</strong>和<strong>符号引用</strong>组成，在类被加载后会将静态常量池加载到内存中也就是运行时常量池</p><p><strong>字面量</strong> ：文本，字符串以及Final修饰的内容</p><p><strong>符号引用</strong> ：类，接口，方法，字段等相关的描述信息。</p><h2 id="2-运行时常量池"><strong>2.运行时常量池</strong></h2><p>当静态常量池被加载到内存后就会变成运行时常量池。</p><blockquote><p>也就是真正的把文件的内容落地到JVM内存了</p></blockquote><p><img src="HTTPs://zdwtop.cn/blog/image-20230519115822851.png" alt="image-20230519115822851"></p><h2 id="3-字符串常量池"><strong>3.字符串常量池</strong></h2><p>**设计理念：**字符串作为最常用的数据类型，为减小内存的开销，专门为其开辟了一块内存区域（字符串常量池）用以存放。</p><p>JDK1.6及之前版本，字符串常量池是位于永久代（相当于现在的方法区）。</p><p>JDK1.7之后，字符串常量池位于Heap堆中</p><p>常量池在内存中的布局：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519115905523.png" alt="image-20230519115905523"></p><p><strong>面试常问点：</strong></p><p>下列三种操作最多产生哪些对象</p><p><strong>1.直接赋值</strong></p><p>String a =“aaaa”;</p><p>解析：</p><p>最多创建一个字符串对象。</p><p>首先“aaaa”会被认为字面量，先在字符串常量池中查找（.equals()）,如果没有找到，在堆中创建“aaaa”字符串对象，并且将“aaaa”的引用维护到字符串常量池中（实际是一个hashTable结构，存放key-value结构数据），再返回该引用；如果在字符串常量池中已经存在“aaaa”的引用，直接返回该引用。</p><p><strong>2.new String()</strong></p><p>String  a  =new  String(“aaaa”);</p><p>解析：</p><p>最多会创建两个对象。</p><p>首先“aaaa”会被认为字面量，先在字符串常量池中查找（.equals()）,如果没有找到，在堆中创建“aaaa”字符串对象，然后再在堆中创建一个“aaaa”对象，返回后面“aaaa”的引用；</p><p><strong>3.intern()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zdw&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>解析：</p><p>String中的intern方法是一个 native 的方法，当调用 intern方法时，如果常量池**已经包含一个等于此String对象的字符串（用equals(object)方法确定），**则返回池中的字符串。否则，将intern返回的引用指向当前字符串 s1。(jdk1.6版本需要将s1 复制到字符串常量池里)</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519120715763.png" alt="image-20230519120715763"></p><p>例子；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hydra&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// 比较的是地址</span></span><br><span class="line">    System.out.println(s1 == <span class="string">&quot;Hydra&quot;</span>); <span class="comment">// </span></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;Hydra&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里借用大佬的图说明。</p><h1><strong>运行时数据区(Run-Time Data Areas)</strong></h1><p>熟悉了上面的东西，我们来看JVM的运行时数据区就很简单了。</p><h3 id="1、官网概括"><strong>1、官网概括</strong></h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>Java 虚拟机定义在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在 Java 虚拟机启动时创建的，并且仅在 Java 虚拟机退出时销毁。其他数据区域是每个线程的。每线程数据区域在创建线程时创建，在线程退出时销毁。</p><p>官方图：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519144110711.png" alt="image-20230519144110711"></p><p>个人详细图：</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519115151888.png" alt="image-20230519115151888"></p><h3 id="2、初步认识"><strong>2、初步认识</strong></h3><h4 id="线程共享">线程共享</h4><h5 id="方法区-Method-Area"><strong>方法区 Method Area</strong></h5><p><strong>（1）方法区是各个线程共享的内存区域，在虚拟机启动时创建</strong></p><p><strong>（2）虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来</strong></p><p><strong>（3）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></p><p><strong>（4）当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</strong></p><blockquote><p><strong>值得说明的</strong>JVM运行时数据区是一种规范，方法区真正的实现在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space</p><p>JDK1.7之前      Perm  space    永久代   持久代       JVM自己的内存   线性整理    会增加垃圾回收的时间</p><p>JDK1.8    Meta Space    元空间   元数据区       直接内存   减少内存碎片        节省压缩时间</p></blockquote><p>此时回看装载阶段的第2步，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图。忘记了可以回看上一篇文章。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519144656234.png" alt="image-20230519144656234"></p><h5 id="Heap-堆"><strong>Heap(堆)</strong></h5><p><strong>（1）Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。</strong></p><p><strong>（2）Java对象实例以及数组都在堆上分配。</strong></p><blockquote><p><strong>此时回看装载阶段的第3步，在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</strong></p></blockquote><p>此时装载(1)(2)(3)的图可以改动一下</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519151337967.png" alt="image-20230519151337967"></p><h4 id="线程私有"><strong>线程私有</strong></h4><h5 id="虚拟机栈"><strong>虚拟机栈</strong></h5><p>-Java Virtual Machine Stacks</p><blockquote><p>**经过上面的分析，类加载机制的装载过程已经完成，后续的链接，初始化也会相应的生效。假如目前的阶段是初始化完成了，后续做啥呢？肯定是Use使用咯，不用的话这样折腾来折腾去有什么意义？那怎样才能被使用到？换句话说里面内容怎样才能被执行？比如通过主函数main调用其他方法，这种方式实际上是main线程执行之后调用的方法，即要想使用里面的各种内容，得要以线程为单位，执行相应的方法才行。**那一个线程执行的状态如何维护？一个线程可以执行多少个方法？这样的关系怎么维护呢</p></blockquote><p><strong>（1）虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</strong></p><p><strong>（2）每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</strong></p><p><strong>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</strong></p><p>讲下栈之前要提下栈中有个局部变量表，这个时候一个对象的使用就很清楚了。画图说明：栈、方法区、堆之间的联系，</p><p><img src="HTTPs://zdwtop.cn/blog/e68af7f0f3254811a2cd2975ca09e662.png" alt="在这里插入图片描述"></p><ul><li>图解 栈和栈帧</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="HTTPs://zdwtop.cn/blog/image-20230519151501687.png" alt="image-20230519151501687"></p><h5 id="栈帧">栈帧</h5><p>由上图可以看出<strong>栈帧的作用：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519151525539.png" alt="image-20230519151525539"></p><p><strong>每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用-动态链接(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。</strong></p><p><strong>局部变量表:</strong> 方法中定义的局部变量以及方法的参数存放在这张表中 局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载至操作数栈中作为操作数使用。</p><p><strong>操作数栈:</strong> 以压栈和出栈的方式存储操作数的</p><p><strong>动态链接:</strong> 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。</p><p><strong>方法返回地址:</strong> 当一个方法开始执行后,只有两种方式可以退出，<strong>一种是遇到方法返回的字节码指令</strong>；<strong>一种是遇见异常，并且这个异常没有在方法体内得到处理。</strong></p><ul><li>结合字节码指令理解栈帧</li></ul><blockquote><p><strong>javap -c Person.class &gt; Person.txt</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Person.java&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">...     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&#123;</span><br><span class="line">    op = <span class="number">3</span>;<span class="type">int</span> <span class="variable">relust</span> <span class="operator">=</span> op1 + op2; </span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 方法区指向堆</span></span><br><span class="line">    <span class="keyword">return</span> relust;</span><br><span class="line">&#125;</span><br><span class="line">  Code:</span><br><span class="line">   <span class="number">0</span>: iconst_3   <span class="comment">//将int类型常量3压入[操作数栈]</span></span><br><span class="line">   <span class="number">1</span>: istore_0   <span class="comment">//将int类型值存入[局部变量0]</span></span><br><span class="line">   <span class="number">2</span>: iload_0    <span class="comment">//从[局部变量0]中装载int类型值入栈</span></span><br><span class="line">   <span class="number">3</span>: iload_1    <span class="comment">//从[局部变量1]中装载int类型值入栈</span></span><br><span class="line">   <span class="number">4</span>: iadd     <span class="comment">//将栈顶元素弹出栈，执行int类型的加法，结果入栈</span></span><br><span class="line">   <span class="number">5</span>: istore_2   <span class="comment">//将栈顶int类型值保存到[局部变量2]中</span></span><br><span class="line">   <span class="number">6</span>: iload_2    <span class="comment">//从[局部变量2]中装载int类型值入栈</span></span><br><span class="line">   <span class="number">7</span>: ireturn    <span class="comment">//从方法中返回int类型的数据</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的兄弟可能对局部变量表这里有疑问，这个0下表开始不应该是传的是this吗？怎么是个变量呢？</p><p><strong>那我这里简单解释一下：在java语言中，类静态方法调用时，任何参数都会从局部变量表的0下标开始传递。如果是实例方法，那么在调用时局部变量表0下标就是调用实例方法的对象引用，也就是this。</strong></p><p>这里附上官网的解释：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0. On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (this in the Java programming language). Any parameters are subsequently passed in consecutive local variables starting from local variable 1.</span><br></pre></td></tr></table></figure><h5 id="pc程序计数器"><strong>pc程序计数器</strong></h5><blockquote><p><strong>我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据CPU调度来的。假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获得CPU执行权的时候，怎么能继续执行呢？这就是需要在线程中维护一个变量，记录线程执行到的位置。</strong></p></blockquote><p><strong>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；</strong></p><p><strong>如果正在执行的是Native方法，则这个计数器为空。</strong></p><h4 id="本地方法栈">本地方法栈</h4><p><strong>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</strong></p><p><strong>那如果在Java方法执行的时候调用native的方法呢？</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519153358348.png" alt="image-20230519153358348"></p><p>以上就介绍了运行时数据区的全部结构了，接下来我们需要介绍几种几个区域相互引用的情况。</p><h2 id="栈指向堆"><strong>栈指向堆</strong></h2><p><strong>如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519153528229.png" alt="image-20230519153528229"></p><h2 id="方法区指向堆">方法区指向堆</h2><p><strong>方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对</strong><br><strong>象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p><img src="HTTPs://zdwtop.cn/blog/503d6384d1e344d2b09ddda80e5f069b.png" alt="image.png"></p><h2 id="堆指向方法区"><strong>堆指向方法区</strong></h2><p><strong>What？堆还能指向方法区？注意，方法区中会包含类的信息，堆中会有对象，那怎么知道对象是哪个类创建的呢？</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519153743700.png" alt="image-20230519153743700"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;计算机体系结构&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;JVM的设计实际上遵循了遵循冯诺依曼计算机结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;HTTPs://zdwtop.cn/blog/image-2023051911484471</summary>
      
    
    
    
    <category term="JVM" scheme="https://eizo01.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://eizo01.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1、类加载机制</title>
    <link href="https://eizo01.github.io/posts/81190f8.html"/>
    <id>https://eizo01.github.io/posts/81190f8.html</id>
    <published>2023-01-02T12:00:00.000Z</published>
    <updated>2023-05-19T07:49:50.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解释和编译">解释和编译</h2><p>Java属于编译型+解释型的高级语言其实并不是因为有javac将Java源码编译成class文件，才说Java属于编译+解释语言，因为在这个编译器编译之后，生成的类文件不能直接在对应的平台上运行。那为何又说Java是编译+解释语言呢？因为class文件最终是通过JVM来翻译才能在对应的平台上运行，而这个翻译大多数时候是解释的过程，但是也会有编译，称之为运行时编译，即JIT(Just In Time)。综上所述，Java是一门编译型+解释型的高级语言。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519110300424.png" alt="image-20230519110300424"></p><h2 id="类文件">类文件</h2><p>java源文件加载到JVM的过程</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519110326772.png" alt="image-20230519110326772"></p><p>(1) 源码到类文件<br>(2) 类文件到JVM<br>(3) JVM各种折腾  [内部结构、执行方式、垃圾回收、本地调用等]<br><strong>java.c编译器</strong></p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519110338623.png" alt="image-20230519110338623"></p><p>Javac编译过程大致可以分为1个准备过程和3个处理过程：</p><ol><li><p>准备过程：编译器需要解析编译命令、读取源文件和设置编译环境等。</p></li><li><p>词法和语法分析处理过程：编译器将Java源代码转换成标记，然后按照语法规则组织成语法树。</p></li><li><p>语义分析处理过程：编译器会对程序中的类型进行检查、解析符号和检查错误等。</p></li><li><p>生成字节码处理过程：编译器将抽象语法树转换成Java字节码，并生成对应的.class文件。</p></li></ol><h2 id="类加载机制">类加载机制</h2><p><img src="HTTPs://zdwtop.cn/blog/image-20230519110444594.png" alt="image-20230519110444594"></p><p><strong>Java的类加载机制指的是将Java代码编译成字节码文件后，JVM将字节码文件所包含数据读入内存，并从内存里把二进制加工成为可用的数据，提供一个数据的访问入口的一种机制。</strong><br>类加载的最终产品是数据访问入口。<br><strong>加载.class文件的方式：</strong></p><p>• 编译后本地.class文件</p><p>• 网络传输获取二进制流</p><p>• Jar/War包中解压后读取</p><p>• 动态运行生成,JDK动态代理/CGLib</p><p>将Java源文件动态编译为.class文件，也就是运行时计算而成（动态代理技术）</p><p>所谓类加载机制就是<strong>虚拟机把Class文件加载到内存并对数据进行校验，转换解析和初始化形成可以虚拟机直接使用的Java类型，即java.lang.Class.</strong></p><img src="HTTPs://zdwtop.cn/blog/image-20230519110706709.png" alt="image-20230519110706709" style="zoom:50%;"><h3 id="1、装载">1、装载</h3><blockquote><p>class文件-&gt; 字节流 -&gt; 类加载器 自定义模块 字节码增强操作</p></blockquote><p>JVM中读取字节码文件打成二进制流，通过类加载器解析字节码文件，产生数据放到运行时数据区。<br>（1）通过一个<strong>类的全限定名</strong>获取定义此类的二进制字节流<br>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>（3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口<br>在加载类过程中,必然会触发父类加载。<br>方法区：类信息，静态变量<br>常量堆：代表被加载类的<code>java.lang.Class</code>对象</p><pre><code>  Class clz = A.class;   Field age = clz.getField(&quot;age&quot;);</code></pre><p><strong>即时编译之后的热点代码并不在这个阶段进入方法区</strong></p><h3 id="2、链接">2、链接</h3><h4 id="2-1-验证-Verify-确保字节码符合虚拟机要求">2.1 验证(Verify):确保字节码符合虚拟机要求</h4><ul><li>文件格式验证</li></ul><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。</p><ul><li>元数据验证</li></ul><p>对类的元数据信息进行语义校验（其实就是对Java语法校验），保证不存在不符合Java语法规范的元数据信息。</p><p><strong>总结：对类的元数据信息进行语义校验（其实就是对Java语法校验），保证不存在不符合Java语法规范的元数据信息。</strong></p><ul><li>字节码验证</li></ul><p>数据流与控制流分析</p><ol><li><p>运行检查</p></li><li><p>栈数据类型和操作码操作参数吻合</p></li><li><p>跳转指令指向合理的位置</p></li></ol><ul><li>符号引用验证</li></ul><p>这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。</p><p><code>-Xverify:none 取消验证。</code></p><h4 id="2-2-准备-Prepare-为字段赋予初始值">2.2 准备(Prepare):为字段赋予初始值</h4><p><strong>为类的静态变量分配内存，并将其初始化为默认值</strong></p><ul><li><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p></li><li><p>这里不会为实例变量（也就是没加static）分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常打印出0，因为静态变量i在准备阶段会有默认值0</span></span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a=1;那么a在准备阶段过后的初始值为0，不为1，这时候只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编译后，存放于类构造器()方法之中，重点：所以a被赋值为1是在初始化阶段才会执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-解析-Resolve-符号引用转换为直接引用">2.3 解析(Resolve):符号引用转换为直接引用</h4><p><strong>将字节码的静态字面关联转换JVM内存中的动态指针关联。</strong></p><pre><code>将**符号引用**替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的**静态链接**过程(类加载期间完成).**动态链接**是在程序运行期间完成的将符号引用替换为直接引用 。  </code></pre><h2 id="3、初始化">3、初始化</h2><p>​初始化阶段是执行类构造器()方法的过程。或者讲得通俗易懂些在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，比如赋值。执行Clinit方法。</p><p>**在Java中对类变量进行初始值设定有两种方式：**按照程序员的逻辑，你必须把静态变量定义在静态代码块的前面。因为两个的执行是会根据代码编写的顺序来决定的，顺序搞错了可能会影响你的业务代码。</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤：假如这个类还没有被加载和连接，则程序先加载并链接该类假如该类的直接父类还没有被初始化，则先初始化其直接父类假如类中有初始化语句，则系统依次执行这些初始化语句。</p><h2 id="4、使用">4、使用</h2><p>​那么这个时候我们去思考一个问题，我们的初始化过程什么时候会被触发执行呢？或者换句话说类初始化时机是什么呢？<br><strong>主动引用只有当对类的主动使用的时候才会导致类的初始化。</strong><br><strong>类的主动使用有六种：</strong></p><ol><li><p>创建类的实例，也就是new的方式</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如Class.forName(“com.carl.Test”) ）</p></li><li><p>初始化某个类的子类，则其父类也会被初始化</p></li><li><p>Java虚拟机启动时被标明为启动类的类（JvmCaseApplication ），直接使用 java.exe 命令来运行某个主类</p></li></ol><p><strong>被动引用</strong></p><ol><li><p>引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</p></li><li><p>定义类数组，不会引起类的初始化。</p></li><li><p>引用类的static final常量，不会引起类的初始化（如果只有static修饰，还是会引起该类初始化的）。</p></li></ol><h2 id="5、卸载">5、卸载</h2><p><strong>在类使用完之后，如果满足下面的情况，类就会被卸载：</strong></p><ul><li><p>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li><li><p>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，**类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。**但是一般情况下<code>启动类加载器加载的类</code>不会被卸载，而我们的其他两种基础类型的类加载器只有在极少数情况下才会被卸载</p><h1>类加载器ClassLoader</h1><blockquote><p>​    在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载器完成，顾名思义，就是用来装载Class文件的。</p></blockquote><h2 id="什么是类加载器？"><strong>什么是类加载器？</strong></h2><p>：负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例的代码模块 。<br>类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。<br>**一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。**但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。</p><h2 id="类加载器分类">类加载器分类</h2><p>1）<strong>Bootstrap ClassLoader</strong> ：负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。<br>2）<strong>Extension ClassLoader</strong>：  负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。<br>3）App ClassLoader：  负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。<br>4）Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoad。</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230519113142780.png" alt="image-20230519113142780"></p><h2 id="为什么我们的类加载器要分层？">为什么我们的类加载器要分层？</h2><p>1.2版本的JVM中，只有一个类加载器，就是现在的“Bootstrap”类加载器。也就是根类加载器。但是这样会出现一个问题。假如用户调用他编写的java.lang.String类。理论上该类可以访问和改变java.lang包下其他类的默认访问修饰符的属性和方法的能力。也就是说，我们其他的类使用String时也会调用这个类，因为只有一个类加载器，我无法判定到底加载哪个。因为Java语言本身并没有阻止这种行为，所以会出现问题。<br>这个时候，我们就想到，可不可以使用不同级别的类加载器来对我们的信任级别做一个区分呢？比如用三种基础的类加载器做为我们的三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于你本机的类）。所以，我们三种基础的类加载器由此而生。</p><h2 id="JVM类加载机制的三种特性">JVM类加载机制的三种特性</h2><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p><strong>父类委托</strong>，“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。</p><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都将在内存中缓存，当程序中需要使用某个Class时，类加载器先从内存的缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。<strong>对于一个类加载器实例来说，相同全名的类只加载一次，即loadClass方法不会被重复调用。</strong></p><p><strong>而这里我们JDK8使用的是直接内存，所以我们会用到直接内存进行缓存。这也就是我们的类变量为什么只会被初始化一次的由来。</strong></p><h2 id="“双亲委派”机制加载Class的具体过程是："><strong>“双亲委派”机制加载Class的具体过程是：</strong></h2><ol><li>ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</li><li>父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</li><li>依此类推，直到始祖类加载器（引用类加载器）。</li><li>始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</li><li>始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</li><li>依此类推，直到源ClassLoader。（全盘委托的类加载器）</li><li>源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</li></ol><p>“双亲委派”机制只是Java推荐的机制，并不是强制的机制。我们可以继承java.lang.ClassLoader类，实现自己的类加载器。</p><ul><li>如果想保持双亲委派模型，就应该重写findClass(name)方法；</li><li>如果想破坏双亲委派模型，可以重写loadClass(name)方法。文字太长的话，可以看图</li></ul><p><img src="HTTPs://zdwtop.cn/blog/image-20230519113443615.png" alt="image-20230519113443615"></p><h2 id="打破双亲委派">打破双亲委派</h2><p><strong>tomcat和driver两种模式的打破</strong><br><strong>spi</strong><br><strong>OSGI</strong>:比如我们的JAVA程序员更加追求程序的动态性，比如代码热部署，代码热替换。也就是就是机器不用重启，只要部署上就能用。OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。<br><strong>自定义类加载器</strong></p><h3 id="Tomcat打破双亲委派机制">Tomcat打破双亲委派机制</h3><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？<br>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p><ol><li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li><li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。</li><li>web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li><li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</li></ol><p>再看看我们的问题：<strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong></p><p>答案是不行的。为什么？</p><p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p><p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。</p><p>第三个问题和第一个问题一样。</p><p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p><h4 id="Tomcat自定义加载器详解"><strong>Tomcat自定义加载器详解</strong></h4><p><img src="HTTPs://zdwtop.cn/blog/image-20230519113616172.png" alt="image-20230519113616172"></p><p>tomcat的几个主要类加载器：</p><ul><li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li><li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li><li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li><li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本；</li></ul><p>从图中的委派关系中可以看出：</p><p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</p><p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p><p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p><p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗？答案是：违背了。</p><p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，<strong>每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制</strong>。</p><p><strong>模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//非自定义的类还是走双亲委派加载</span></span><br><span class="line">                    <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;com.tuling.jvm&quot;</span>))&#123;</span><br><span class="line">                        c = <span class="built_in">this</span>.getParent().loadClass(name);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test1&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> classLoader1.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> clazz1.newInstance();</span><br><span class="line">        Method method1= clazz1.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method1.invoke(obj1, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz1.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@266474c2</span><br><span class="line"></span><br><span class="line">=======另外一个User1版本：自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@66d3c617</span><br></pre></td></tr></table></figure><p>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</p><p><strong>模拟实现Tomcat的JasperLoader热加载</strong></p><p>原理：后台启动线程监听jsp文件变化，如果变化了找到该jsp对应的servlet类的加载器引用(gcroot)，重新生成新的<strong>JasperLoader</strong>加载器赋值给引用，然后加载新的jsp对应的servlet类，之前的那个加载器因为没有gcroot引用了，下一次gc的时候会被销毁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">附下User类的代码：</span><br><span class="line">package com.tuling.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span>()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">int</span> id, String name</span>)</span> &#123;</span><br><span class="line">    super();</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getId</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(<span class="params"><span class="built_in">int</span> id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span>()</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;=======自己的加载器加载类调用方法=======&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><h1>补充：Hotspot源码JVM启动执行main方法流程</h1><p><img src="HTTPs://zdwtop.cn/blog/image-20230519113751790.png" alt="image-20230519113751790"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解释和编译&quot;&gt;解释和编译&lt;/h2&gt;
&lt;p&gt;Java属于编译型+解释型的高级语言其实并不是因为有javac将Java源码编译成class文件，才说Java属于编译+解释语言，因为在这个编译器编译之后，生成的类文件不能直接在对应的平台上运行。那为何又说Java是编译+</summary>
      
    
    
    
    <category term="JVM" scheme="https://eizo01.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://eizo01.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis整合Spring的原理分析</title>
    <link href="https://eizo01.github.io/posts/4287b857.html"/>
    <id>https://eizo01.github.io/posts/4287b857.html</id>
    <published>2022-12-10T12:00:00.000Z</published>
    <updated>2023-04-04T08:57:38.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis整合Spring的原理分析"><a href="#MyBatis整合Spring的原理分析" class="headerlink" title="MyBatis整合Spring的原理分析"></a>MyBatis整合Spring的原理分析</h1><p><a href="http://mybatis.org/spring/zh/index.html">http://mybatis.org/spring/zh/index.html</a></p><h2 id="1-MyBatis整合Spring实现"><a href="#1-MyBatis整合Spring实现" class="headerlink" title="1. MyBatis整合Spring实现"></a>1. MyBatis整合Spring实现</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们先来实现MyBatis和Spring的整合操作。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/3c836661773f488f88610095398a5432.png" alt="image.png"></p><h3 id="1-1-添加相关的依赖"><a href="#1-1-添加相关的依赖" class="headerlink" title="1.1 添加相关的依赖"></a>1.1 添加相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h3><p>我们将MyBatis整合到Spring中，那么原来在MyBatis的很多配置我们都可以在Spring的配置文件中设置，我们可以给MyBatis的配置文件设置为空</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加Spring的配置文件，并在该文件中实现和Spring的整合操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关联数据属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zdw&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 整合mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联mybatis的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config-spring.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加别名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zdw.domain&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置扫描的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zdw.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><p>然后我们就可以通过测试来操作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RunWith(value = SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisSpringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">bean</span> <span class="operator">=</span> ac.getBean(IUserService.class);</span><br><span class="line">    List&lt;User&gt; list = bean.query();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单元测试的代码我们可以发现，将MyBatis整合到Spring中后，原来操作的核心对象(SqlSessionFactory,SqlSession,getMapper)都不见了，使我们的开发更加的简洁。</p><h2 id="2-MyBatis整合Spring的原理"><a href="#2-MyBatis整合Spring的原理" class="headerlink" title="2.MyBatis整合Spring的原理"></a>2.MyBatis整合Spring的原理</h2><p>把MyBatis集成到Spring里面，是为了进一步简化MyBatis的使用，所以只是对MyBatis做了一些封装，并没有替换MyBatis的核心对象。也就是说：MyBatis jar包中的SqlSessionFactory、SqlSession、MapperProxy这些类都会用到。mybatis-spring.jar里面的类只是做了一些包装或者桥梁的工作。</p><p>只要我们弄明白了这三个对象是怎么创建的，也就理解了Spring继承MyBatis的原理。我们把它分成三步：</p><ol><li>SqlSessionFactory在哪创建的。</li><li>SqlSession在哪创建的。</li><li>代理类在哪创建的。</li></ol><h3 id="2-1-SqlSessionFactory"><a href="#2-1-SqlSessionFactory" class="headerlink" title="2.1 SqlSessionFactory"></a>2.1 SqlSessionFactory</h3><p>首先我们来看下在MyBatis整合Spring中SqlSessionFactory的创建过程，查看这步的入口在Spring的配置文件中配置整合的标签中</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/d52e211fccaa4776a5a117fd70fa16a4.png" alt="image.png"></p><p>我们进入SqlSessionFactoryBean中查看源码发现，其实现了InitializingBean 、FactoryBean、ApplicationListener 三个接口</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/620e151e278643b69382f88a97edee70.png" alt="image.png"></p><p>对于这三个接口，学过Spring生命周期的小伙伴应该清楚他们各自的作用</p><div class="table-container"><table><thead><tr><th><strong>接口</strong></th><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>FactoryBean</td><td>getObject()</td><td>返回由FactoryBean创建的Bean实例</td></tr><tr><td>InitializingBean</td><td>afterPropertiesSet()</td><td>bean属性初始化完成后添加操作</td></tr><tr><td>ApplicationListener</td><td>onApplicationEvent()</td><td>对应用的时间进行监听</td></tr></tbody></table></div><h4 id="2-1-1-afterPropertiesSet"><a href="#2-1-1-afterPropertiesSet" class="headerlink" title="2.1.1 afterPropertiesSet"></a>2.1.1 afterPropertiesSet</h4><p>我们首先来看下 afterPropertiesSet 方法中的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.configuration == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.configLocation == <span class="literal">null</span> || <span class="built_in">this</span>.configuration == <span class="literal">null</span> || <span class="built_in">this</span>.configLocation == <span class="literal">null</span>, <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = <span class="built_in">this</span>.buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在afterPropertiesSet中直接调用了buildSqlSessionFactory方法来实现 sqlSessionFactory 对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 解析全局配置文件的 XMLConfigBuilder 对象</span></span><br><span class="line">      <span class="type">XMLConfigBuilder</span> <span class="variable">xmlConfigBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// Configuration 对象</span></span><br><span class="line">      Configuration targetConfiguration;</span><br><span class="line">      Optional var10000;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.configuration != <span class="literal">null</span>) &#123; <span class="comment">// 判断是否存在 configuration对象，如果存在说明已经解析过了</span></span><br><span class="line">          targetConfiguration = <span class="built_in">this</span>.configuration;</span><br><span class="line">          <span class="comment">// 覆盖属性</span></span><br><span class="line">          <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="literal">null</span>) &#123;</span><br><span class="line">              targetConfiguration.setVariables(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configurationProperties != <span class="literal">null</span>) &#123;</span><br><span class="line">              targetConfiguration.getVariables().putAll(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果configuration对象不存在，但是存在configLocation属性，就根据mybatis-config.xml的文件路径来构建 xmlConfigBuilder对象</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configLocation != <span class="literal">null</span>) &#123;  </span><br><span class="line">          xmlConfigBuilder = <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(<span class="built_in">this</span>.configLocation.getInputStream(), (String)<span class="literal">null</span>, <span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 属性&#x27;configuration&#x27;或&#x27;configLocation&#x27;未指定，使用默认MyBatis配置</span></span><br><span class="line">          LOGGER.debug(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          targetConfiguration = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">          var10000 = Optional.ofNullable(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">          Objects.requireNonNull(targetConfiguration);</span><br><span class="line">          var10000.ifPresent(targetConfiguration::setVariables);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 设置 Configuration 中的属性  即我们可以在Mybatis和Spring的整合文件中来设置 MyBatis的全局配置文件中的设置</span></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.objectFactory);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.objectWrapperFactory);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.vfs);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line">      Stream var24;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">          var24 = <span class="built_in">this</span>.scanClasses(<span class="built_in">this</span>.typeAliasesPackage, <span class="built_in">this</span>.typeAliasesSuperType).stream().filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isMemberClass();</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="type">TypeAliasRegistry</span> <span class="variable">var10001</span> <span class="operator">=</span> targetConfiguration.getTypeAliasRegistry();</span><br><span class="line">          Objects.requireNonNull(var10001);</span><br><span class="line">          var24.forEach(var10001::registerAlias);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeAliases)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.typeAliases).forEach((typeAlias) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered type alias: &#x27;&quot;</span> + typeAlias + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.plugins)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.plugins).forEach((plugin) -&gt; &#123;</span><br><span class="line">              targetConfiguration.addInterceptor(plugin);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered plugin: &#x27;&quot;</span> + plugin + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">          var24 = <span class="built_in">this</span>.scanClasses(<span class="built_in">this</span>.typeHandlersPackage, TypeHandler.class).stream().filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">          &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> !Modifier.isAbstract(clazz.getModifiers());</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="type">TypeHandlerRegistry</span> <span class="variable">var25</span> <span class="operator">=</span> targetConfiguration.getTypeHandlerRegistry();</span><br><span class="line">          Objects.requireNonNull(var25);</span><br><span class="line">          var24.forEach(var25::register);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.typeHandlers).forEach((typeHandler) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered type handler: &#x27;&quot;</span> + typeHandler + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">          Stream.of(<span class="built_in">this</span>.scriptingLanguageDrivers).forEach((languageDriver) -&gt; &#123;</span><br><span class="line">              targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Registered scripting language driver: &#x27;&quot;</span> + languageDriver + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.defaultScriptingLanguageDriver);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              targetConfiguration.setDatabaseId(<span class="built_in">this</span>.databaseIdProvider.getDatabaseId(<span class="built_in">this</span>.dataSource));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException var23) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed getting a databaseId&quot;</span>, var23);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var10000 = Optional.ofNullable(<span class="built_in">this</span>.cache);</span><br><span class="line">      Objects.requireNonNull(targetConfiguration);</span><br><span class="line">      var10000.ifPresent(targetConfiguration::addCache); <span class="comment">// 如果cache不为空就把cache 添加到 configuration对象中</span></span><br><span class="line">      <span class="keyword">if</span> (xmlConfigBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              xmlConfigBuilder.parse(); <span class="comment">// 解析全局配置文件</span></span><br><span class="line">              LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="built_in">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception var21) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="built_in">this</span>.configLocation, var21);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ErrorContext.instance().reset();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      targetConfiguration.setEnvironment(<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="built_in">this</span>.environment, (TransactionFactory)(<span class="built_in">this</span>.transactionFactory == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>() : <span class="built_in">this</span>.transactionFactory), <span class="built_in">this</span>.dataSource));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">              LOGGER.warn(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Resource[] var3 = <span class="built_in">this</span>.mapperLocations;</span><br><span class="line">              <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> var3.length;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                  <span class="type">Resource</span> <span class="variable">mapperLocation</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">                  <span class="keyword">if</span> (mapperLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">//创建了一个用来解析Mapper.xml的XMLMapperBuilder，调用了它的parse()方法。这个步骤我们之前了解过了，</span></span><br><span class="line">                          <span class="comment">//主要做了两件事情，一个是把增删改查标签注册成MappedStatement对象。</span></span><br><span class="line">                          <span class="comment">// 第二个是把接口和对应的MapperProxyFactory工厂类注册到MapperRegistry中</span></span><br><span class="line">                          <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(), targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                          xmlMapperBuilder.parse();</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, var19);</span><br><span class="line">                      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          ErrorContext.instance().reset();</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                          <span class="keyword">return</span> <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                      &#125;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          LOGGER.debug(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 最后调用sqlSessionFactoryBuilder.build()返回了一个DefaultSqlSessionFactory。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在afterPropertiesSet方法中完成了SqlSessionFactory对象的创建，已经相关配置文件和映射文件的解析操作。</p><p>方法小结一下：通过定义一个实现了InitializingBean接口的SqlSessionFactoryBean类，里面有一个afterPropertiesSet()方法会在bean的属性值设置完的时候被调用。Spring在启动初始化这个Bean的时候，完成了解析和工厂类的创建工作。</p><h4 id="2-1-2-getObject"><a href="#2-1-2-getObject" class="headerlink" title="2.1.2 getObject"></a>2.1.2 getObject</h4><p>另外SqlSessionFactoryBean实现了FactoryBean接口。</p><p>FactoryBean的作用是让用户可以自定义实例化Bean的逻辑。如果从BeanFactory中根据Bean的ID获取一个Bean，它获取的其实是FactoryBean的getObject()返回的对象。</p><p>也就是说，我们获取SqlSessionFactoryBean的时候，就会调用它的getObject()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObject方法中的逻辑就非常简单，返回SqlSessionFactory对象，如果SqlSessionFactory对象为空的话就又调用一次afterPropertiesSet来解析和创建一次。</p><h4 id="2-1-3-onApplicationEvent"><a href="#2-1-3-onApplicationEvent" class="headerlink" title="2.1.3 onApplicationEvent"></a>2.1.3 onApplicationEvent</h4><p>实现ApplicationListener接口让SqlSessionFactoryBean有能力监控应用发出的一些事件通知。比如这里监听了ContextRefreshedEvent（上下文刷新事件），会在Spring容器加载完之后执行。这里做的事情是检查ms是否加载完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.failFast &amp;&amp; event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-SqlSession"><a href="#2-2-SqlSession" class="headerlink" title="2.2 SqlSession"></a>2.2 SqlSession</h3><h4 id="2-2-1-DefaultSqlSession的问题"><a href="#2-2-1-DefaultSqlSession的问题" class="headerlink" title="2.2.1 DefaultSqlSession的问题"></a>2.2.1 DefaultSqlSession的问题</h4><p>在前面介绍MyBatis的使用的时候，通过SqlSessionFactory的open方法获取的是DefaultSqlSession，但是在Spring中我们不能直接使用DefaultSqlSession，因为DefaultSqlSession是线程不安全的。所以直接使用会存在数据安全问题，针对这个问题的，在整合的MyBatis-Spring的插件包中给我们提供了一个对应的工具SqlSessionTemplate。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/1f28ec9841ef4031816dc12cd59e0c80.png" alt="image.png"></p><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/d62b09e3616e4ff586ade9b5637073b8.png" alt="image.png"></p><p>也就是在我们使用SqlSession的时候都需要使用try catch 块来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   session = sqlSessionFactory.openSession();</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整合Spring中通过提供的SqlSessionTemplate来简化了操作，提供了安全处理。</p><h4 id="2-2-2-SqlSessionTemplate"><a href="#2-2-2-SqlSessionTemplate" class="headerlink" title="2.2.2 SqlSessionTemplate"></a>2.2.2 SqlSessionTemplate</h4><p>在mybatis-spring的包中，提供了一个线程安全的SqlSession的包装类，用来替代SqlSession，这个类就是SqlSessionTemplate。因为它是线程安全的，所以可以在所有的DAO层共享一个实例（默认是单例的）。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/9479734db48f42b28115dfe44d85be1a.png" alt="image.png"></p><p>SqlSessionTemplate虽然跟DefaultSqlSession一样定义了操作数据的selectOne()、selectList()、insert()、update()、delete()等所有方法，但是没有自己的实现，全部调用了一个代理对象的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/4bc98188f0ca467086c9c1ed3b3341b7.png" alt="image.png"></p><p>那么SqlSessionProxy是怎么来的呢？在SqlSessionTemplate的构造方法中有答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span><br><span class="line"><span class="params">    PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">  notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="built_in">this</span>.executorType = executorType;</span><br><span class="line">  <span class="built_in">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="comment">// 创建了一个 SqlSession 接口的代理对象， 调用SqlSessionTemplate中的 selectOne() 方法，其实就是调用</span></span><br><span class="line">    <span class="comment">// SqlSessionProxy的 selectOne() 方法，然后执行的是 SqlSessionInterceptor里面的 invoke方法</span></span><br><span class="line">  <span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的介绍那么我们应该进入到 SqlSessionInterceptor 的 invoke 方法中。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/cd0625c0163a4d55b0657a595760c829.png" alt="image.png"></p><p>上面的代码虽然看着比较复杂，但是本质上就是下面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   session = sqlSessionFactory.openSession();</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSqlSession方法中的关键代码：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/bdba616d94ba402fb2b7fb7ef5af3cdc.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/5d887bfb8e5c45c2bcd5d8aaf204a80a.png" alt="image.png"></p><p><strong>总结一下</strong>：因为DefaultSqlSession自己做不到每次请求调用产生一个新的实例，我们干脆创建一个代理类，也实现SqlSession，提供跟DefaultSqlSession一样的方法，在任何一个方法被调用的时候都先创建一个DefaultSqlSession实例，再调用被代理对象的相应方法。</p><p>MyBatis还自带了一个线程安全的SqlSession实现：SqlSessionManager，实现方式一样，如果不集成到Spring要保证线程安全，就用SqlSessionManager。</p><h4 id="2-2-3-SqlSessionDaoSupport"><a href="#2-2-3-SqlSessionDaoSupport" class="headerlink" title="2.2.3 SqlSessionDaoSupport"></a>2.2.3 SqlSessionDaoSupport</h4><p>通过上面的介绍我们清楚了在Spring项目中我们应该通过SqlSessionTemplate来执行数据库操作，那么我们就应该首先将SqlSessionTemplate添加到IoC容器中，然后我们在Dao通过@Autowired来获取具体步骤参考官网：<a href="http://mybatis.org/spring/zh/sqlsession.html">http://mybatis.org/spring/zh/sqlsession.html</a></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/9e232bb8c69845d0bd7ff903fea08829.png" alt="image.png"></p><p>然后我们可以看看SqlSessionDaoSupport中的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/a703e6fb875647ccba442245474496fe.png" alt="image.png"></p><p>如此一来在Dao层我们就只需要继承 SqlSessionDaoSupport就可以通过getSqlSession方法来直接操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他代码省略</span></span><br></pre></td></tr></table></figure><p>也就是说我们让DAO层（实现类）继承抽象类SqlSessionDaoSupport，就自动拥有了getSqlSession()方法。调用getSqlSession()就能拿到共享的SqlSessionTemplate。</p><p>在DAO层执行SQL格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getSqlSession().selectOne(statement, parameter);</span><br><span class="line">getSqlSession().insert(statement);</span><br><span class="line">getSqlSession().update(statement);</span><br><span class="line">getSqlSession().delete(statement);</span><br></pre></td></tr></table></figure><p>还是不够简洁。为了减少重复的代码，我们通常不会让我们的实现类直接去继承SqlSessionDaoSupport，而是先创建一个BaseDao继承SqlSessionDaoSupport。在BaseDao里面封装对数据库的操作，包括selectOne()、selectList()、insert()、delete()这些方法，子类就可以直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">BaseDao</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> &#123;</span><br><span class="line">   <span class="comment">//使用sqlSessionFactory</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getSqlSession().selectOne(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure><p>然后让我们的DAO层实现类继承BaseDao并且实现我们的Mapper接口。实现类需要加上@Repository的注解。</p><p>在实现类的方法里面，我们可以直接调用父类（BaseDao）封装的selectOne()方法，那么它最终会调用sqlSessionTemplate的selectOne()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span> <span class="keyword">implements</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Employee <span class="title function_">selectByPrimaryKey</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> (Employee) <span class="built_in">this</span>.selectOne(<span class="string">&quot;com.boboedu.crud.dao.EmployeeMapper.selectByPrimaryKey&quot;</span>,empId);</span><br><span class="line">       <span class="keyword">return</span> emp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 后面省略</span></span><br></pre></td></tr></table></figure><p>然后在需要使用的地方，比如Service层，注入我们的实现类，调用实现类的方法就行了。我们这里直接在单元测试类DaoSupportTest.java里面注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">EmployeeDaoImpl employeeDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">EmployeeDaoSupportTest</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(employeeDao.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到DefaultSqlSession的方法。</p><h4 id="2-2-4-MapperScannerConfigurer"><a href="#2-2-4-MapperScannerConfigurer" class="headerlink" title="2.2.4 MapperScannerConfigurer"></a>2.2.4 MapperScannerConfigurer</h4><p>上面我们介绍了SqlSessionTemplate和SqlSessionDaoSupport，也清楚了他们的作用，但是我们在实际开发的时候，还是能够直接获取到 Mapper 的代理对象，并没有创建Mapper的实现类，这个到底是怎么实现的呢？这个我们就要注意在整合MyBatis的配置文件中除了SqlSessionFactoryBean以外我们还设置了一个MapperScannerConfigurer，我们来分析下这个类</p><p>首先是MapperScannerConfigurer的继承结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/70e0612bcf1548188206d3f683af3c72.png" alt="image.png"></p><p>MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor接口。BeanDefinitionRegistryPostProcessor 是BeanFactoryPostProcessor的子类，里面有一个postProcessBeanDefinitionRegistry()方法。</p><p>实现了这个接口，就可以在Spring创建Bean之前，修改某些Bean在容器中的定义。Spring创建Bean之前会调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">    processPropertyPlaceHolders(); <span class="comment">// 处理 占位符</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ClassPathMapperScanner 对象</span></span><br><span class="line">  <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">  scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">  scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">  scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">  scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">  scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">  scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">  scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">  scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">  scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">  scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 根据上面的配置生成对应的 过滤器</span></span><br><span class="line">  scanner.registerFilters();</span><br><span class="line">    <span class="comment">// 开始扫描basePackage字段中指定的包及其子包</span></span><br><span class="line">  scanner.scan(</span><br><span class="line">      StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的核心是 scan方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    <span class="built_in">this</span>.doScan(basePackages);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用子类ClassPathMapperScanner 中的 doScan方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类中的 doScan方法 扫描所有的接口，把接口全部添加到beanDefinitions中。</span></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">    LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">        + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在注册beanDefinitions的时候，BeanClass被改为MapperFactoryBean</span></span><br><span class="line">    processBeanDefinitions(beanDefinitions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/dd0804867b50469285cbf1a56f79075b.png" alt="image.png"></p><p>因为一个接口是没法创建实例对象的，这时我们就在创建对象之前将这个接口类型指向了一个具体的普通Java类型，MapperFactoryBean .也就是说，所有的Mapper接口，在容器里面都被注册成一个支持泛型的MapperFactoryBean了。然后在创建这个接口的对象时创建的就是MapperFactoryBean 对象。</p><h4 id="2-2-5-MapperFactoryBean"><a href="#2-2-5-MapperFactoryBean" class="headerlink" title="2.2.5 MapperFactoryBean"></a>2.2.5 MapperFactoryBean</h4><p>为什么要注册成它呢？那注入使用的时候，也是这个对象，这个对象有什么作用？首先来看看他们的类图结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1660569226052/1f31b3afbf8248ddb8e4a1e982b25359.png" alt="image.png"></p><p>从类图中我们可以看到MapperFactoryBean继承了SqlSessionDaoSupport,那么每一个注入Mapper的地方，都可以拿到SqlSessionTemplate对象了。然后我们还发现MapperFactoryBean实现了 FactoryBean接口，也就意味着，向容器中注入MapperFactoryBean对象的时候，本质上是把getObject方法的返回对象注入到了容器中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// 从这可以看到 本质上 Mapper接口 还是通过DefaultSqlSession.getMapper方法获取了一个JDBC的代理对象，和我们前面讲解的就关联起来了</span></span><br><span class="line">  <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并没有直接返回一个MapperFactoryBean。而是调用了SqlSessionTemplate的getMapper()方法。SqlSessionTemplate的本质是一个代理，所以它最终会调用DefaultSqlSession的getMapper()方法。后面的流程我们就不重复了。也就是说，最后返回的还是一个JDK的动态代理对象。</p><p>所以最后调用Mapper接口的任何方法，也是执行MapperProxy的invoke()方法，后面的流程就跟编程式的工程里面一模一样了</p><p>总结一下，Spring是怎么把MyBatis继承进去的？</p><p>1、提供了SqlSession的替代品SqlSessionTemplate，里面有一个实现了实现了InvocationHandler的内部SqlSessionInterceptor，本质是对SqlSession的代理。</p><p>2、提供了获取SqlSessionTemplate的抽象类SqlSessionDaoSupport。</p><p>3、扫描Mapper接口，注册到容器中的是MapperFactoryBean，它继承了SqlSessionDaoSupport，可以获得SqlSessionTemplate。</p><p>4、把Mapper注入使用的时候，调用的是getObject()方法，它实际上是调用了SqlSessionTemplate的getMapper()方法，注入了一个JDK动态代理对象。</p><p>5、执行Mapper接口的任意方法，会走到触发管理类MapperProxy，进入SQL处理流程。</p><p>核心对象：</p><div class="table-container"><table><thead><tr><th><strong>对象</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>SqlSessionTemplate</td><td>Spring中SqlSession的替代品，是线程安全的</td></tr><tr><td>SqlSessionDaoSupport</td><td>用于获取SqlSessionTemplate</td></tr><tr><td>SqlSessionInterceptor（内部类）</td><td>代理对象，用来代理DefaultSqlSession，在SqlSessionTemplate中使用</td></tr><tr><td>MapperFactoryBean</td><td>代理对象，继承了SqlSessionDaoSupport用来获取SqlSessionTemplate</td></tr><tr><td>SqlSessionHolder</td><td>控制SqlSession和事务</td></tr></tbody></table></div><h2 id="3-设计模式总结"><a href="#3-设计模式总结" class="headerlink" title="3.设计模式总结"></a>3.设计模式总结</h2><div class="table-container"><table><thead><tr><th>设计模式</th><th><strong>类</strong></th></tr></thead><tbody><tr><td>工厂模式</td><td>SqlSessionFactory、ObjectFactory、MapperProxyFactory</td></tr><tr><td>建造者模式</td><td>XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuidler</td></tr><tr><td>单例模式</td><td>SqlSessionFactory、Configuration、ErrorContext</td></tr><tr><td>代理模式</td><td>绑定：MapperProxy<br>延迟加载：ProxyFactory   &#x3c;br/&gt;插件：PluginSpring  &#x3c;br&gt;集成MyBaits：  SqlSessionTemplate的内部SqlSessionInterceptorMyBatis&#x3c;br&gt;自带连接池：PooledConnection&#x3c;br/&gt;日志打印：ConnectionLogger、StatementLogger</td></tr><tr><td>适配器模式</td><td>Log，对于Log4j、JDK logging这些没有直接实现slf4j接口的日志组件，需要适配器</td></tr><tr><td>模板方法</td><td>BaseExecutor、SimpleExecutor、BatchExecutor、ReuseExecutor</td></tr><tr><td>装饰器模式</td><td>LoggingCache、LruCache对PerpetualCacheCachingExecutor对其他Executor</td></tr><tr><td>责任链模式</td><td>Interceptor、InterceptorChain</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis整合Spring的原理分析&quot;&gt;&lt;a href=&quot;#MyBatis整合Spring的原理分析&quot; class=&quot;headerlink&quot; title=&quot;MyBatis整合Spring的原理分析&quot;&gt;&lt;/a&gt;MyBatis整合Spring的原理分析&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis核心工作原理讲解</title>
    <link href="https://eizo01.github.io/posts/7233d38e.html"/>
    <id>https://eizo01.github.io/posts/7233d38e.html</id>
    <published>2022-12-08T12:00:00.000Z</published>
    <updated>2023-04-04T08:57:38.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis核心工作原理讲解"><a href="#MyBatis核心工作原理讲解" class="headerlink" title="MyBatis核心工作原理讲解"></a>MyBatis核心工作原理讲解</h1><h1 id="一、MyBatis源码分析"><a href="#一、MyBatis源码分析" class="headerlink" title="一、MyBatis源码分析"></a>一、MyBatis源码分析</h1><h2 id="1-三层划分介绍"><a href="#1-三层划分介绍" class="headerlink" title="1.三层划分介绍"></a>1.三层划分介绍</h2><p>首先大家要从宏观上了解Mybatis的整体框架分为三层，分别是基础支持层、核心处理层、和接口层。如下图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/0f2aea0caa394ff1bee96bb8bbb97dc9.png" alt="image.png"></p><p>然后根据前面讲解的MyBatis的应用案例，给出MyBatis的主要工作流程图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/561666a5f7f447f1b64927dcd15b1316.png" alt="image.png"></p><p>在MyBatis的主要工作流程里面，不同的功能是由很多不同的类协作完成的，它们分布在MyBatis jar包的不同的package里面。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/68b1458fe3b7431c8abdd50a66c760f4.png" alt="image.png"></p><p>大概有一千多个类，这样看起来不够清楚，不知道什么类在什么环节工作，属于什么层次。MyBatis按照功能职责的不同，所有的package可以分成不同的工作层次。上面的那个图已经给大家展现了</p><h3 id="1-1-接口层"><a href="#1-1-接口层" class="headerlink" title="1.1 接口层"></a>1.1 接口层</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先接口层是我们打交道最多的。核心对象是SqlSession，它是上层应用和MyBatis打交道的桥梁，SqlSession上定义了非常多的对数据库的操作方法。接口层在接收到调用请求的时候，会调用核心处理层的相应模块来完成具体的数据库操作。</span><br></pre></td></tr></table></figure><h3 id="1-2-核心处理层"><a href="#1-2-核心处理层" class="headerlink" title="1.2 核心处理层"></a>1.2 核心处理层</h3><p>接下来是核心处理层。既然叫核心处理层，也就是跟数据库操作相关的动作都是在这一层完成的。</p><p>核心处理层主要做了这几件事：</p><ol><li>把接口中传入的参数解析并且映射成JDBC类型；</li><li>解析xml文件中的SQL语句，包括插入参数，和动态SQL的生成；</li><li>执行SQL语句；</li><li>处理结果集，并映射成Java对象。</li></ol><p>插件也属于核心层，这是由它的工作方式和拦截的对象决定的。</p><h3 id="1-3-基础支持层"><a href="#1-3-基础支持层" class="headerlink" title="1.3 基础支持层"></a>1.3 基础支持层</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后一个就是基础支持层。基础支持层主要是一些抽取出来的通用的功能（实现复用），用来支持核心处理层的功能。比如数据源、缓存、日志、<span class="built_in">xml</span>解析、反射、IO、事务等等这些功能，</span><br></pre></td></tr></table></figure><h2 id="2-核心流程"><a href="#2-核心流程" class="headerlink" title="2. 核心流程"></a>2. 核心流程</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析源码我们还是从编程式的Demo入手。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis getMapper 方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.selectUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们通过一个比较复杂的步骤实现了MyBatis的数据库查询操作。下面我们会按照这5个步骤来分析MyBatis的运行原理</span><br></pre></td></tr></table></figure><p><strong>第一步：资源配置文件的读取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>第二步：解析配置文件，完成SqlSessionFactory的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">// 通过建造者模式来 构建复杂的对象  1.完成配置文件的加载解析  2.完成SqlSessionFactory的创建</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br></pre></td></tr></table></figure><p>原理：要获取SqlSessionFactory的实例，通常需要先读取MyBatis配置文件（比如mybatis-config.xml），然后使用该配置文件中的信息来创建一个Configuration对象。Configuration对象包含了MyBatis的所有配置信息，并且具备解析映射文件、构建执行器等能力。接着，使用Configuration对象构建DefaultSqlSessionFactory类的实例，这个类实现了SqlSessionFactory接口，提供了默认的SqlSession实现方式并将其返回给调用者。</p><p>问题：SqlSessionFactory 的实例我们没有通过 DefaultSqlSessionFactory直接来获取？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory是一个顶级接口，它由DefaultSqlSessionFactory来实现</span><br></pre></td></tr></table></figure><p>主要原因：</p><ul><li>SqlSessionFactoryBuilder：用于解析 MyBatis 配置文件并构建出基本的 SqlSessionFactory 对象。</li><li>DefaultSqlSessionFactory：用于创建 SqlSession 对象，提供数据库操作的接口。</li></ul><p>所以为了职责不同，SqlSessionFactory 生产 SqlSession 对象的 SqlSessionFactory 应该是单例。<br>SqlSessionFactoryBuilder负责读取 MyBatis 配置文件和映射文件等资源，并将其解析为内存对象，最终生成 SqlSessionFactory 实例。也只需要在 系统启动的时候完成加载操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 `SqlSessionFactoryBuilder` 来从配置文件中构建 `SqlSessionFactory` 实例。</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的设计模式：建造者和工厂模式</p><p>所以前面这两步就是启动MyBatis，加载了配置文件，创建了一个SqlSessionFactory</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 在启动的时候会做哪些操作？</span><br><span class="line">   <span class="number">1</span>.加载全局配置文件</span><br><span class="line">   <span class="number">2</span>.加载映射文件</span><br><span class="line">   <span class="number">3</span>.加载的内容存储在了那个<span class="keyword">Java对象中？ </span>Configuration</span><br></pre></td></tr></table></figure><p><strong>第三步：根据SqlSessionFactory对象获取SqlSession对象</strong></p><p>程序每一次操作数据库，都需要创建一个全局会话，我们用openSession()方法来创建，执行器一般有简单，可复用的，批处理的。（SIMPLE（默认）,REUSE,BATCH）</p><p>真正干活的是我们的执行器，而openSession只是我们的一个对外接口。</p><p>获得事务工厂，那么得到我们的事务对象就很简单了，然后根据事务对象和执行器类型得到一个执行器。</p><p>总结：创建会话的过程，我们获得了一个DefaultSqlSession，里面包含了一个Executor，Executor是SQL的实际执行对象。</p><p><strong>第四步：sql的执行过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = </span><br><span class="line">    <span class="comment">//名称空间 + id 在mapper.xml里</span></span><br><span class="line">    sqlSession.selectList(<span class="string">&quot;com.zdw.mapper.UserMapper.selectUserList&quot;</span>);</span><br></pre></td></tr></table></figure><p>查询怎么查</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230331140344451.png" alt="image-20230331140344451"></p><p>一级缓存是session级别，二级缓存是进程级别</p><p>在浏览器发送一次请求里，如果是请求数据的话，在进程里面缓存是可能性非常大的，而一级缓存它是会话级别的，有可能请求时会话就已经断开了</p><blockquote><p>MyBatis使用二级缓存来提高查询性能。当查询语句执行时，MyBatis先检查是否开启了二级缓存，如果开启了则会先从二级缓存中查找是否有匹配的结果。如果有匹配的结果，则直接返回结果，否则继续执行查询并将结果存放到二级缓存中。</p><p>MyBatis优先选择二级缓存的原因是，相比于从数据库中进行查询，从缓存中获取数据可以大大提高查询性能和响应速度，避免频繁地访问数据库，减轻数据库的压力，并且在一定程度上保证数据的一致性。</p><p>因此，对于同一个SqlSession对象，在执行了一次查询后，再次查询相同的数据，是从缓存中取出来的，并没有发送SQL语句到数据库。</p><p>但是，如果使用了多个SqlSession对象，每个SqlSession都有自己的一级缓存，那么第二个SqlSession查询相同的数据并不会从第一个SqlSession的缓存中取出来，而是会发送SQL到数据库查询数据。所以，如果需要跨SqlSession对象共享缓存，可以使用MyBatis的二级缓存。</p></blockquote><p>真正从数据库查询的操作，进一步的对jdbc的封装</p><p>执行器到最后也是交给StatementHandler去处理，而这里就是对原生JDBC的封装</p><h3 id="2-1-核心对象的生命周期"><a href="#2-1-核心对象的生命周期" class="headerlink" title="2.1 核心对象的生命周期"></a>2.1 核心对象的生命周期</h3><h4 id="2-1-1-SqlSessionFactoryBuiler"><a href="#2-1-1-SqlSessionFactoryBuiler" class="headerlink" title="2.1.1 SqlSessionFactoryBuiler"></a>2.1.1 SqlSessionFactoryBuiler</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是SqlSessionFactoryBuiler。它是用来构建SqlSessionFactory的，而SqlSessionFactory只需要一个，所以只要构建了这一个SqlSessionFactory，它的使命就完成了，也就没有存在的意义了。所以它的生命周期只存在于方法的局部。</span><br></pre></td></tr></table></figure><h4 id="2-1-2-SqlSessionFactory"><a href="#2-1-2-SqlSessionFactory" class="headerlink" title="2.1.2 SqlSessionFactory"></a>2.1.2 SqlSessionFactory</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory是用来创建SqlSession的，每次应用程序访问数据库，都需要创建一个会话。因为我们一直有创建会话的需要，所以SqlSessionFactory应该存在于应用的整个生命周期中（作用域是应用作用域）。创建SqlSession只需要一个实例来做这件事就行了，否则会产生很多的混乱，和浪费资源。所以我们要采用单例模式。</span><br></pre></td></tr></table></figure><h4 id="2-1-3-SqlSession"><a href="#2-1-3-SqlSession" class="headerlink" title="2.1.3 SqlSession"></a>2.1.3 SqlSession</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession是一个会话，因为它不是线程安全的，不能在线程间共享。所以我们在请求开始的时候创建一个SqlSession对象，在请求结束或者说方法执行完毕的时候要及时关闭它（一次请求或者操作中）。</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Mapper"><a href="#2-1-4-Mapper" class="headerlink" title="2.1.4 Mapper"></a>2.1.4 Mapper</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapper（实际上是一个代理对象）是从SqlSession中获取的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>它的作用是发送SQL来操作数据库的数据。它应该在一个SqlSession事务方法之内。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/f53b812216e84dcb94c50f92671b429d.png" alt="image.png"></p><h3 id="2-2-SqlSessionFactory"><a href="#2-2-SqlSessionFactory" class="headerlink" title="2.2 SqlSessionFactory"></a>2.2 SqlSessionFactory</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331133249354.png" alt="image-20230331133249354">映射文件就是CRUD标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先我们来看下SqlSessionFactory对象的获取</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br></pre></td></tr></table></figure><h5 id="2-2-1-SqlSessionFactoryBuilder"><a href="#2-2-1-SqlSessionFactoryBuilder" class="headerlink" title="2.2.1 SqlSessionFactoryBuilder"></a>2.2.1 SqlSessionFactoryBuilder</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先我们<span class="keyword">new</span><span class="type"></span>了一个SqlSessionFactoryBuilder，这是建造者模式的运用（建造者模式用来创建复杂对象，而不需要关注内部细节，是一种封装的体现）。MyBatis中很多地方用到了建造者模式（名字以Builder结尾的类还有<span class="number">9</span>个）。</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder中用来创建SqlSessionFactory对象的方法是<span class="built_in">build</span>()，<span class="built_in">build</span>()方法有<span class="number">9</span>个重载，可以用不同的方式来创建SqlSessionFactory对象。SqlSessionFactory对象默认是单例的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 用于解析 mybatis-config.xml，同时创建了 Configuration 对象 &gt;&gt;</span></span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">    <span class="comment">// 解析XML，最终返回一个 DefaultSqlSessionFactory &gt;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">build</span>方法中首先是创建了一个XMLConfigBuilder对象，XMLConfigBuilder是抽象类BaseBuilder的一个子类，专门用来解析全局配置文件，针对不同的构建目标还有其他的一些子类（关联到源码路径），比如：</span><br></pre></td></tr></table></figure><ul><li>XMLMapperBuilder：解析Mapper映射器</li><li>XMLStatementBuilder：解析增删改查标签</li><li>XMLScriptBuilder：解析动态SQL</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后是执行了</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build(parser.parse());</span><br></pre></td></tr></table></figure><p>构建的代码，parser.parse()方法返回的是一个Configuration对象，build方法的如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这儿我们可以看到SessionFactory最终实现是DefaultSqlSessionFactory对象。</p><h4 id="2-2-2-XMLConfigBuilder"><a href="#2-2-2-XMLConfigBuilder" class="headerlink" title="2.2.2 XMLConfigBuilder"></a>2.2.2 XMLConfigBuilder</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们再来看下XMLConfigBuilder初始化的时候做了哪些操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> &#123;</span><br><span class="line">  <span class="comment">// EntityResolver的实现类是XMLMapperEntityResolver 来完成配置文件的校验，根据对应的DTD文件来实现</span></span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(inputStream, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再去进入重载的构造方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>()); <span class="comment">// 完成了Configuration的初始化</span></span><br><span class="line">  ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.configuration.setVariables(props); <span class="comment">// 设置对应的Properties属性</span></span><br><span class="line">  <span class="built_in">this</span>.parsed = <span class="literal">false</span>; <span class="comment">// 设置 是否解析的标志为 false</span></span><br><span class="line">  <span class="built_in">this</span>.environment = environment; <span class="comment">// 初始化environment</span></span><br><span class="line">  <span class="built_in">this</span>.parser = parser; <span class="comment">// 初始化 解析器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Configuration"><a href="#2-2-3-Configuration" class="headerlink" title="2.2.3 Configuration"></a>2.2.3 Configuration</h4><p>然后我们可以看下Configuration初始化做了什么操作</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/559d82906a7646e3838fc24858978e30.png" alt="image.png"></p><p>完成了类型别名的注册工作，通过上面的分析我们可以看到XMLConfigBuilder完成了XML文件的解析对应XPathParser和Configuration对象的初始化操作，然后我们再来看下parse方法到底是如何解析配置文件的</p><h4 id="2-2-4-parse解析"><a href="#2-2-4-parse解析" class="headerlink" title="2.2.4 parse解析"></a>2.2.4 parse解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.parse()</span><br></pre></td></tr></table></figure><p>进入具体的解析方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 检查是否已经解析过了</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// XPathParser，dom 和 SAX 都有用到 &gt;&gt;  开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseConfiguration方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//issue #117 read properties first</span></span><br><span class="line">    <span class="comment">// 对于全局配置文件各种标签的解析</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 settings 标签</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    <span class="comment">// 日志设置</span></span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    <span class="comment">// 类型别名</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    <span class="comment">// 用于创建对象</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 用于对对象进行加工</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 反射工具箱</span></span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">// 创建了数据源 &gt;&gt;</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析引用的Mapper映射器</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-4-1-全局配置文件解析"><a href="#2-2-4-1-全局配置文件解析" class="headerlink" title="2.2.4.1 全局配置文件解析"></a>2.2.4.1 全局配置文件解析</h5><p><strong>properties解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建了一个 Properties 对象，后面可以用到</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">defaults</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// url 和 resource 不能同时存在</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载resource或者url属性中指定的 properties 文件</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">vars</span> <span class="operator">=</span> configuration.getVariables();</span><br><span class="line">    <span class="keyword">if</span> (vars != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 和 Configuration中的 variables 属性合并</span></span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新对应的属性信息</span></span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个是解析\<properties>标签，读取我们引入的外部配置文件，例如db.properties。</properties></p><p>这里面又有两种类型，一种是放在resource目录下的，是相对路径，一种是写的绝对路径的（url）。</p><p>解析的最终结果就是我们会把所有的配置信息放到名为defaults的Properties对象里面（Hashtable对象，KV存储），最后把XPathParser和Configuration的Properties属性都设置成我们填充后的Properties对象。</p><p><strong>settings解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Properties <span class="title function_">settingsAsProperties</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取settings节点下的所有的子节点</span></span><br><span class="line">  <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">  <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">  <span class="type">MetaClass</span> <span class="variable">metaConfig</span> <span class="operator">=</span> MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The setting &quot;</span> + key + <span class="string">&quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getChildrenAsProperties方法就是具体的解析了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Properties <span class="title function_">getChildrenAsProperties</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  <span class="keyword">for</span> (XNode child : getChildren()) &#123;</span><br><span class="line">    <span class="comment">// 获取对应的name和value属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      properties.setProperty(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadCustomVfs(settings)方法</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadCustomVfs是获取Vitual <span class="keyword">File</span> <span class="keyword">System</span>的自定义实现类，比如要读取本地文件，或者FTP远程文件的时候，就可以用到自定义的VFS类。</span><br></pre></td></tr></table></figure><p>根据\<settings>标签里面的\<vfsImpl>标签，生成了一个抽象类VFS的子类，在MyBatis中有JBoss6VFS和DefaultVFS两个实现，在io包中。</vfsImpl></settings></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadCustomVfs</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;vfsImpl&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] clazzes = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String clazz : clazzes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!clazz.isEmpty()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt; vfsImpl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt;)Resources.classForName(clazz);</span><br><span class="line">        configuration.setVfsImpl(vfsImpl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后赋值到<span class="keyword">Configuration</span>中。</span><br></pre></td></tr></table></figure><p><strong>loadCustomLogImpl(settings)方法</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">load</span>CustomLogImpl是根据</span><br></pre></td></tr></table></figure><p>\<logImpl>标签获取日志的实现类，我们可以用到很多的日志的方案，包括LOG4J，LOG4J2，SLF4J等等，在logging包中。</logImpl></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadCustomLogImpl</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; logImpl = resolveClass(props.getProperty(<span class="string">&quot;logImpl&quot;</span>));</span><br><span class="line">  configuration.setLogImpl(logImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typeAliases解析</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一步是类型别名的解析</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeAliasesElement</span><span class="params">(XNode parent)</span> &#123;</span><br><span class="line">  <span class="comment">// 放入 TypeAliasRegistry</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeAliasPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;alias&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描 @Alias 注解使用</span></span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接注册</span></span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error registering typeAlias for &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>plugins解析</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件标签的解析</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 获取&lt;plugin&gt; 节点的 interceptor 属性的值</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取&lt;plugin&gt; 下的所有的properties子节点</span></span><br><span class="line">      <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 获取 Interceptor 对象</span></span><br><span class="line">      <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">      <span class="comment">// 设置 interceptor的 属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">// Configuration中记录 Interceptor</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件的具体使用后面专门介绍</p><p>objectFactory，objectWrapperFactory及reflectorFactory解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取&lt;objectFactory&gt; 节点的 type 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 &lt;objectFactory&gt; 节点下的配置信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 获取ObjectFactory 对象的对象 通过反射方式</span></span><br><span class="line">    <span class="type">ObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">// ObjectFactory 和 对应的属性信息关联</span></span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    <span class="comment">// 将创建的ObjectFactory对象绑定到Configuration中</span></span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectWrapperFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="type">ObjectWrapperFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reflectorFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="type">ReflectorFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFactory用来创建返回的对象。</p><p>ObjectWrapperFactory用来对对象做特殊的处理。比如：select没有写别名，查询返回的是一个Map，可以在自定义的objectWrapperFactory中把下划线命名变成驼峰命名。</p><p>ReflectorFactory是反射的工具箱，对反射的操作进行了封装（官网和文档没有这个对象的描述）。</p><p>以上四个对象，都是用resolveClass创建的。</p><p><strong>settingsElement(settings)方法</strong></p><p>这里就是对\<settings>标签里面所有子标签的处理了，前面我们已经把子标签全部转换成了Properties对象，所以在这里处理Properties对象就可以了。</settings></p><p>settings二级标签中一共26个配置，比如二级缓存、延迟加载、默认执行器类型等等。</p><p>需要注意的是，我们之前提到的所有的默认值，都是在这里赋值的。如果说后面我们不知道这个属性的值是什么，也可以到这一步来确认一下。</p><p>所有的值，都会赋值到Configuration的属性里面去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">settingsElement</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingBehavior&quot;</span>, <span class="string">&quot;PARTIAL&quot;</span>)));</span><br><span class="line">  configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span>, <span class="string">&quot;NONE&quot;</span>)));</span><br><span class="line">  configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;cacheEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">&quot;proxyFactory&quot;</span>)));</span><br><span class="line">  configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;lazyLoadingEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(<span class="string">&quot;aggressiveLazyLoading&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;multipleResultSetsEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setUseColumnLabel(booleanValueOf(props.getProperty(<span class="string">&quot;useColumnLabel&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(<span class="string">&quot;useGeneratedKeys&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(<span class="string">&quot;defaultExecutorType&quot;</span>, <span class="string">&quot;SIMPLE&quot;</span>)));</span><br><span class="line">  configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(<span class="string">&quot;defaultStatementTimeout&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">  configuration.setDefaultFetchSize(integerValueOf(props.getProperty(<span class="string">&quot;defaultFetchSize&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">  configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(<span class="string">&quot;defaultResultSetType&quot;</span>)));</span><br><span class="line">  configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeRowBoundsEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(<span class="string">&quot;localCacheScope&quot;</span>, <span class="string">&quot;SESSION&quot;</span>)));</span><br><span class="line">  configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(<span class="string">&quot;jdbcTypeForNull&quot;</span>, <span class="string">&quot;OTHER&quot;</span>)));</span><br><span class="line">  configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(<span class="string">&quot;lazyLoadTriggerMethods&quot;</span>), <span class="string">&quot;equals,clone,hashCode,toString&quot;</span>));</span><br><span class="line">  configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeResultHandlerEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(<span class="string">&quot;defaultScriptingLanguage&quot;</span>)));</span><br><span class="line">  configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(<span class="string">&quot;defaultEnumTypeHandler&quot;</span>)));</span><br><span class="line">  configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(<span class="string">&quot;callSettersOnNulls&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setUseActualParamName(booleanValueOf(props.getProperty(<span class="string">&quot;useActualParamName&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(<span class="string">&quot;returnInstanceForEmptyRow&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  configuration.setLogPrefix(props.getProperty(<span class="string">&quot;logPrefix&quot;</span>));</span><br><span class="line">  configuration.setConfigurationFactory(resolveClass(props.getProperty(<span class="string">&quot;configurationFactory&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>environments解析</strong></p><p>这一步是解析\<environments>标签。</environments></p><p>我们前面讲过，一个environment就是对应一个数据源，所以在这里我们会根据配置的\<transactionManager>创建一个事务工厂，根据\<dataSource>标签创建一个数据源，最后把这两个对象设置成Environment对象的属性，放到Configuration里面。</dataSource></transactionManager></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        <span class="comment">// 事务工厂</span></span><br><span class="line">        <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">        <span class="comment">// 数据源工厂（例如 DruidDataSourceFactory ）</span></span><br><span class="line">        <span class="type">DataSourceFactory</span> <span class="variable">dsFactory</span> <span class="operator">=</span> dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">        <span class="comment">// 数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> dsFactory.getDataSource();</span><br><span class="line">        <span class="comment">// 包含了 事务工厂和数据源的 Environment</span></span><br><span class="line">        Environment.<span class="type">Builder</span> <span class="variable">environmentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">        <span class="comment">// 放入 Configuration</span></span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>databaseIdProviderElement()</strong></p><p>解析databaseIdProvider标签，生成DatabaseIdProvider对象（用来支持不同厂商的数据库）。</p><p><strong>typeHandlerElement()</strong></p><p>跟TypeAlias一样，TypeHandler有两种配置方式，一种是单独配置一个类，一种是指定一个package。最后我们得到的是JavaType和JdbcType，以及用来做相互映射的TypeHandler之间的映射关系，存放在TypeHandlerRegistry对象里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeHandlerElement</span><span class="params">(XNode parent)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeHandlerPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;javaType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jdbcTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;jdbcType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">        <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">        <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper解析</strong></p><p>最后就是\<mappers>标签的解析。</mappers></p><p>根据全局配置文件中不同的注册方式，用不同的方式扫描，但最终都是做了两件事情，对于语句的注册和接口的注册。</p><div class="table-container"><table><thead><tr><th>扫描类型</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>resource</td><td>相对路径</td></tr><tr><td>url</td><td>绝对路径</td></tr><tr><td>package</td><td>包</td></tr><tr><td>class</td><td>单个接口</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        &lt;mapper class=<span class="string">&quot;com.zdw.mapper.UserMapper&quot;</span> /&gt;--&gt; <span class="comment">//包路径</span></span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 不同的定义方式的扫描，最终都是调用 addMapper()方法（添加到 MapperRegistry）。这个方法和 getMapper() 对应</span></span><br><span class="line">      <span class="comment">// package包</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// resource相对路径</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">            <span class="comment">// 读取映射文件</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">// XMLMapperBuilder 解析映射文件</span></span><br><span class="line">          XMLMapperBuilder 解析 mapperParser = <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">// 解析 Mapper.xml，总体上做了两件事情 &gt;&gt; 往下看</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// url绝对路径</span></span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// class 单个接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始进入具体的配置文件的解析操作</p><h5 id="2-2-4-2-映射文件的解析"><a href="#2-2-4-2-映射文件的解析" class="headerlink" title="2.2.4.2 映射文件的解析"></a>2.2.4.2 映射文件的解析</h5><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先进入<span class="built_in">parse</span>方法，<span class="number">1</span>、对于语句注册和接口注册</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 总体上做了两件事情，对于语句的注册和接口的注册</span></span><br><span class="line">    <span class="comment">//判断是否加载过映射文件</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 1、具体增删改查标签的解析。</span></span><br><span class="line">    <span class="comment">// 一个标签一个MappedStatement。 &gt;&gt;</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 2、把namespace（接口类型）和工厂类绑定起来，放到一个map。</span></span><br><span class="line">    <span class="comment">// 一个namespace 一个 MapperProxyFactory &gt;&gt;</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configurationElement()——解析所有的子标签，最终获得MappedStatement对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.boge.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span></span><br><span class="line">        id,user_name,real_name,password,age,d_id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>bindMapperForNamespace()——把namespace（接口类型）和工厂类MapperProxyFactory绑定起来。</p><h6 id="configurationElement方法"><a href="#configurationElement方法" class="headerlink" title="configurationElement方法"></a><strong>configurationElement方法</strong></h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configurationElement是对Mapper.xml中所有具体的标签的解析，包括<span class="keyword">namespace</span>、<span class="symbol">cache</span>、<span class="symbol">parameterMap</span>、<span class="symbol">resultMap</span>、<span class="symbol">sql</span>和<span class="symbol">select</span>|<span class="symbol">insert</span>|<span class="symbol">update</span>|<span class="symbol">delete</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绑定名称空间</span></span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 添加缓存对象 如果希望多个名称空间共同使用同一个二级缓存就可以使用</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 cache 属性，添加缓存对象</span></span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建 ParameterMapping 对象 不推荐废弃了</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建 List&lt;ResultMapping&gt;</span></span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析可以复用的SQL</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析增删改查标签，得到 MappedStatement &gt;&gt;</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在buildStatementFromContext()方法中，创建了用来解析增删改查标签的XMLStatementBuilder，并且把创建的MappedStatement添加到mappedStatements中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">MappedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> statementBuilder.build();</span><br><span class="line">   <span class="comment">// 最关键的一步，在 Configuration 添加了 MappedStatement &gt;&gt;</span></span><br><span class="line">   configuration.addMappedStatement(statement);</span><br></pre></td></tr></table></figure><h6 id="bindMapperForNamespace方法"><a href="#bindMapperForNamespace方法" class="headerlink" title="bindMapperForNamespace方法"></a><strong>bindMapperForNamespace方法</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindMapperForNamespace</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> builderAssistant.getCurrentNamespace();</span><br><span class="line">  <span class="keyword">if</span> (namespace != <span class="literal">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; boundType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据名称空间加载对应的接口类型</span></span><br><span class="line">      boundType = Resources.classForName(namespace);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boundType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">        <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">        <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">        <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">        configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">        <span class="comment">// 添加到 MapperRegistry，本质是一个 map，里面也有 Configuration &gt;&gt;</span></span><br><span class="line">        configuration.addMapper(boundType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过源码分析发现主要是是调用了<span class="built_in">addMapper</span>()。<span class="built_in">addMapper</span>()方法中，把接口类型注册到MapperRegistry中：实际上是为接口创建一个对应的MapperProxyFactory（用于为这个type提供工厂类，创建MapperProxy）。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123; <span class="comment">// 检测 type 是否为接口</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123; <span class="comment">// 检测是否已经加装过该接口</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ！Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; 存放的是接口类型，和对应的工厂类的关系</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;&gt;(type));</span><br><span class="line">      <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册了接口之后，根据接口，开始解析所有方法上的注解，例如 @Select &gt;&gt;</span></span><br><span class="line">      <span class="type">MapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperAnnotationBuilder</span>(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的再进入parse方法中查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> type.toString();</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 先判断 Mapper.xml 有没有解析，没有的话先解析 Mapper.xml（例如定义 package 方式）</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    <span class="comment">// 处理 @CacheNamespace</span></span><br><span class="line">    parseCache();</span><br><span class="line">    <span class="comment">// 处理 @CacheNamespaceRef</span></span><br><span class="line">    parseCacheRef();</span><br><span class="line">    <span class="comment">// 获取所有方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// issue #237</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">// 解析方法上的注解，添加到 MappedStatement 集合中 &gt;&gt;</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> <span class="title class_">MethodResolver</span>(<span class="built_in">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以继续进入到parseStatement方法中查看。</p><p>总结：</p><ol><li>我们主要完成了config配置文件、Mapper文件、Mapper接口中注解的解析。</li><li>我们得到了一个最重要的对象Configuration，这里面存放了全部的配置信息，它在属性里面还有各种各样的容器。</li><li>最后，返回了一个DefaultSqlSessionFactory，里面持有了Configuration的实例。</li></ol><p>最后的时序图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/0ec80d74c1f546c08dd5e79eee31ff37.png" alt="image.png"></p><h3 id="2-3-SqlSession"><a href="#2-3-SqlSession" class="headerlink" title="2.3 SqlSession"></a>2.3 SqlSession</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331135531498.png" alt="image-20230331135531498"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序每一次操作数据库，都需要创建一个会话，我们用<span class="keyword">open</span><span class="constructor">Session()</span>方法来创建。接下来我们看看SqlSession创建过程中做了哪些操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过前面创建的DefaultSqlSessionFactory的openSession方法来创建</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会获取默认的执行器类型。默认的是simple</p><p><strong>继续往下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 创建事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们在解析environment标签的时候有创建TransactionFactory对象</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/a38daed1923a4eca86a46da0314346c0.png" alt="image.png"></p><p><strong>根据事务工厂和默认的执行器类型，创建执行器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      <span class="comment">//穿一件衣服-》装饰模式</span></span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后返回的是一个DefaultSqlSession对象</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/ec8d7ab5e6194cf4a6cc10ee303149f2.png" alt="image.png"></p><p>在这个DefaultSqlSession对象中包括了Configuration和Executor对象</p><p>总结：创建会话的过程，我们获得了一个DefaultSqlSession，里面包含了一个Executor，Executor是SQL的实际执行对象。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/96fdcffdb1e54f4f8fb72a84133b7f26.png" alt="image.png"></p><h3 id="2-4-Mapper代理对象"><a href="#2-4-Mapper代理对象" class="headerlink" title="2.4 Mapper代理对象"></a>2.4 Mapper代理对象</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来看下通过getMapper方法获取对应的接口的代理对象的实现原理</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>进入DefaultSqlSession中查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="comment">// mapperRegistry中注册的有Mapper的相关信息 在解析映射文件时 调用过addMapper方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入getMapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Mapper接口对应的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取Mapper接口对应的 MapperProxyFactory 对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入newInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实现了 mapperInterface 接口的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">  <span class="comment">// 1：类加载器:2：被代理类实现的接口、3：实现了 InvocationHandler 的触发管理类</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们在代码中发现代理对象是通过JDK动态代理创建，返回的代理对象。而且里面也传递了一个实现了InvocationHandler接口的触发管理类。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/61cfbb435a3f41c397683c15cbe4a81a.png" alt="image.png"></p><p>总结：获得Mapper对象的过程，实质上是获取了一个JDK动态代理对象（类型是$ProxyN）。这个代理类会继承Proxy类，实现被代理的接口，里面持有了一个MapperProxy类型的触发管理类。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/99732f0f96dc44f4b463a1eb9c469d1b.png" alt="image.png"></p><h3 id="2-5-SQL执行"><a href="#2-5-SQL执行" class="headerlink" title="2.5 SQL执行"></a>2.5 SQL执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们看看<span class="keyword">SQL</span>语句的具体执行过程是怎么样的</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = mapper.selectUserList();</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于所有的Mapper都是JDK动态代理对象，所以任意的方法都是执行触发管理类MapperProxy的<span class="built_in">invoke</span>()方法</span><br></pre></td></tr></table></figure><h4 id="2-5-1-MapperProxy-invoke"><a href="#2-5-1-MapperProxy-invoke" class="headerlink" title="2.5.1 MapperProxy.invoke()"></a>2.5.1 MapperProxy.invoke()</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们直接进入到<span class="keyword">invoke</span>方法中</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // toString hashCode equals getClass等方法，无需走到执行SQL的流程</span><br><span class="line">   <span class="built_in"> if </span>(Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">     <span class="built_in"> return </span>method.invoke(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的<span class="built_in"> invoke</span></span><br><span class="line"><span class="built_in"></span>      // 普通方法会走到 PlainMethodInvoker（内部类） 的<span class="built_in"> invoke</span></span><br><span class="line"><span class="built_in"></span>     <span class="built_in"> return </span>cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">   <span class="built_in"> throw </span>ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入到PlainMethodInvoker的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">// SQL执行的真正起点</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-mapperMethod-execute"><a href="#2-5-2-mapperMethod-execute" class="headerlink" title="2.5.2 mapperMethod.execute()"></a>2.5.2 mapperMethod.execute()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123; <span class="comment">// 根据SQL语句的类型调用SqlSession对应的方法</span></span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 通过 ParamNameResolver 处理args[] 数组 将用户传入的实参和指定参数名称关联起来</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      <span class="comment">// sqlSession.insert(command.getName(), param) 调用SqlSession的insert方法</span></span><br><span class="line">      <span class="comment">// rowCountResult 方法会根据 method 字段中记录的方法的返回值类型对结果进行转换</span></span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        <span class="comment">// 返回值为空 且 ResultSet通过 ResultHandler处理的方法</span></span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值为 单一对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        <span class="comment">// 普通 select 语句的执行入口 &gt;&gt;</span></span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == <span class="literal">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">          result = Optional.ofNullable(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">        + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这一步，根据不同的type（INSERT、UPDATE、DELETE、SELECT）和返回类型：</p><p>1）调用convertArgsToSqlCommandParam()将方法参数转换为SQL的参数。</p><p>2）调用sqlSession的insert()、update()、delete()、selectOne ()方法。我们以查询为例，会走到selectOne()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure><h4 id="2-5-3-sqlSession-selectOne"><a href="#2-5-3-sqlSession-selectOne" class="headerlink" title="2.5.3 sqlSession.selectOne"></a>2.5.3 sqlSession.selectOne</h4><p>这里来到了对外的接口的默认实现类DefaultSqlSession。</p><p>selectOne()最终也是调用了selectList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 来到了 DefaultSqlSession</span></span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SelectList()中，我们先根据command name（Statement ID）从Configuration中拿到MappedStatement。ms里面有xml中增删改查标签配置的所有属性，包括id、statementType、sqlSource、useCache、入参、出参等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 如果 cacheEnabled = true（默认），Executor会被 CachingExecutor装饰</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行了Executor的query()方法。</p><p>Executor是第二步openSession的时候创建的，创建了执行器基本类型之后，依次执行了二级缓存装饰，和插件包装。</p><p>所以，如果有被插件包装，这里会先走到插件的逻辑。如果没有显式地在settings中配置cacheEnabled=false，再走到CachingExecutor的逻辑，然后会走到BaseExecutor的query()方法。</p><h4 id="2-5-4-CachingExecutor-query"><a href="#2-5-4-CachingExecutor-query" class="headerlink" title="2.5.4 CachingExecutor.query()"></a>2.5.4 CachingExecutor.query()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 获取SQL</span></span><br><span class="line">  <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span></span><br><span class="line">  <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的CacheKey是怎么构成的呢？或者说，什么样的查询才能确定是同一个查询呢？</p><p>在BaseExecutor的createCacheKey方法中，用到了六个要素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cacheKey.update(ms.getId()); <span class="comment">// com.msb.mapper.BlogMapper.selectBlogById</span></span><br><span class="line">cacheKey.update(rowBounds.getOffset()); <span class="comment">// 0</span></span><br><span class="line">cacheKey.update(rowBounds.getLimit()); <span class="comment">// 2147483647 = 2^31-1</span></span><br><span class="line">cacheKey.update(boundSql.getSql());</span><br><span class="line">cacheKey.update(value);</span><br><span class="line">cacheKey.update(configuration.getEnvironment().getId());</span><br></pre></td></tr></table></figure><p>也就是说，方法相同、翻页偏移相同、SQL相同、参数值相同、数据源环境相同，才会被认为是同一个查询。</p><p>CacheKey的实际值举例（toString()生成的），debug可以看到：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1381545870:4796102018:com.msb.mapper.BlogMapper.selectBlogById:0:2147483647:select * from blog where bid = ?:1:development</span><br></pre></td></tr></table></figure><p>注意看一下CacheKey的属性，里面有一个List按顺序存放了这些要素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MULTIPLIER</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HASHCODE</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> multiplier;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> hashcode;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> checksum;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> <span class="keyword">private</span> List&lt;Object&gt; updateList</span><br></pre></td></tr></table></figure><p>怎么比较两个CacheKey是否相等呢？如果一上来就是依次比较六个要素是否相等，要比较6次，这样效率不高。有没有更高效的方法呢？继承Object的每个类，都有一个hashCode ()方法，用来生成哈希码。它是用来在集合中快速判重的。</p><p>在生成CacheKey的时候（update方法），也更新了CacheKey的hashCode，它是用乘法哈希生成的（基数baseHashCode=17，乘法因子multiplier=37）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcode = multiplier * hashcode + baseHashCode;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span>中的<span class="built_in">hashCode</span>()是一个本地方法，通过随机数算法生成（OpenJDK8 ，默认，可以通过-XX<span class="selector-pseudo">:has</span>hCode修改）。CacheKey中的<span class="built_in">hashCode</span>()方法进行了重写，返回自己生成的hashCode。</span><br></pre></td></tr></table></figure><p>为什么要用37作为乘法因子呢？跟String中的31类似。</p><p>CacheKey中的equals也进行了重写，比较CacheKey是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span> == object) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (CacheKey) object;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">thisObject</span> <span class="operator">=</span> updateList.get(i);</span><br><span class="line">     <span class="type">Object</span> <span class="variable">thatObject</span> <span class="operator">=</span> cacheKey.updateList.get(i);</span><br><span class="line">     <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果哈希值（乘法哈希）、校验值（加法哈希）、要素个数任何一个不相等，都不是同一个查询，最后才循环比较要素，防止哈希碰撞。</p><p>CacheKey生成之后，调用另一个query()方法。</p><h4 id="2-5-5-BaseExecutor-query方法"><a href="#2-5-5-BaseExecutor-query方法" class="headerlink" title="2.5.5 BaseExecutor.query方法"></a>2.5.5 BaseExecutor.query方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">  <span class="comment">// cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span></span><br><span class="line">  <span class="comment">// 由 &lt;cache&gt; 标签决定</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// flushCache=&quot;true&quot; 清空一级二级缓存 &gt;&gt;</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="comment">// 获取二级缓存</span></span><br><span class="line">      <span class="comment">// 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 写入二级缓存</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span></span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 异常体系之 ErrorContext</span></span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// flushCache=&quot;true&quot;时，即使是查询，也清空一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 防止递归查询重复处理缓存</span></span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 查询一级缓存</span></span><br><span class="line">    <span class="comment">// ResultHandler 和 ResultSetHandler的区别</span></span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 真正的查询流程</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">// 先占位</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 三种 Executor 的区别，看doUpdate</span></span><br><span class="line">    <span class="comment">// 默认Simple</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 移除占位符</span></span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入一级缓存</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-6-SimpleExecutor-doQuery方法"><a href="#2-5-6-SimpleExecutor-doQuery方法" class="headerlink" title="2.5.6 SimpleExecutor.doQuery方法"></a>2.5.6 SimpleExecutor.doQuery方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 获取一个 Statement对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 用完就关闭</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在configuration.<span class="keyword">new</span><span class="type">StatementHandler</span>()中，<span class="keyword">new</span><span class="type"></span>一个StatementHandler，先得到RoutingStatementHandler。</span><br></pre></td></tr></table></figure><p>RoutingStatementHandler里面没有任何的实现，是用来创建基本的StatementHandler的。这里会根据MappedStatement里面的statementType决定StatementHandler的类型。默认是PREPARED（STATEMENT、PREPARED、CALLABLE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType=&quot;PREPARED&quot;，默认值 PREPARED</span></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">SimpleStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      <span class="comment">// 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span></span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">PreparedStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">CallableStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatementHandler里面包含了处理参数的ParameterHandler和处理结果集的ResultSetHandler。</p><p>这两个对象都是在上面new的时候创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  <span class="built_in">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">  <span class="built_in">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  <span class="built_in">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (boundSql == <span class="literal">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了四大对象的其它两大对象 &gt;&gt;</span></span><br><span class="line">  <span class="comment">// 创建这两大对象的时候分别做了什么？</span></span><br><span class="line">  <span class="built_in">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="built_in">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这三个对象都是可以被插件拦截的四大对象之一，所以在创建之后都要用拦截器进行包装的方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ParameterHandler <span class="title function_">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">ParameterHandler</span> <span class="variable">parameterHandler</span> <span class="operator">=</span> mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ResultSetHandler <span class="title function_">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span><br><span class="line"><span class="params">    ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">ResultSetHandler</span> <span class="variable">resultSetHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultSetHandler</span>(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> StatementHandler <span class="title function_">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingStatementHandler</span>(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建Statement</strong></p><p>用new出来的StatementHandler创建Statement对象。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/2ebb88356cf347ad835ee7f9ec97f0e9.png" alt="image.png"></p><p><strong>执行查询操作,如果有插件包装，会先走到被拦截的业务逻辑。</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="keyword">handler</span>.<span class="title">query</span><span class="params">(stmt, resultHandler)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>进入到PreparedStatementHandler中处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">    <span class="comment">// 到了JDBC的流程</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">// 处理结果集</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行PreparedStatement的execute()方法，后面就是JDBC包中的PreparedStatement的执行了。</strong><br><strong>ResultSetHandler处理结果集，如果有插件包装，会先走到被拦截的业务逻辑。</strong></p><p><strong>总结：调用代理对象执行SQL操作的流程</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657799522091/f5e29e9810c444df970c45e802d3ad23.png" alt="image.png"></p><h3 id="2-6-MyBatis核心对象"><a href="#2-6-MyBatis核心对象" class="headerlink" title="2.6 MyBatis核心对象"></a>2.6 MyBatis核心对象</h3><p><img src="HTTPs://zdwtop.cn/blog/image-20230331144755674.png" alt="image-20230331144755674"></p><div class="table-container"><table><thead><tr><th><strong>对象</strong></th><th>相关对象</th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>Configuration</td><td>MapperRegistry<br>TypeAliasRegistry<br>TypeHandlerRegistry</td><td>包含了MyBatis的所有的配置信息</td></tr><tr><td>SqlSession</td><td>SqlSessionFactory<br>DefaultSqlSession</td><td>对操作数据库的增删改查的API进行了封装，提供给应用层使用</td></tr><tr><td>Executor</td><td>BaseExecutor<br>SimpleExecutor<br>BatchExecutor<br>ReuseExecutor</td><td>MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</td></tr><tr><td>StatementHandler</td><td>BaseStatementHandler<br>SimpleStatementHandler<br>PreparedStatementHandler<br>CallableStatementHandler</td><td>封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</td></tr><tr><td>ParameterHandler</td><td>DefaultParameterHandler</td><td>把用户传递的参数转换成JDBC Statement 所需要的参数</td></tr><tr><td>ResultSetHandler</td><td>DefaultResultSetHandler</td><td>把JDBC返回的ResultSet结果集对象转换成List类型的集合</td></tr><tr><td>MapperProxy</td><td>MapperProxyFactory</td><td>触发管理类，用于代理Mapper接口方法</td></tr><tr><td>MappedStatement</td><td>SqlSource<br>BoundSql</td><td>MappedStatement维护了一条&lt;select\</td><td>update\</td><td>delete\</td><td>insert&gt;节点的封装，表示一条SQL包括了SQL信息、入参信息、出参信息</td></tr></tbody></table></div><blockquote><p><strong>看源码的注意事项</strong></p><ol><li>一定要带着问题去看，猜想验证。</li><li>不要只记忆流程，学编程风格，设计思想（他的代码为什么这么写？如果不这么写呢？包括接口的定义，类的职责，涉及模式的应用，高级语法等等）。</li><li>先抓重点，就像开车熟路，哪个地方限速，哪个地方变道，要走很多次。先走主干道，再去、覆盖分支小路。</li><li>记录核心流程和对象，总结层次、结构、关系，输出（图片或者待注释的源码）。</li><li>培养看源码的信心和感觉，从带着看到自己去看，看更多的源码。</li><li>debug还是直接Ctrl+Alt+B跟方法？debug可以看到实际的值，比如到底是哪个实现类，value到底是什么。但是Ctrl+Alt+B不一定能走到真正的对象，比如有代理或者父类方法，或者多个实现的时候。熟悉流程之后，直接跟方法。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis核心工作原理讲解&quot;&gt;&lt;a href=&quot;#MyBatis核心工作原理讲解&quot; class=&quot;headerlink&quot; title=&quot;MyBatis核心工作原理讲解&quot;&gt;&lt;/a&gt;MyBatis核心工作原理讲解&lt;/h1&gt;&lt;h1 id=&quot;一、MyBatis源码分析</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis最佳实践</title>
    <link href="https://eizo01.github.io/posts/eced4617.html"/>
    <id>https://eizo01.github.io/posts/eced4617.html</id>
    <published>2022-12-04T12:00:00.000Z</published>
    <updated>2023-04-16T14:03:47.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis最佳实践"><a href="#MyBatis最佳实践" class="headerlink" title="MyBatis最佳实践"></a>MyBatis最佳实践</h1><h2 id="1-动态SQL语句"><a href="#1-动态SQL语句" class="headerlink" title="1.动态SQL语句"></a>1.动态SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态 <span class="keyword">SQL</span> 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 <span class="keyword">SQL</span> 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 <span class="keyword">SQL</span>，可以彻底摆脱这种痛苦。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用动态 <span class="keyword">SQL</span> 并非一件易事，但借助可用于任何 <span class="keyword">SQL</span> 映射语句中的强大的动态 <span class="keyword">SQL</span> 语言，MyBatis 显著地提升了这一特性的易用性。</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你之前用过 JSTL 或任何基于类 <span class="keyword">XML</span> <span class="title">语言的文本处理器，你对动态 SQL</span> 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis <span class="number">3</span> 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</span><br></pre></td></tr></table></figure><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h3 id="1-1-if"><a href="#1-1-if" class="headerlink" title="1.1 if"></a>1.1 if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要判断的时候，条件写在<span class="built_in">test</span>中</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">            and user_name = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-choose"><a href="#1-2-choose" class="headerlink" title="1.2 choose"></a>1.2 choose</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要选择一个条件的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- choose 的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;userName != null and userName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_name like CONCAT(CONCAT(&#x27;%&#x27;,#&#123;userName,jdbcType=VARCHAR&#125;),&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-trim"><a href="#1-3-trim" class="headerlink" title="1.3 trim"></a>1.3 trim</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要去掉<span class="keyword">where</span>、<span class="keyword">and</span>、逗号之类的符号的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    trim 的使用</span></span><br><span class="line"><span class="comment">    替代where标签的使用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListTrim&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseSQL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;where&gt;</span></span><br><span class="line"><span class="comment">        &lt;if test=&quot;username!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">            and name = #&#123;username&#125;</span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">    &lt;/where&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null&quot;</span>&gt;</span></span><br><span class="line">            and user_name = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 替代set标签的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    update t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null&quot;</span>&gt;</span></span><br><span class="line">            user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-foreach"><a href="#1-4-foreach" class="headerlink" title="1.4 foreach"></a>1.4 foreach</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要遍历集合的时候</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user </span><br><span class="line">     where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">         #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color:red">动态SQL主要是用来解决SQL语句生成的问题。</span></p><h2 id="2-批量操作"><a href="#2-批量操作" class="headerlink" title="2.批量操作"></a>2.批量操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在项目中会有一些批量操作的场景，比如导入文件批量处理数据的情况（批量新增商户、批量修改商户信息），当数据量非常大，比如超过几万条的时候，在Java代码中循环发送<span class="keyword">SQL</span>到数据库执行肯定是不现实的，因为这个意味着要跟数据库创建几万次会话。即使在同一个连接中，也有重复编译和执行<span class="keyword">SQL</span>的开销。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如循环插入10000条（大约耗时3秒钟）：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Batch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.获取配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">        session = factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环插入10000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">            mapper.insertUser(user);</span><br><span class="line">         &#125;</span><br><span class="line">         session.commit();</span><br><span class="line">         session.close();</span><br><span class="line">         <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">         System.out.println(<span class="string">&quot;循环批量插入&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="variable">MyBatis</span>里面是支持批量的操作的，包括批量的插入、更新、删除。我们可以直接传入一个<span class="built_in">List</span>、<span class="built_in">Set</span>、<span class="built_in">Map</span>或者数组，配合动态<span class="variable">SQL</span>的标签，<span class="variable">MyBatis</span>会自动帮我们生成语法正确的<span class="variable">SQL</span>语句。</span><br></pre></td></tr></table></figure><h3 id="2-1-批量插入"><a href="#2-1-批量插入" class="headerlink" title="2.1 批量插入"></a>2.1 批量插入</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">批量插入的语法是这样的，只要在<span class="built_in">values</span>后面增加插入的值就可以了。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_emp (emp_id, emp_name, gender,email, d_id) <span class="keyword">values</span> ( ?,?,?,?,? ),( ?,?,?,?,? ),( ?,?,?,?,? )</span><br></pre></td></tr></table></figure><p>在Mapper文件里面，我们使用foreach标签拼接 values部分的语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量插入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUserList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span> &gt;</span></span><br><span class="line">    insert into t_user(user_name,real_name)</span><br><span class="line">    values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;user.userName&#125;,#&#123;user.realName&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java代码里面，直接传入一个List类型的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    mapper.insertUserList(list);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;循环批量插入&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入一万条大约耗时1秒钟。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到，动态<span class="keyword">SQL</span>批量插入效率要比循环发送<span class="keyword">SQL</span>执行要高得多。最关键的地方就在于减少了跟数据库交互的次数，并且避免了开启和结束事务的时间消耗。</span><br></pre></td></tr></table></figure><h3 id="2-2-批量更新"><a href="#2-2-批量更新" class="headerlink" title="2.2 批量更新"></a>2.2 批量更新</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">批量更新的语法是这样的，通过<span class="keyword">case</span> <span class="keyword">when</span>，来匹<span class="built_in">配id</span>相关的字段值</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> </span><br><span class="line">user_name <span class="operator">=</span> </span><br><span class="line"><span class="keyword">case</span> id </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> ,</span><br><span class="line">real_name <span class="operator">=</span> </span><br><span class="line"><span class="keyword">case</span> id</span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> ( ? , ? , ? )</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以在Mapper文件里面最关键的就是<span class="keyword">case</span> <span class="keyword">when</span>和<span class="keyword">where</span>的配置。</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要注意一下open属性和separator属性。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserList&quot;</span>&gt;</span></span><br><span class="line"> update t_user set</span><br><span class="line">    user_name =</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span> <span class="attr">open</span>=<span class="string">&quot;case id&quot;</span> <span class="attr">close</span>=<span class="string">&quot;end&quot;</span>&gt;</span></span><br><span class="line">    when #&#123;user.id&#125; then #&#123;user.userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">     ,real_name =</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span> <span class="attr">open</span>=<span class="string">&quot;case id&quot;</span> <span class="attr">close</span>=<span class="string">&quot;end&quot;</span>&gt;</span></span><br><span class="line">      when #&#123;user.id&#125; then #&#123;user.realName&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">     where id in</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">      #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">12000</span>;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2000</span>; i&lt; count; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(i);</span><br><span class="line">        user.setUserName(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    mapper.updateUserList(list);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;批量更新&quot;</span>+count+<span class="string">&quot;条，耗时：&quot;</span> + (end -start )+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-批量删除"><a href="#2-3-批量删除" class="headerlink" title="2.3 批量删除"></a>2.3 批量删除</h3><p>批量删除也是类似的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item.id,jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-BatchExecutor"><a href="#2-4-BatchExecutor" class="headerlink" title="2.4 BatchExecutor"></a>2.4 BatchExecutor</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然MyBatis的动态标签的批量操作也是存在一定的缺点的，比如数据量特别大的时候，拼接出来的<span class="keyword">SQL</span>语句过大。</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MySQL</span>的服务端对于接收的数据包有大小限制，max_allowed_packet 默认是 <span class="number">4</span>M，需要修改默认配置或者手动地控制条数，才可以解决这个问题。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.PacketTooBigException: Packet <span class="keyword">for</span> query is too <span class="title function_">large</span> <span class="params">(<span class="number">7188967</span> &gt; <span class="number">4194304</span>)</span>. You can change <span class="built_in">this</span> value on the server by setting the max_allowed_packet<span class="string">&#x27; variable.</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们的全局配置文件中，可以配置默认的Executor的类型（默认是SIMPLE）。其中有一种BatchExecutor。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在创建会话的时候指定执行器类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br></pre></td></tr></table></figure><p><strong>Executor</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/a01141b547b3498f81bb8509c81ddbe6.png" alt="image.png"></p><ol><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。executeUpdate()是一个语句访问一次数据库，executeBatch()是一批语句访问一次数据库（具体一批发送多少条SQL跟服务端的max_allowed_packet有关）。BatchExecutor底层是对JDBC ps.addBatch()和ps. executeBatch()的封装。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?rewriteBatchedStatements=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">       ps = conn.prepareStatement(</span><br><span class="line">               <span class="string">&quot;INSERT into blog values (?, ?, ?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">101000</span>; i++) &#123;</span><br><span class="line">           <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blog</span>();</span><br><span class="line">           ps.setInt(<span class="number">1</span>, i);</span><br><span class="line">           ps.setString(<span class="number">2</span>, String.valueOf(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           ps.setInt(<span class="number">3</span>, <span class="number">1001</span>);</span><br><span class="line">           ps.addBatch();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       ps.executeBatch();</span><br><span class="line">       ps.close();</span><br><span class="line">       conn.close();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">       se.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException se2) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-关联查询"><a href="#3-关联查询" class="headerlink" title="3.关联查询"></a>3.关联查询</h2><h3 id="3-1-嵌套查询"><a href="#3-1-嵌套查询" class="headerlink" title="3.1 嵌套查询"></a>3.1 嵌套查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在查询业务数据的时候经常会遇到关联查询的情况，比如查询员工就会关联部门（一对一），查询学生成绩就会关联课程（一对一），查询订单就会关联商品（一对多），等等。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户和部门的对应关系是1对1的关系</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌套查询 1对1 1个用户对应一个部门--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserNested&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap1&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            t1.`id`</span><br><span class="line">            ,t1.`user_name`</span><br><span class="line">            ,t1.`real_name`</span><br><span class="line">            ,t1.`password`</span><br><span class="line">            ,t1.`age`</span><br><span class="line">            ,t2.`did`</span><br><span class="line">            ,t2.`d_name`</span><br><span class="line">            ,t2.`d_desc`</span><br><span class="line">        FROM t_user t1</span><br><span class="line">        LEFT JOIN</span><br><span class="line">            t_department t2</span><br><span class="line">            ON t1.`d_id` = t2.`did`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有就是1对多的关联关系，嵌套查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌套查询 1对多 1个部门有多个用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptNested&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap2&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            t1.`id`</span><br><span class="line">            ,t1.`user_name`</span><br><span class="line">            ,t1.`real_name`</span><br><span class="line">            ,t1.`password`</span><br><span class="line">            ,t1.`age`</span><br><span class="line">            ,t2.`did`</span><br><span class="line">            ,t2.`d_name`</span><br><span class="line">            ,t2.`d_desc`</span><br><span class="line">        FROM t_user t1</span><br><span class="line">        RIGHT JOIN</span><br><span class="line">            t_department t2</span><br><span class="line">            ON t1.`d_id` = t2.`did`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-延迟加载"><a href="#3-2-延迟加载" class="headerlink" title="3.2 延迟加载"></a>3.2 延迟加载</h3><p>在MyBatis里面可以通过开启延迟加载的开关来解决这个问题。</p><p>在settings标签里面可以配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。默认false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;proxyFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CGLIB&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>lazyLoadingEnabled决定了是否延迟加载（默认false）。</p><p>aggressiveLazyLoading决定了是不是对象的所有方法都会触发查询。</p><p>1对1的延迟加载配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 延迟加载 1对1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap1Lazy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;queryDeptByUserIdLazy&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserNestedLazy&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap1Lazy&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        t1.`id`</span><br><span class="line">        ,t1.`user_name`</span><br><span class="line">        ,t1.`real_name`</span><br><span class="line">        ,t1.`password`</span><br><span class="line">        ,t1.`age`</span><br><span class="line">        ,t1.d_id</span><br><span class="line">    FROM t_user t1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptByUserIdLazy&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseDept&quot;</span>&gt;</span></span><br><span class="line">    select * from t_department where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：开启了延迟加载的开关，调用user.getDept()以及默认的（equals,clone,hashCode,toString）时才会发起第二次查询，其他方法并不会触发查询，比如blog.getName()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1对1  关联查询 延迟加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.queryUserNestedLazy();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user.getUserName() );</span><br><span class="line">        <span class="comment">//System.out.println(user.getUserName() + &quot;----&gt;&quot;+user.getDept());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发延迟加载的方法可以通过\<lazyLoadTriggerMethods>配置，默认    equals(),clone(),hashCode(),toString()。</lazyLoadTriggerMethods></p><p>1对多的延迟加载的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1对多 延迟加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;nestedMap2Lazy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">select</span>=<span class="string">&quot;queryUserByDeptLazy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDeptNestedLazy&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;nestedMap2&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        ,t2.`did`</span><br><span class="line">        ,t2.`d_name`</span><br><span class="line">        ,t2.`d_desc`</span><br><span class="line">    FROM</span><br><span class="line">        t_department t2</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByDeptLazy&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    select * from t_user where d_id = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-分页操作"><a href="#4-分页操作" class="headerlink" title="4.分页操作"></a>4.分页操作</h2><h3 id="4-1-逻辑分页"><a href="#4-1-逻辑分页" class="headerlink" title="4.1 逻辑分页"></a>4.1 逻辑分页</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis里面有一个逻辑分页对象RowBounds，里面主要有两个属性，<span class="keyword">offset</span>和<span class="keyword">limit</span>（从第几条开始，查询多少条）。我们可以在Mapper接口的方法上加上这个参数，不需要修改<span class="type">xml</span>里面的<span class="keyword">SQL</span>语句。</span><br></pre></td></tr></table></figure><p>接口中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserList</span><span class="params">(RowBounds rowBounds)</span>;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// 设置分页的数据</span></span><br><span class="line">    <span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    List&lt;User&gt; users = mapper.queryUserList(rowBounds);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RowBounds的工作原理其实是对ResultSet的处理。它会舍弃掉前面<span class="keyword">offset</span>条数据，然后再取剩下的数据的<span class="keyword">limit</span>条。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>();</span><br><span class="line">   <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> rsw.getResultSet();</span><br><span class="line">   <span class="built_in">this</span>.skipRows(resultSet, rowBounds);</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">this</span>.shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">       <span class="type">ResultMap</span> <span class="variable">discriminatedResultMap</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveDiscriminatedResultMap(resultSet, resultMap, (String)<span class="literal">null</span>);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> <span class="built_in">this</span>.getRowValue(rsw, discriminatedResultMap, (String)<span class="literal">null</span>);</span><br><span class="line">       <span class="built_in">this</span>.storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，如果数据量大的话，这种翻页方式效率会很低（跟查询到内存中再使用subList(start,end)没什么区别）。所以我们要用到物理翻页。</p><h3 id="4-2-物理分页"><a href="#4-2-物理分页" class="headerlink" title="4.2 物理分页"></a>4.2 物理分页</h3><p>物理翻页是真正的翻页，它是通过数据库支持的语句来翻页。</p><p>第一种简单的办法就是传入参数（或者包装一个page对象），在SQL语句中翻页。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserPage&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">  select * from t_user limit #&#123;curIndex&#125; , #&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一个问题是我们要在Java业务代码里面去计算起止序号；第二个问题是：每个需要翻页的Statement都要编写limit语句，会造成Mapper映射器里面很多代码冗余。</p><p>那我们就需要一种通用的方式，不需要去修改配置的任何一条SQL语句，我们只要传入当前是第几页，每页多少条就可以了，自动计算出来起止序号。</p><p>我们最常用的做法就是使用翻页的插件，比如PageHelper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageSize每一页几条</span></span><br><span class="line">PageHelper.startPage(pn, <span class="number">10</span>);</span><br><span class="line">List&lt;Employee&gt; emps = employeeService.getAll();</span><br><span class="line"><span class="comment">// navigatePages 导航页码数</span></span><br><span class="line"><span class="type">PageInfo</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInfo</span>(emps, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> Msg.success().add(<span class="string">&quot;pageInfo&quot;</span>, page);</span><br></pre></td></tr></table></figure><p>PageHelper是通过MyBatis的拦截器实现的，插件的具体原理我们后面的课再分析。简单地来说，它会根据PageHelper的参数，改写我们的SQL语句。比如MySQL会生成limit语句，Oracle会生成rownum语句，SQL Server会生成top语句。</p><h2 id="5-MBG与Example"><a href="#5-MBG与Example" class="headerlink" title="5.MBG与Example"></a>5.MBG与Example</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mybatis/g</span>enerator</span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在项目中使用MyBaits的时候，针对需要操作的一张表，需要创建实体类、Mapper映射器、Mapper接口，里面又有很多的字段和方法的配置，这部分的工作是非常繁琐的。而大部分时候我们对于表的基本操作是相同的，比如根据主键查询、根据<span class="built_in">Map</span>查询、单条插入、批量插入、根据主键删除等等等等。当我们的表很多的时候，意味着有大量的重复工作。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以有没有一种办法，可以根据我们的表，自动生成实体类、Mapper映射器、Mapper接口，里面包含了我们需要用到的这些基本方法和<span class="keyword">SQL</span>呢？</span><br></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis也提供了一个代码生成器，叫做MyBatis <span class="built_in">Generator</span>，简称MBG（它是MyBatis的一个插件）。我们只需要修改一个配置文件，使用相关的jar包命令或者Java代码就可以帮助我们生成实体类、映射器和接口文件。</span><br></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MBG的配置文件里面有一个<span class="keyword">Example</span>的开关，这个东西用来构造复杂的筛选条件的，换句话说就是根据我们的代码去生成<span class="keyword">where</span>条件。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理：在实体类中包含了两个有继承关系的Criteria，用其中自动生成的方法来构建查询条件。把这个包含了Criteria的实体类作为参数传到查询参数中，在解析Mapper映射器的时候会转换成<span class="keyword">SQL</span>条件。</span><br></pre></td></tr></table></figure><h3 id="5-1-添加配置文件"><a href="#5-1-添加配置文件" class="headerlink" title="5.1 添加配置文件"></a>5.1 添加配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们添加如下的配置文件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库的驱动包路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;C:\Users\dpb\.m2\repository\mysql\mysql-connector-java\8.0.11\mysql-connector-java-8.0.11.jar&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 去掉生成文件中的注释 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库链接URL、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot;</span></span><br><span class="line"><span class="comment">              connectionURL=&quot;jdbc:oracle:thin:@localhost:1521:XE&quot;</span></span><br><span class="line"><span class="comment">              userId=&quot;car&quot;</span></span><br><span class="line"><span class="comment">              password=&quot;car&quot;&gt;</span></span><br><span class="line"><span class="comment">      &lt;/jdbcConnection&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成模型的包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.domain&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否在当前路径下新加一层schema,eg：fase路径com.oop.eksp.user.model， true:com.oop.eksp.user.model.[schemaName] --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的映射文件包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成DAO的包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.boge.vip.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">&quot;t_user&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;User&quot;</span>   /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-添加插件"><a href="#5-2-添加插件" class="headerlink" title="5.2 添加插件"></a>5.2 添加插件</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们需要在pom.<span class="built_in">xml</span>中添加对应的插件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-生成"><a href="#5-3-生成" class="headerlink" title="5.3 生成"></a>5.3 生成</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们就可以利用插件帮助我们快速生成我们需要的表结构对应的相关文件</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/31e53fbe324044ad90e09d5256518ba3.png" alt="image.png"></p><p>有springboot配置类的方式生成！</p><h2 id="6-通用Mapper"><a href="#6-通用Mapper" class="headerlink" title="6. 通用Mapper"></a>6. 通用Mapper</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：当我们的表字段发生变化的时候，我们需要修改实体类和Mapper文件定义的字段和方法。如果是增量维护，那么一个个文件去修改。如果是全量替换，我们还要去对比用MBG生成的文件。字段变动一次就要修改一次，维护起来非常麻烦。</span><br></pre></td></tr></table></figure><h3 id="6-1-方式一"><a href="#6-1-方式一" class="headerlink" title="6.1 方式一"></a>6.1 方式一</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个，因为MyBatis的Mapper是支持继承的（见：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mybatis/my</span>batis-<span class="number">3</span><span class="regexp">/issues/</span><span class="number">35</span>）。所以我们可以把我们的Mapper.xml和Mapper接口都分成两个文件。一个是MBG生成的，这部分是固定不变的。然后创建DAO类继承生成的接口，变化的部分就在DAO里面维护。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapperExt</span> <span class="keyword">extends</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUserByName</span><span class="params">(String userName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.boge.vip.mapper.UserMapperExt&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMapExt&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.vip.domain.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;i_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;iId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMapExt&quot;</span> &gt;</span></span><br><span class="line">    select * from t_user where user_name = #&#123;userName&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在全局配置文件中我们也需要扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapperExt.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以以后只要修改Ext的文件就可以了。这么做有一个缺点，就是文件会增多。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/9b8ab56ac56746938c1ce5836f7c6c18.png" alt="image.png"></p><h3 id="6-2-方式二"><a href="#6-2-方式二" class="headerlink" title="6.2 方式二"></a>6.2 方式二</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">既然针对每张表生成的基本方法都是一样的，也就是公共的方法部分代码都是一样的，我们能不能把这部分合并成一个文件，让它支持泛型呢？</span><br></pre></td></tr></table></figure><p>当然可以！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个支持泛型的通用接口，比如叫GPBaseMapper</span><br></pre></td></tr></table></figure><p><T>，把实体类作为参数传入。这个接口里面定义了大量的增删改查的基础方法，这些方法都是支持泛型的。</T></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义的Mapper接口继承该通用接口，例如<span class="keyword">BlogMapper </span><span class="keyword">extends </span>GPBaseMapper</span><br></pre></td></tr></table></figure><p><Blog>，自动获得对实体类的操作方法。遇到没有的方法，我们依然可以在我们自己的Mapper里面编写。</Blog></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们能想到的解决方案，早就有人做了这个事了，这个东西就叫做通用Mapper。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/abel533/Mapper/wiki">https://github.com/abel533/Mapper/wiki</a></p><p>用途：主要解决单表的增删改查问题，并不适用于多表关联查询的场景。</p><p>除了配置文件变动的问题之外，通用Mapper还可以解决：</p><ol><li>每个Mapper接口中大量的重复方法的定义；</li><li>屏蔽数据库的差异；</li><li>提供批量操作的方法；</li><li>实现分页。</li></ol><p>使用方式：在Spring中使用时，引入jar包，替换applicationContext.xml中的sqlSessionFactory和configure。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.boge.crud.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-MyBatis-Plus"><a href="#7-MyBatis-Plus" class="headerlink" title="7.MyBatis-Plus"></a>7.MyBatis-Plus</h2><p><a href="https://mybatis.plus/guide">https://mybatis.plus/guide</a></p><p>MyBatis-Plus是原生MyBatis的一个增强工具，可以在使用原生MyBatis的所有功能的基础上，使用plus特有的功能。</p><p>MyBatis-Plus的核心功能：</p><p><strong>通用 CRUD</strong>：定义好Mapper接口后，只需要继承BaseMapper<T> 接口即可获得通用的增删改查功能，无需编写任何接口方法与配置文件。</T></p><p><strong>条件构造器</strong>：通过EntityWrapper<T>（实体包装类），可以用于拼接 SQL 语句，并且支持排序、分组查询等复杂的SQL。</T></p><p><strong>代码生成器</strong>：支持一系列的策略配置与全局配置，比MyBatis的代码生成更好用。</p><p>另外MyBatis-Plus也有分页的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis最佳实践&quot;&gt;&lt;a href=&quot;#MyBatis最佳实践&quot; class=&quot;headerlink&quot; title=&quot;MyBatis最佳实践&quot;&gt;&lt;/a&gt;MyBatis最佳实践&lt;/h1&gt;&lt;h2 id=&quot;1-动态SQL语句&quot;&gt;&lt;a href=&quot;#1-动态SQL语</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门</title>
    <link href="https://eizo01.github.io/posts/4658a061.html"/>
    <id>https://eizo01.github.io/posts/4658a061.html</id>
    <published>2022-12-02T12:00:00.000Z</published>
    <updated>2023-04-16T14:03:47.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、MyBatis的介绍"><a href="#一、MyBatis的介绍" class="headerlink" title="一、MyBatis的介绍"></a>一、MyBatis的介绍</h1><p>官网地址：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p><p>推荐一个网站：<a href="http://www.mybatis.cn/archives/789.html">http://www.mybatis.cn/archives/789.html</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 <span class="keyword">JDBC </span>代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 <span class="keyword">Java </span>POJO（Plain Old <span class="keyword">Java </span>Objects，普通老式 <span class="keyword">Java </span>对象）为数据库中的记录。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“半自动”的ORM框架能够很好的解决上面所讲的Hibernate的几个问题，半自动化”是相对于Hibernate的全自动化来说的。它的封装程度没有Hibernate那么高，不会自动生成全部的<span class="keyword">SQL</span>语句，主要解决的是<span class="keyword">SQL</span>和对象的映射问题。</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis的前身是ibatis，<span class="number">2001</span>年开始开发，是“internet”和“abatis [&#x27;æbətɪs]（障碍物）”两个单词的组合。04年捐赠给Apache。<span class="number">2010</span>年更名为MyBatis。</span><br></pre></td></tr></table></figure><p>在MyBatis里面，SQL和代码是分离的，所以会写SQL基本上就会用MyBatis，没有额外的学习成本。</p><h1 id="二、MyBatis使用"><a href="#二、MyBatis使用" class="headerlink" title="二、MyBatis使用"></a>二、MyBatis使用</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们就通过实际的案例代码来演示下MyBatis的具体使用。</span><br></pre></td></tr></table></figure><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们先来搭建MyBatis的使用环境</span><br></pre></td></tr></table></figure><h3 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个普通的Maven项目，然后添加对应的Mybatis和MySQL的相关依赖</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-POJO对象"><a href="#1-2-POJO对象" class="headerlink" title="1.2 POJO对象"></a>1.2 POJO对象</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的案例通过数据库中的 T_USER 表来讲解，创建的对应的POJO对象为,有用到Lombok，大家可以自行添加对应的依赖</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer dId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-添加配置文件"><a href="#1-3-添加配置文件" class="headerlink" title="1.3 添加配置文件"></a>1.3 添加配置文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis中我们需要添加全局的配置文件和对应的映射文件。</span><br><span class="line">默认名字：mybatis-config.xml</span><br></pre></td></tr></table></figure><p>全局配置文件,这里面是对MyBatis的核心行为的控制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印查询语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- STATEMENT级别的缓存，使一级缓存，只针对当前执行的这一statement有效 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zdw.domain.User&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关联的映射文件,通常来说一张表对应一个，我们会在这个里面配置我们增删改查的SQL语句，以及参数和返回的结果集的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zdw.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- $只能用在自定义类型和map上 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByBean&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user where user_name = &#x27;$&#123;userName&#125;&#x27;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库属性的配置文件一并贴出 db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h2 id="2-编程式的使用"><a href="#2-编程式的使用" class="headerlink" title="2. 编程式的使用"></a>2. 编程式的使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环境准备好后我们就可以来使用其帮助我们实现数据库的操作了。在MyBatis中的使用方式有两种，首先来看下第一种编程式的方式</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis API 的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;com.zdw.mapper.UserMapper.selectUserList&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了执行效果</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230330164348963.png" alt="image-20230330164348963"></p><p>这种方式其实就是通过SqlSession中给我们提供的相关的API方法来执行对应的CRUD操作，查找我们写的SQL语句是通过 namespace+”.”+id的方式实现的</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/b027e8acea894748ad6f4d68abf34feb.png" alt="image.png"></p><p>这样的调用方式，解决了重复代码、资源管理、SQL耦合、结果集映射这4大问题。</p><p>不过，这样的调用方式还是会存在一些问题：</p><ol><li>Statement ID是硬编码，维护起来很不方便；</li><li>不能在编译时进行类型检查，如果namespace或者Statement ID输错了，只能在运行的时候报错。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以我们通常会使用第二种方式，也是新版的MyBatis里面推荐的方式：定义一个Mapper接口的方式。这个接口全路径必须跟Mapper.xml里面的<span class="keyword">namespace</span>对应起来，方法也要跟<span class="symbol">Statement</span> <span class="symbol">ID</span>一一对应。</span><br></pre></td></tr></table></figure><h2 id="3-代理方式的使用"><a href="#3-代理方式的使用" class="headerlink" title="3. 代理方式的使用"></a>3. 代理方式的使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们还可以通过SqlSession中提供的getMapper方法来获取声明接口的代理对象来处理。实现如下</span><br></pre></td></tr></table></figure><h3 id="3-1-接口声明"><a href="#3-1-接口声明" class="headerlink" title="3.1 接口声明"></a>3.1 接口声明</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们需要声明一个Dao的接口。然后在接口中定义相关的方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dao 的接口声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUserList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-映射文件"><a href="#3-2-映射文件" class="headerlink" title="3.2 映射文件"></a>3.2 映射文件</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们通过getMapper的方式来使用的话，我们需要添加对应的映射文件，在映射文件中我们需要将<span class="keyword">namespace</span>声明为上面接口的全类路径名，同时对应的<span class="symbol">sql</span>标签的<span class="symbol">id</span>要和方法名称一致。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/6ca7a8099bf1466e9e5596b664d18b1d.png" alt="image.png"></p><p>最后我们还有保证映射文件的名称和接口的名称要一致。在文件很多的情况能很好的管理</p><h3 id="3-3-getMapper"><a href="#3-3-getMapper" class="headerlink" title="3.3 getMapper"></a>3.3 getMapper</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后我们在通过getMapper方法来获取声明的Dao接口的代码对象来实现数据库操作。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis getMapper 方法的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 1.获取配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.selectUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.关闭会话</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过执行接口方法，来执行映射器中的<span class="keyword">SQL</span>语句。</span><br></pre></td></tr></table></figure><p>最后总结下MyBatis的特点：</p><ol><li>使用连接池对连接进行管理</li><li>SQL和代码分离，集中管理</li><li>结果集映射</li><li>参数映射和动态SQL</li><li>重复SQL的提取</li><li>缓存管理</li><li>插件机制</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate和MyBatis跟DbUtils、Spring JDBC一样，都是对JDBC的一个封装，我们去看源码，最后一定会看到<span class="keyword">Connection</span>、<span class="keyword">Statement</span>和ResultSet这些对象。对应的选择</span><br></pre></td></tr></table></figure><ol><li>在一些业务比较简单的项目中，我们可以使用Hibernate；</li><li>如果需要更加灵活的SQL，可以使用MyBatis，对于底层的编码，或者性能要求非常高的场合，可以用JDBC；</li><li>实际上在我们的项目中，MyBatis和Spring JDBC是可以混合使用的；</li><li>当然，我们也根据项目的需求自己写ORM框架。</li></ol><h1 id="三、MyBatis核心配置"><a href="#三、MyBatis核心配置" class="headerlink" title="三、MyBatis核心配置"></a>三、MyBatis核心配置</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis中我们发现其实他最核心的应该是那两个配置文件，一个全局配置文件，一个映射文件。我们只要把这两个文件弄清楚，其实对于MyBatis的使用就掌握了大部分。接下来我们详细的给大家来介绍下这两个配置文件</span><br></pre></td></tr></table></figure><h2 id="1-全局配置文件"><a href="#1-全局配置文件" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MyBatis</span> 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。他们是有先序顺序的，配置文档的顶层结构如下：</span><br></pre></td></tr></table></figure><blockquote><ul><li>configuration（配置）</li><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ul></blockquote><h3 id="1-1-configuration"><a href="#1-1-configuration" class="headerlink" title="1.1 configuration"></a>1.1 configuration</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configuration</span>是整个配置文件的根标签，实际上也对应着MyBatis里面最重要的配置类<span class="keyword">Configuration</span>。它贯穿MyBatis执行流程的每一个环节。我们打开这个类看一下，这里面有很多的属性，跟其他的子标签也能对应上。</span><br></pre></td></tr></table></figure><h3 id="1-2-properties"><a href="#1-2-properties" class="headerlink" title="1.2 properties"></a>1.2 properties</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个一级标签是<span class="keyword">properties</span>，用来配置参数信息，比如最常见的数据库连接信息。</span><br></pre></td></tr></table></figure><p>为了避免直接把参数写死在xml配置文件中，我们可以把这些参数单独放在properties文件中，用properties标签引入进来，然后在xml配置文件中用${}引用就可以了。可以用resource引用应用里面的相对路径，也可以用url指定本地服务器或者网络的绝对路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入一个属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-settings"><a href="#1-3-settings" class="headerlink" title="1.3 settings"></a>1.3 settings</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>设置参数</th><th style="text-align:left">描述</th><th style="text-align:left">有效值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td style="text-align:left">全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>lazyLoadingEnabled</td><td style="text-align:left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>aggressiveLazyLoading</td><td style="text-align:left">当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考lazyLoadTriggerMethods).</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>multipleResultSetsEnabled</td><td style="text-align:left">是否允许单一语句返回多结果集（需要兼容驱动）。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>useColumnLabel</td><td style="text-align:left">使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>useGeneratedKeys</td><td style="text-align:left">允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>autoMappingBehavior</td><td style="text-align:left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</td><td style="text-align:left">NONE, PARTIAL, FULL</td><td style="text-align:left">PARTIAL</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td style="text-align:left">指定发现自动映射目标未知列（或者未知属性类型）的行为。 NONE: 不做任何反应WARNING: 输出提醒日志(‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN) FAILING: 映射失败 (抛出 SqlSessionException)</td><td style="text-align:left">NONE, WARNING, FAILING</td><td style="text-align:left">NONE</td></tr><tr><td>defaultExecutorType</td><td style="text-align:left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td><td style="text-align:left">SIMPLE REUSE BATCH</td><td style="text-align:left">SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td style="text-align:left">设置超时时间，它决定驱动等待数据库响应的秒数。</td><td style="text-align:left">任意正整数</td><td style="text-align:left">Not Set (null)</td></tr><tr><td>defaultFetchSize</td><td style="text-align:left">为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。</td><td style="text-align:left">任意正整数</td><td style="text-align:left">Not Set (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td style="text-align:left">允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>safeResultHandlerEnabled</td><td style="text-align:left">允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td>mapUnderscoreToCamelCase</td><td style="text-align:left">是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td><td style="text-align:left">true\</td><td style="text-align:left">false</td><td>False</td></tr><tr><td>localCacheScope</td><td style="text-align:left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td><td style="text-align:left">SESSION\</td><td style="text-align:left">STATEMENT</td><td>SESSION</td></tr><tr><td>jdbcTypeForNull</td><td style="text-align:left">当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td><td style="text-align:left">JdbcType 常量. 大多都为: NULL, VARCHAR and OTHER</td><td style="text-align:left">OTHER</td></tr><tr><td>lazyLoadTriggerMethods</td><td style="text-align:left">指定哪个对象的方法触发一次延迟加载。</td><td style="text-align:left">用逗号分隔的方法列表。</td><td style="text-align:left">equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td style="text-align:left">指定动态 SQL 生成的默认语言。</td><td style="text-align:left">一个类型别名或完全限定类名。</td><td style="text-align:left">org.apache.ibatis.scripting.xmltags.XMLLanguageDriver</td></tr><tr><td>defaultEnumTypeHandler</td><td style="text-align:left">指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始)     一个类型别名或完全限定类名。</td><td style="text-align:left">org.apache.ibatis.type.EnumTypeHandler</td><td style="text-align:left"></td></tr><tr><td>callSettersOnNulls</td><td style="text-align:left">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</td><td style="text-align:left">true\</td><td style="text-align:left">false</td><td>false</td></tr><tr><td>returnInstanceForEmptyRow</td><td style="text-align:left">当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始）</td><td style="text-align:left">true\</td><td style="text-align:left">false</td><td>false</td></tr><tr><td>logPrefix</td><td style="text-align:left">指定 MyBatis 增加到日志名称的前缀。</td><td style="text-align:left">任何字符串</td><td style="text-align:left">Not set</td></tr><tr><td>logImpl</td><td style="text-align:left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td style="text-align:left">SLF4J</td><td style="text-align:left">LOG4J\</td><td>LOG4J2 \</td><td>JDK_LOGGING \</td><td>COMMONS_LOGGING\</td></tr><tr><td>proxyFactory</td><td style="text-align:left">指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</td><td style="text-align:left">CGLIB\</td><td style="text-align:left">JAVASSIST</td></tr><tr><td>vfsImpl</td><td style="text-align:left">指定VFS的实现</td><td style="text-align:left">自定义VFS的实现的类全限定名，以逗号分隔。</td><td style="text-align:left">Not set</td></tr><tr><td>useActualParamName</td><td style="text-align:left">允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的工程必须采用Java 8编译，并且加上-parameters选项。（从3.4.1开始）</td><td style="text-align:left">true\</td><td style="text-align:left">false</td><td>true</td></tr><tr><td>configurationFactory</td><td style="text-align:left">指定一个提供Configuration实例的类。 这个被返回的Configuration实例用来加载被反序列化对象的懒加载属性值。 这个类必须包含一个签名方法static Configuration getConfiguration(). (从 3.2.3 版本开始)</td><td style="text-align:left">类型别名或者全类名.</td><td style="text-align:left">Not set</td></tr></tbody></table></div><p>设置的案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打印查询语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过select标签的 fetchType来覆盖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- STATEMENT级别的缓存，使一级缓存，只针对当前执行的这一statement有效 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-typeAliases"><a href="#1-4-typeAliases" class="headerlink" title="1.4 typeAliases"></a>1.4 typeAliases</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeAlias是类型的别名，跟Linux系统里面的<span class="built_in">alias</span>一样，主要用来简化类名全路径的拼写。比如我们的参数类型和返回值类型都可能会用到我们的Bean，如果每个地方都配置全路径的话，那么内容就比较多，还可能会写错。</span><br></pre></td></tr></table></figure><p>我们可以为自己的Bean创建别名，既可以指定单个类，也可以指定一个package，自动转换。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.domain.User&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在使用的时候我们就可以简化了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/ec167bbe0a78409aa6904b5dbbba4e3e.png" alt="image.png"></p><p>MyBatis里面有很多系统预先定义好的类型别名，在TypeAliasRegistry中。所以可以用string代替java.lang.String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TypeAliasRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">  registerAlias(<span class="string">&quot;string&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;byte&quot;</span>, Byte.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;long&quot;</span>, Long.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;short&quot;</span>, Short.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;int&quot;</span>, Integer.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;integer&quot;</span>, Integer.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;double&quot;</span>, Double.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;float&quot;</span>, Float.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;boolean&quot;</span>, Boolean.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;byte[]&quot;</span>, Byte[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;long[]&quot;</span>, Long[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;short[]&quot;</span>, Short[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;int[]&quot;</span>, Integer[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;integer[]&quot;</span>, Integer[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;double[]&quot;</span>, Double[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;float[]&quot;</span>, Float[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;boolean[]&quot;</span>, Boolean[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;_byte&quot;</span>, <span class="type">byte</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_long&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_short&quot;</span>, <span class="type">short</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_int&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_integer&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_double&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_float&quot;</span>, <span class="type">float</span>.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_boolean&quot;</span>, <span class="type">boolean</span>.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;_byte[]&quot;</span>, <span class="type">byte</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_long[]&quot;</span>, <span class="type">long</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_short[]&quot;</span>, <span class="type">short</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_int[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_integer[]&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_double[]&quot;</span>, <span class="type">double</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_float[]&quot;</span>, <span class="type">float</span>[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;_boolean[]&quot;</span>, <span class="type">boolean</span>[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;date&quot;</span>, Date.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;decimal&quot;</span>, BigDecimal.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;bigdecimal&quot;</span>, BigDecimal.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;biginteger&quot;</span>, BigInteger.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;object&quot;</span>, Object.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;date[]&quot;</span>, Date[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;decimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;bigdecimal[]&quot;</span>, BigDecimal[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;biginteger[]&quot;</span>, BigInteger[].class);</span><br><span class="line">  registerAlias(<span class="string">&quot;object[]&quot;</span>, Object[].class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;map&quot;</span>, Map.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;hashmap&quot;</span>, HashMap.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;list&quot;</span>, List.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;arraylist&quot;</span>, ArrayList.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;collection&quot;</span>, Collection.class);</span><br><span class="line">  registerAlias(<span class="string">&quot;iterator&quot;</span>, Iterator.class);</span><br><span class="line"></span><br><span class="line">  registerAlias(<span class="string">&quot;ResultSet&quot;</span>, ResultSet.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-TypeHandler"><a href="#1-5-TypeHandler" class="headerlink" title="1.5 TypeHandler"></a>1.5 TypeHandler</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于Java类型和数据库的JDBC类型不是一一对应的（比如<span class="type">String</span>与varchar、<span class="type">char</span>、text），所以我们把Java对象转换为数据库的值，和把数据库的值转换成Java对象，需要经过一定的转换，这两个方向的转换就要用到TypeHandler。</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当参数类型和返回值是一个对象的时候，我没有做任何的配置，为什么对象里面的一个<span class="type">String</span>属性，可以转换成数据库里面的varchar字段？</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是因为<span class="type">MyBatis</span>已经内置了很多<span class="type">TypeHandler</span>（在<span class="keyword">type</span>包下），它们全部全部注册在<span class="type">TypeHandlerRegistry</span>中，他们都继承了抽象类<span class="type">BaseTypeHandler</span>，泛型就是要处理的<span class="type">Java</span>数据类型。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个也是为什么大部分类型都不需要处理。当我们查询数据和登记数据，做数据类型转换的时候，就会自动调用对应的TypeHandler的方法。</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/7645fcdfbdcf4ca1b1749ab2ad12f5cb.png" alt="image.png"></p><p>我们可以自定义一个TypeHandler来帮助我们简单的处理数据，比如查询的结果的字段如果是一个字符串，且值为”zhangsan”就修饰下这个信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类型处理器</span></span><br><span class="line"><span class="comment"> *    处理的字段如果是 String类型的话就 且 内容是 zhangsan 拼接个信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeHandler</span>  <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据的时候回调的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jdbcType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------setNonNullParameter1：&quot;</span>+parameter);</span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnName);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时将我们的处理器在全局配置文件中注册下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.boge.type.MyTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在映射文件中配置对应的处理器</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/f16ae2441126453da41dffbd9c5dda98.png" alt="image.png"></p><h3 id="1-6-objectFactory"><a href="#1-6-objectFactory" class="headerlink" title="1.6 objectFactory"></a>1.6 objectFactory</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们把数据库返回的结果集转换为实体类的时候，需要创建对象的实例，由于我们不知道需要处理的类型是什么，有哪些属性，所以不能用<span class="keyword">new</span><span class="type"></span>的方式去创建。只能通过反射来创建。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在MyBatis里面，它提供了一个工厂类的接口，叫做ObjectFactory，专门用来创建对象的实例（MyBatis封装之后，简化了对象的创建），里面定义了4个方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span>;</span><br><span class="line">  &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isCollection</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>void</strong> setProperties(Properties properties);</td><td>设置参数时调用</td></tr><tr><td><T> T create(Class<T> type);</T></T></td><td>创建对象（调用无参构造函数）</td></tr><tr><td><T> T create(Class<T> type, List<Class<?>&gt; constructorArgTypes, List<Object> constructorArgs);</Object></Class<?></T></T></td><td>创建对象（调用带参数构造函数）</td></tr><tr><td><T> <strong>boolean</strong> isCollection(Class<T> type)</T></T></td><td>判断是否集合</td></tr></tbody></table></div><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory有一个默认的实现类DefaultObjectFactory。创建对象的方法最终都调用了<span class="built_in">instantiateClass</span>()，这里面能看到反射的代码。</span><br></pre></td></tr></table></figure><p>默认情况下，所有的对象都是由DefaultObjectFactory创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.boge.objectfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.boge.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.factory.DefaultObjectFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义ObjectFactory，通过反射的方式实例化对象</span></span><br><span class="line"><span class="comment"> * 一种是无参构造函数，一种是有参构造函数——第一个方法调用了第二个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">(Class type)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建对象方法：&quot;</span> + type);</span><br><span class="line">        <span class="keyword">if</span> (type.equals(User.class)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">blog</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.create(type);</span><br><span class="line">            blog.setUserName(<span class="string">&quot;object factory&quot;</span>);</span><br><span class="line">            blog.setId(<span class="number">1111</span>);</span><br><span class="line">            blog.setRealName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> blog;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.create(type);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObjectFactory</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">myBlog</span> <span class="operator">=</span> (User) factory.create(User.class);</span><br><span class="line">        System.out.println(myBlog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在config文件里面注册，在创建对象的时候会被自动调用：</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;com.boge.objectfactory.MyObjectFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;boge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样，就可以让MyBatis的创建实体类的时候使用我们自己的对象工厂。</span><br></pre></td></tr></table></figure><h3 id="1-7-plugins"><a href="#1-7-plugins" class="headerlink" title="1.7 plugins"></a>1.7 plugins</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件是MyBatis的一个很强大的机制。跟很多其他的框架一样，MyBatis预留了插件的接口，让MyBatis更容易扩展。</span><br></pre></td></tr></table></figure><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins</a></p><h3 id="1-8-environments"><a href="#1-8-environments" class="headerlink" title="1.8 environments"></a>1.8 environments</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environments标签用来管理数据库的环境，比如我们可以有开发环境、测试环境、生产环境的数据库。可以在不同的环境中使用不同的数据库地址或者类型。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单独使用时配置成MANAGED没有事务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span><span class="comment">&lt;!--unPOOLED 不用连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些别名都在configuration</p><p><img src="HTTPs://zdwtop.cn/blog/image-20230330171020089.png" alt="image-20230330171020089"></p><p><strong>environment</strong></p><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个<span class="built_in">environment</span>标签就是一个数据源，代表一个数据库。这里面有两个关键的标签，一个是事务管理器，一个是数据源。</span><br></pre></td></tr></table></figure><p><strong>transactionManager</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果配置的是JDBC，则会使用Connection对象的<span class="built_in">commit</span>()、<span class="built_in">rollback</span>()、<span class="built_in">close</span>()管理事务。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果配置成MANAGED，会把事务交给容器来管理，比如JBOSS，Weblogic。因为我们跑的是本地程序，如果配置成MANAGE不会有任何事务。</span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是Spring + MyBatis，则没有必要配置，因为我们会直接在applicationContext.<span class="built_in">xml</span>里面配置数据源和事务，覆盖MyBatis的配置。</span><br></pre></td></tr></table></figure><p><strong>dataSource</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据源，顾名思义，就是数据的来源，一个数据源就对应一个数据库。在Java里面，它是对数据库连接的一个抽象。</span><br></pre></td></tr></table></figure><p>一般的数据源都会包括连接池管理的功能，所以很多时候也把DataSource直接 称为连接池，准确的说法应该是：带连接池功能的数据源。</p><h3 id="1-9-mappers"><a href="#1-9-mappers" class="headerlink" title="1.9 mappers"></a>1.9 mappers</h3><p><mappers\>标签配置的是映射器，也就是Mapper.xml的路径。这里配置的目的是让MyBatis在启动的时候去扫描这些映射器，创建映射关系。</mappers\></p><p>我们有四种指定Mapper文件的方式：</p><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers">http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers</a></p><p>a.使用相对于类路径的资源引用（resource）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.使用完全限定资源定位符（绝对路径）（URL）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;file:///app/sale/mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c.使用映射器接口实现类的完全限定类名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.boge.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>d.将包内的映射器接口实现全部注册为映射器（最常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.boge.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-映射文件"><a href="#2-映射文件" class="headerlink" title="2. 映射文件"></a>2. 映射文件</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 <span class="keyword">XML</span> <span class="title">文件就显得相对简单。如果拿它跟具有相同功能的 JDBC</span> 代码进行对比，你会立即发现省掉了将近 <span class="number">95</span>% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</span><br></pre></td></tr></table></figure><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><h3 id="2-1-cache"><a href="#2-1-cache" class="headerlink" title="2.1 cache"></a>2.1 cache</h3><p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：<cache></cache></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定命名空间的缓存配置（是否开启二级缓存）。</span><br><span class="line">使用自定义缓存：可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。</span><br><span class="line">&lt;<span class="keyword">cache</span> <span class="keyword">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-cache-ref"><a href="#2-2-cache-ref" class="headerlink" title="2.2 cache-ref"></a>2.2 cache-ref</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其他命名空间缓存配置的引用。缓存相关两个标签在缓存组件模块的时候会使用到。</span><br><span class="line">目前很少使用</span><br></pre></td></tr></table></figure><h3 id="2-3-resultMap"><a href="#2-3-resultMap" class="headerlink" title="2.3 resultMap"></a>2.3 resultMap</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie<span class="symbol">&#x27;g</span>是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;CHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-sql"><a href="#2-4-sql" class="headerlink" title="2.4 sql"></a>2.4 sql</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可被其他语句引用的可重用语句块。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">emp_id, emp_name, gender, email, d_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-增删改查标签"><a href="#2-5-增删改查标签" class="headerlink" title="2.5 增删改查标签"></a>2.5 增删改查标签</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对常用的增删改查操作提供的有对应的标签来处理</span><br></pre></td></tr></table></figure><p>\<insert> – 映射插入语句</insert></p><p>\<update> – 映射更新语句</update></p><p>\<delete> – 映射删除语句</delete></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag"> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">parameterMap</span>=<span class="string">&quot;deprecated&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultMap</span>=<span class="string">&quot;personResultMap&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">timeout</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">fetchSize</span>=<span class="string">&quot;256&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultSetType</span>=<span class="string">&quot;FORWARD_ONLY&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td style="text-align:left"><code>parameterType</code></td><td style="text-align:left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td style="text-align:left"><code>parameterMap</code></td><td style="text-align:left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td></tr><tr><td style="text-align:left"><code>resultType</code></td><td style="text-align:left">期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td style="text-align:left"><code>resultMap</code></td><td style="text-align:left">对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td style="text-align:left"><code>flushCache</code></td><td style="text-align:left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr><tr><td style="text-align:left"><code>useCache</code></td><td style="text-align:left">将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td style="text-align:left"><code>timeout</code></td><td style="text-align:left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td style="text-align:left"><code>fetchSize</code></td><td style="text-align:left">这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td style="text-align:left"><code>statementType</code></td><td style="text-align:left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td style="text-align:left"><code>resultSetType</code></td><td style="text-align:left">FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td></tr><tr><td style="text-align:left"><code>databaseId</code></td><td style="text-align:left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr><tr><td style="text-align:left"><code>resultOrdered</code></td><td style="text-align:left">这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td></tr><tr><td style="text-align:left"><code>resultSets</code></td><td style="text-align:left">这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、MyBatis的介绍&quot;&gt;&lt;a href=&quot;#一、MyBatis的介绍&quot; class=&quot;headerlink&quot; title=&quot;一、MyBatis的介绍&quot;&gt;&lt;/a&gt;一、MyBatis的介绍&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://mybatis.</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>ORM框架的发展历程</title>
    <link href="https://eizo01.github.io/posts/6b5152eb.html"/>
    <id>https://eizo01.github.io/posts/6b5152eb.html</id>
    <published>2022-12-01T10:19:03.000Z</published>
    <updated>2023-04-16T14:03:47.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ORM框架的发展历程"><a href="#一、ORM框架的发展历程" class="headerlink" title="一、ORM框架的发展历程"></a>一、ORM框架的发展历程</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/c8fb12ecffb042fea929ce1fb4b9029a.png" alt="image.png"><br>从面向sql编程到面向对象编程。</p><h2 id="1-JDBC操作"><a href="#1-JDBC操作" class="headerlink" title="1. JDBC操作"></a>1. JDBC操作</h2><h3 id="1-1-JDBC操作的特点"><a href="#1-1-JDBC操作的特点" class="headerlink" title="1.1 JDBC操作的特点"></a>1.1 JDBC操作的特点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最初的时候我们肯定是直接通过jdbc来直接操作数据库的，本地数据库我们有一张student表，那么我们的操作流程是</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接</span></span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from student where id = 1&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">major</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;major&quot;</span>);</span><br><span class="line"></span><br><span class="line">    student.setId(id);</span><br><span class="line">    student.setName(name);</span><br><span class="line">    student.setMajor(major);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的操作步骤是，首先在pom.xml中引入MySQL的驱动依赖，注意MySQL数据库的版本</p><ol><li>Class.forName注册驱动</li><li>获取一个Connection对象</li><li>创建一个Statement对象</li><li>execute()方法执行SQL语句，获取ResultSet结果集</li><li>通过ResultSet结果集给POJO的属性赋值</li><li>最后关闭相关的资源</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种实现方式首先给我们的感觉就是操作步骤比较繁琐，在复杂的业务场景中会更麻烦。尤其是我们需要自己来维护管理资源的连接，如果忘记了，就很可能造成数据库服务连接耗尽。同时我们还能看到具体业务的<span class="keyword">SQL</span>语句直接在代码中写死耦合性增强。每个连接都会经历这几个步骤，重复代码很多，总结上面的操作的特点：</span><br></pre></td></tr></table></figure><ol><li>代码重复</li><li>资源管理</li><li>结果集处理</li><li>SQL耦合</li></ol><p>针对这些问题我们可以把公共的部分提取出来</p><h3 id="1-2-JDBC优化1-0"><a href="#1-2-JDBC优化1-0" class="headerlink" title="1.2 JDBC优化1.0"></a>1.2 JDBC优化1.0</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对常规jdbc操作的特点，我们可以先从代码重复和资源管理方面来优化，我们可以创建一个工具类来专门处理这个问题</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_NAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供获取数据库连接的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn = DriverManager.getConnection(JDBC_URL,JDBC_NAME,JDBC_PASSWORD);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn )</span>&#123;</span><br><span class="line">        close(conn,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts )</span>&#123;</span><br><span class="line">        close(conn,sts,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement sts , ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sts != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sts.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的jdbc操作代码可以简化如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 通过JDBC查询用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">           <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 打开连接</span></span><br><span class="line">           conn = DBUtils.getConnection();</span><br><span class="line">           <span class="comment">// 执行查询</span></span><br><span class="line">           stmt = conn.createStatement();</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from student where id = 1&quot;</span>;</span><br><span class="line">           rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取结果集</span></span><br><span class="line">           <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">               <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">major</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;major&quot;</span>);</span><br><span class="line"></span><br><span class="line">               student.setId(id);</span><br><span class="line">               student.setName(userName);</span><br><span class="line">               student.setMajor(major);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               System.out.println(student);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           DBUtils.close(conn,stmt,rs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过JDBC实现添加用户信息的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 打开连接</span></span><br><span class="line">           conn = DBUtils.getConnection();</span><br><span class="line">           <span class="comment">// 执行查询</span></span><br><span class="line">           stmt = conn.createStatement();</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student(name,major)values(&#x27;李四&#x27;,&#x27;管理学&#x27;)&quot;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">           System.out.println(<span class="string">&quot;影响的行数:&quot;</span> + i);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">           se.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           DBUtils.close(conn,stmt);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但是整体的操作步骤还是会显得比较复杂，这时我们可以进一步优化</p><h3 id="1-3-JDBC优化2-0"><a href="#1-3-JDBC优化2-0" class="headerlink" title="1.3 JDBC优化2.0"></a>1.3 JDBC优化2.0</h3><p>我们可以针对DML操作的方法来优化，先解决SQL耦合的问题，在DBUtils中添加封装DML操作的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行数据库的DML操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">update</span><span class="params">(String sql,Object ... paramter)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(paramter != <span class="literal">null</span> &amp;&amp; paramter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,paramter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    close(conn,ps);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在DML操作的时候我们就可以简化为如下步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过JDBC实现添加用户信息的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student(name,major)values(?,?)&quot;</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           DBUtils.update(sql,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;数学&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>显然这种方式会比最初的使用要简化很多，但是在查询处理的时候我们还是没有解决ResultSet结果集的处理问题，表的不同结构还是需要自己构造，在上面我们只优化了添加和更新的优化。对于查询JDBC代码还是过于冗余。</p><h3 id="1-4-JDBC优化3-0"><a href="#1-4-JDBC优化3-0" class="headerlink" title="1.4 JDBC优化3.0"></a>1.4 JDBC优化3.0</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对<span class="keyword">ResultSet</span>的优化我们需要从反射和元数据两方面入手，具体如下</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法的简易封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, Class clazz, Object ... parameter)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    conn = getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">if</span>(parameter != <span class="literal">null</span> &amp;&amp; parameter.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameter.length; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,parameter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="comment">// 获取对应的表结构的元数据</span></span><br><span class="line">    <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> ps.getMetaData();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        <span class="comment">// 根据 字段名称获取对应的值 然后将数据要封装到对应的对象中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; columnCount+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据每列的名称获取对应的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnName(i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line">            setFieldValueForColumn(o,columnName,columnValue);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add((T) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据字段名称设置 对象的属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> columnName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValueForColumn</span><span class="params">(Object o, String columnName,Object columnValue)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = o.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据字段获取属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">        <span class="comment">// 私有属性放开权限</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(o,columnValue);</span><br><span class="line">        field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">// 说明不存在 那就将 _ 转换为 驼峰命名法</span></span><br><span class="line">        <span class="keyword">if</span>(columnName.contains(<span class="string">&quot;_&quot;</span>))&#123;</span><br><span class="line">            <span class="type">Pattern</span> <span class="variable">linePattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;_(\\w)&quot;</span>);</span><br><span class="line">            columnName = columnName.toLowerCase();</span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> linePattern.matcher(columnName);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                matcher.appendReplacement(sb, matcher.group(<span class="number">1</span>).toUpperCase());</span><br><span class="line">            &#125;</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">            <span class="comment">// 再次调用复制操作</span></span><br><span class="line">            setFieldValueForColumn(o,sb.toString(),columnValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了以上方法后我们的查询操作就可以简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 通过JDBC查询用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from t_user where id = ?&quot;</span>;</span><br><span class="line">           List&lt;Student&gt; list = DBUtils.query(sql, Student.class,<span class="number">1</span>);</span><br><span class="line">           System.out.println(list);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样一来我们在操作数据库中数据的时候就只需要关注于核心的SQL操作了。当然以上的设计还比较粗糙，这时Apache 下的 DbUtils是一个很好的选择。</p><h2 id="2-Apache-DBUtils"><a href="#2-Apache-DBUtils" class="headerlink" title="2.Apache DBUtils"></a>2.Apache DBUtils</h2><p>官网地址：<a href="https://commons.apache.org/proper/commons-dbutils/">https://commons.apache.org/proper/commons-dbutils/</a></p><h3 id="2-1-初始配置"><a href="#2-1-初始配置" class="headerlink" title="2.1 初始配置"></a>2.1 初始配置</h3><p>DButils中提供了一个QueryRunner类，它对数据库的增删改查的方法进行了封装，获取QueryRunner的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROPERTY_PATH</span> <span class="operator">=</span> <span class="string">&quot;druid.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource dataSource;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> QueryRunner queryRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> DBUtils.class.getClassLoader().getResourceAsStream(PROPERTY_PATH);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        properties.load(in);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    dataSource = <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    dataSource.configFromPropety(properties);</span><br><span class="line">    <span class="comment">// 使用数据源初始化 QueryRunner</span></span><br><span class="line">    queryRunner = <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建QueryRunner对象的时候我们需要传递一个DataSource对象，这时我们可以选择Druid或者Hikai等常用的连接池工具，我这儿用的是Druid。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">druid.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">druid.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">druid.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">druid.minIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">druid.maxActive</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><h3 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h3><p>QueryRunner中提供的方法解决了重复代码的问题，传入数据源解决了资源管理的问题。而对于ResultSet结果集的处理则是通过 ResultSetHandler 来处理。我们可以自己来实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询所有的用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">       DruidUtils.init();</span><br><span class="line">       <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> DruidUtils.getQueryRunner();</span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">       List&lt;Student&gt; list = queryRunner.query(sql, <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 直接回调</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">               List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">               <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                   <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">                   student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                   student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                   student.setMajor(rs.getString(<span class="string">&quot;major&quot;</span>));</span><br><span class="line"></span><br><span class="line">                   list.add(student);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> list;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">           System.out.println(student);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者用DBUtils中提供的默认的相关实现来解决</p><p><img src="/posts/6b5152eb.htm/image-20220707143936426.png" alt="image-20220707143936426"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ResultHandle的实现类处理查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserUseBeanListHandle</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    DruidUtils.init();</span><br><span class="line">    <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> DruidUtils.getQueryRunner();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">    <span class="comment">// 不会自动帮助我们实现驼峰命名的转换</span></span><br><span class="line">    List&lt;User&gt; list = queryRunner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Apache 封装的DBUtils是能够很方便的帮助我们实现相对比较简单的数据库操作</p><h2 id="3-SpringJDBC"><a href="#3-SpringJDBC" class="headerlink" title="3.SpringJDBC"></a>3.SpringJDBC</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Spring框架平台下，也提供的有<span class="keyword">JDBC的封装操作，在Spring中提供了一个模板方法 </span><span class="keyword">JdbcTemplate，里面封装了各种各样的 </span>execute,query和update方法。</span><br></pre></td></tr></table></figure><p>JdbcTemplate这个类是JDBC的核心包的中心类，简化了JDBC的操作，可以避免常见的异常，它封装了JDBC的核心流程，应用只要提供SQL语句，提取结果集就可以了，它是线程安全的。</p><h3 id="3-1-初始配置"><a href="#3-1-初始配置" class="headerlink" title="3.1 初始配置"></a>3.1 初始配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在SpringJdbcTemplate的使用中，我们依然要配置对应的数据源，然后将JdbcTemplate对象注入到IoC容器中。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        template.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-CRUD操作"><a href="#3-2-CRUD操作" class="headerlink" title="3.2 CRUD操作"></a>3.2 CRUD操作</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们具体操作数据库中数据的时候，我们只需要从容器中获取JdbcTemplate实例即可</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(<span class="string">&quot;insert into t_user(user_name,real_name)values(?,?)&quot;</span>,<span class="string">&quot;bobo&quot;</span>,<span class="string">&quot;波波&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">        List&lt;User&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                user.setUserName(rs.getString(<span class="string">&quot;user_name&quot;</span>));</span><br><span class="line">                user.setRealName(rs.getString(<span class="string">&quot;real_name&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">        List&lt;User&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Hibernate"><a href="#4-Hibernate" class="headerlink" title="4.Hibernate"></a>4.Hibernate</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面介绍的Apache DBUtils和SpringJdbcTemplate虽然简化了数据库的操作，但是本身提供的功能还是比较简单的(缺少缓存，事务管理等)，所以我们在实际开发中往往并没有直接使用上述技术，而是用到了Hibernate和MyBatis等这些专业的ORM持久层框架。</span><br></pre></td></tr></table></figure><h3 id="4-1-ORM介绍"><a href="#4-1-ORM介绍" class="headerlink" title="4.1 ORM介绍"></a>4.1 ORM介绍</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ORM</span><span class="params">( Object Relational Mapping)</span></span> ，也就是对象与关系的映射，对象是程序里面的对象，关系是它与数据库里面的数据的关系，也就是说，ORM框架帮助我们解决的问题是程序对象和关系型数据库的相互映射的问题</span><br></pre></td></tr></table></figure><p>O:对象</p><p>M:映射</p><p>R:关系型数据库</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1657172938017/4cfe3e6447fa4bae84ccfa7b6321ed8f.png" alt="image.png"></p><h3 id="4-2-Hibernate的使用"><a href="#4-2-Hibernate的使用" class="headerlink" title="4.2 Hibernate的使用"></a>4.2 Hibernate的使用</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hibernate</span>是一个很流行的ORM框架，<span class="number">2001</span>年的时候就出了第一个版本。使用步骤如下</span><br></pre></td></tr></table></figure><h4 id="4-2-1-创建项目"><a href="#4-2-1-创建项目" class="headerlink" title="4.2.1 创建项目"></a>4.2.1 创建项目</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个Maven项目并添加相关的依赖即可，我们在此处直接通过 SpringDataJpa的依赖处理</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-配置文件"><a href="#4-2-2-配置文件" class="headerlink" title="4.2.2 配置文件"></a>4.2.2 配置文件</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在使用Hibernate的使用，我们需要为实体类创建一些hbm的<span class="built_in">xml</span>映射文件</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&#x27;-//Hibernate/Hibernate Mapping DTD 3.0//EN&#x27;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&#x27;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.boge.model.User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;t_user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;realName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;real_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及Hibernate的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-configuration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span></span><br><span class="line">            com.mysql.cj.jdbc.Driver</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span></span><br><span class="line">            jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span></span><br><span class="line">            org.hibernate.dialect.MySQLDialect</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-CRUD-操作"><a href="#4-2-3-CRUD-操作" class="headerlink" title="4.2.3 CRUD 操作"></a>4.2.3 CRUD 操作</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在程序中我们可以通过Hibernate提供的 <span class="keyword">Session</span>对象来实现CRUD操作</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hibernate操作案例演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 默认使用hibernate.cfg.xml</span></span><br><span class="line">        configuration.configure();</span><br><span class="line">        <span class="comment">// 创建Session工厂</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">        <span class="comment">// 创建Session</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="comment">// 获取事务对象</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> session.getTransaction();</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">// 把对象添加到数据库中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">666</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;hibernate&quot;</span>);</span><br><span class="line">        user.setRealName(<span class="string">&quot;持久层框架&quot;</span>);</span><br><span class="line">        session.save(user);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-4-其他方式"><a href="#4-2-4-其他方式" class="headerlink" title="4.2.4 其他方式"></a>4.2.4 其他方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在映射文件的位置，我们也可以通过注解的方式来替换掉映射文件</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;real_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;i_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer dId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Spring中给我们提供的JPA对持久层框架做了统一的封装，而且本质上就是基于HibernateJPA来实现的，所以我们在使用的时候也可以通过SpringDataJPA的API来操作</p><p>dao的接口只需要继承JpaRepository接口即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserDao extends JpaRepository&lt;User,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层正常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-Hibernate总结"><a href="#4-3-Hibernate总结" class="headerlink" title="4.3 Hibernate总结"></a>4.3 Hibernate总结</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate的出现大大简化了我们的数据库操作，同时也能够更好的应对更加复杂的业务场景，Hibernate具有如下的特点</span><br></pre></td></tr></table></figure><ol><li>根据数据库方言自定生成SQL，移植性好</li><li>自动管理连接资源</li><li>实现了对象和关系型数据的完全映射，操作对象就想操作数据库记录一样</li><li>提供了缓存机制</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate在处理复杂业务的时候同样也存在一些问题</span><br></pre></td></tr></table></figure><ol><li>比如API中的get(),update()和save()方法，操作的实际上是所有的字段，没有办法指定部分字段，换句话说就是不够灵活</li><li>自定生成SQL的方式，如果要基于SQL去做一些优化的话，也是非常困难的。</li><li>不支持动态SQL，比如分表中的表名，条件，参数变化等，无法根据条件自动生成SQL</li></ol><p>因此我们需要一个更为灵活的框架-MyBatis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ORM框架的发展历程&quot;&gt;&lt;a href=&quot;#一、ORM框架的发展历程&quot; class=&quot;headerlink&quot; title=&quot;一、ORM框架的发展历程&quot;&gt;&lt;/a&gt;一、ORM框架的发展历程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fynotefile.o</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://eizo01.github.io/categories/MyBatis/"/>
    
    
    <category term="orm" scheme="https://eizo01.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="https://eizo01.github.io/posts/54cf796.html"/>
    <id>https://eizo01.github.io/posts/54cf796.html</id>
    <published>2022-11-07T12:00:00.000Z</published>
    <updated>2023-03-18T14:02:16.597Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis底层数据结构</h1><p><strong>Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构</strong>。</p><p>现在附上3.0和6.0的数据结构图</p><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>在最新的 Redis 代码6.0，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318165759154.png" alt="image-20230318165759154"></p><p><img src="https://zdwtop.cn/blog/a9c3e7dc4ac79363d8eb8eb2290a58e6.png" alt="img"></p><p>图有xiaolincoding的贡献。感谢。</p><h2 id="redis的key-value结构">redis的key-value结构</h2><p>我们还是得复习一下整个redis的key-value结构</p><p><img src="https://zdwtop.cn/blog/3c386666e4e7638a07b230ba14b400fe.png" alt="img"></p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 *<em>void * key 和 void * value 指针， <em>key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</em></em>。</li></ul><p>void * key 和 void * value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><p><img src="https://zdwtop.cn/blog/58d3987af2af868dca965193fb27c464.png" alt="img"></p><p>对象结构里包含的成员变量：</p><ul><li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li><li>encoding，标识该对象使用了哪种底层的数据结构；</li><li><strong>ptr，指向底层数据结构的指针</strong>。</li></ul><h2 id="SDS">SDS</h2><p>简单动态字符串（SDS）是Redis的字符串实现之一，它是一个动态字符串，可以自动扩展和收缩，支持O(1)时间复杂度的字符串长度获取.</p><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p><h3 id="C-语言字符串的缺陷">C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p><p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p><img src="https://zdwtop.cn/blog/bcf6bde3b647bdc343efcbc1a8f10579.png" alt="img" style="zoom:80%;"><p>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方*</strong>）</p><p>还有<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（这也是一个可以改进的地方）</strong></p><p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所有字符串操作的函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方*</strong>）。</p><p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul><p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p><h3 id="SDS-结构设计">SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><img src="https://zdwtop.cn/blog/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom:50%;"><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p><h4 id="O（1）复杂度获取字符串长度">O（1）复杂度获取字符串长度</h4><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p><p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p><h4 id="二进制安全">二进制安全</h4><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p><h4 id="不会发生缓冲区溢出">不会发生缓冲区溢出</h4><p>C 语言的字符串标准库提供的字符串操作函数，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p><p>Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p><p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p><p>SDS 扩容的规则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hisds <span class="title function_">hi_sdsMakeRoomFor</span><span class="params">(hisds s, <span class="type">size_t</span> addlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// s目前的剩余空间已足够，无需扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//获取目前s的长度</span></span><br><span class="line">    len = hi_sdslen(s);</span><br><span class="line">    sh = (<span class="type">char</span> *)s - hi_sdsHdrSize(oldtype);</span><br><span class="line">    <span class="comment">//扩展之后 s 至少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    <span class="comment">//根据新长度，为s分配新空间所需要的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; HI_SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">//新长度&lt;HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则，分配长度为目前长度+1MB</span></span><br><span class="line">        newlen += HI_SDS_MAX_PREALLOC;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li><li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li></ul><h4 id="节省内存空间">节省内存空间</h4><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p><p>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p><p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><p><img src="https://zdwtop.cn/blog/image-20230318171838299.png" alt="image-20230318171838299"></p><p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li><li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li></ul><p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p>「字节对齐」的方式分配内存</p><h2 id="链表">链表</h2><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。</p><p>链表是Redis的列表实现之一，它是一个双向链表，每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针.</p><h3 id="链表结构设计">链表结构设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    struct listNode *next;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 在 listNode 结构体基础上又封装了 list 这个数据结构</span></span><br><span class="line">    typedef struct list &#123;</span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    unsigned <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p><img src="https://zdwtop.cn/blog/cadf797496816eb343a19c2451437f1e.png" alt="img"></p><h3 id="链表的优势与缺陷">链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>；</li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li></ul><p>链表的缺陷也是有的：</p><ul><li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li><li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li></ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p><h2 id="压缩列表ZipList">压缩列表<strong>ZipList</strong></h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>压缩列表是Redis的列表和哈希表实现之一，它是一个紧凑的数据结构，可以在内存中存储多个元素，每个元素可以是一个字符串或一个整数.</p><p>但是，压缩列表的缺陷也是有的：</p><ul><li>不能保存过多的元素，否则查询效率就会降低；</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li></ul><p>Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><h3 id="压缩列表结构设计">压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="https://zdwtop.cn/blog/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img"></p><p>压缩列表在表头有三个字段：</p><ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>压缩列表节点（<strong>entry</strong>）的构成如下：</p><ul><li><em><strong>prevlen</strong></em>，<strong>记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</strong></li><li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；占用1个、2个或5个字节</li></ul><p><img src="https://zdwtop.cn/blog/image-20230318182627294.png" alt="image-20230318182627294"></p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关.</p><ul><li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li><li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节/2字节/5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。</p><h3 id="连锁更新">连锁更新</h3><p>压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p><ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p><h3 id="压缩列表的缺陷">压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题.</p><h2 id="哈希表-dict">哈希表 <strong>dict</strong></h2><p>字典是Redis的哈希表实现之一，它是一个键值对的无序集合，其中每个键都映射到一个值.</p><p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。<strong>Redis 采用了「链式哈希」来解决哈希冲突</strong></p><h3 id="哈希表结构设计">哈希表结构设计</h3><p><img src="https://zdwtop.cn/blog/image-20230318183756294.png" alt="image-20230318183756294"></p><p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p><p><img src="https://zdwtop.cn/blog/dc495ffeaa3c3d8cb2e12129b3423118.png" alt="img"></p><p>跳跃表是Redis的有序集合实现之一，它是一个有序的数据结构，其中每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向存储在节点中的值的指针。跳跃表是一种高效的有序数据结构，可以在O(log N)时间内执行插入、删除和查找操作.</p><h3 id="rehash">rehash</h3><p>哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//两个Hash表，交替使用，用于rehash操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    …</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p><p><img src="https://zdwtop.cn/blog/2fedbc9cd4cb7236c302d695686dd478.png" alt="img"></p><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><p><img src="https://zdwtop.cn/blog/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img"></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><h3 id="渐进式-rehash">渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p><blockquote><p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p></blockquote><h3 id="rehash-触发条件">rehash 触发条件</h3><p>rehash 的触发条件跟**负载因子（load factor）**有关系。</p><p>负载因子可以通过下面这个公式计算：</p><p><img src="https://zdwtop.cn/blog/image-20230318184250548.png" alt="image-20230318184250548"></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul><h2 id="整数集合Inset">整数集合<strong>Inset</strong></h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p><p><img src="https://zdwtop.cn/blog/image-20230318184640470.png" alt="image-20230318184640470"></p><h3 id="升级扩容">升级扩容</h3><p><img src="https://zdwtop.cn/blog/image-20230318184733792.png" alt="image-20230318184733792"></p><h2 id="跳表skip-list">跳表<strong>skip list</strong></h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><p>struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</p><p>跳表结构里包含了：</p><ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li></ul><h3 id="跳表结构设计">跳表结构设计</h3><p><strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p><img src="https://zdwtop.cn/blog/image-20230318185333886.png" alt="image-20230318185333886"></p><p><img src="https://zdwtop.cn/blog/redis_skiplist_example.png" alt="Redis 核心数据结构（二） - &quot;地瓜哥&quot;博客网"></p><p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p><p><strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>其中，ZSKIPLIST_MAXLEVEL 定义的是最高的层数，Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32。</p><p>跳表的查找复杂度就是 O(logN)。</p><h3 id="为什么用跳表而不用平衡树？">为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL树、红黑树等）？</p><p>简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。平衡树每个节点包含 2 个指针,跳表平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。</li></ul><p>对象是Redis的所有数据类型的底层实现，它是一个通用的数据结构，可以表示字符串、列表、哈希表、有序集合等多种数据类型.</p><h2 id="quicklist">quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList</p><p>头尾指针-双端链表 节点是ziplist</p><p><img src="https://zdwtop.cn/blog/image-20230318190615928.png" alt="image-20230318190615928"></p><p><img src="https://zdwtop.cn/blog/image-20230318190619375.png" alt="image-20230318190619375"></p><p><img src="https://zdwtop.cn/blog/f46cbe347f65ded522f1cc3fd8dba549.png" alt="img"></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h2 id="listpack">listpack</h2><p>Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p><strong>在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p><h3 id="listpack-结构设计">listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构</p><p><img src="https://zdwtop.cn/blog/4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img"></p><p>stpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis底层数据结构&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Key和Value的数据结构组织</title>
    <link href="https://eizo01.github.io/posts/1cc613d0.html"/>
    <id>https://eizo01.github.io/posts/1cc613d0.html</id>
    <published>2022-11-05T12:00:00.000Z</published>
    <updated>2023-03-18T14:04:30.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的Key和Value的数据结构组织"><a href="#Redis的Key和Value的数据结构组织" class="headerlink" title="Redis的Key和Value的数据结构组织"></a>Redis的Key和Value的数据结构组织</h2><h3 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p><img src="HTTPs://zdwtop.cn/blog/1eb5ca015a3b4389ad4ede842d98df1f.png" alt="image.png"></p><p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。</p><p>哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对：我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p><p>但当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在<br>的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p><p><img src="HTTPs://zdwtop.cn/blog/f2a1f73d63f1428cad1324a7b67283b4.png" alt="image.png"></p><p>Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</p><p>当然如果这个数组一直不变，那么hash冲突会变很多，这个时候检索效率会大打折扣，所以Redis就需要把数组进行扩容（一般是扩大到原来的两倍），但是问题来了，扩容后每个hash桶的数据会分散到不同的位置，这里设计到元素的移动，必定会阻塞IO，所以这个ReHash过程会导致很多请求阻塞。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免这个问题，Redis 采用了渐进式 rehash。</p><p>首先、Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash。</p><p>1、给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍</p><p>2、把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中</p><p>3、释放哈希表 1 的空间</p><p>在上面的第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。</p><p><img src="HTTPs://zdwtop.cn/blog/2406a8206e944d449b03f1f390bedf0d.png" alt="image.png"></p><p>在Redis 开始执行 rehash，Redis仍然正常处理客户端请求，但是要加入一个额外的处理：</p><p>处理第1个请求时，把哈希表 1中的第1个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>处理第2个请求时，把哈希表 1中的第2个索引位置上的所有 entries 拷贝到哈希表 2 中</p><p>如此循环，直到把所有的索引位置的数据都拷贝到哈希表 2 中。</p><p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><p>所以这里基本上也可以确保根据key找value的操作在O（1）左右。</p><p>不过这里要注意，如果Redis中有海量的key值的话，这个Rehash过程会很长很长，虽然采用渐进式Rehash，但在Rehash的过程中还是会导致请求有不小的卡顿。并且像一些统计命令也会非常卡顿：比如keys</p><p>按照Redis的配置每个实例能存储的最大<em>的key的数量</em>为2的32次方,即2.5亿，但是尽量把key的数量控制在千万以下，这样就可以避免Rehash导致的卡顿问题，如果数量确实比较多，建议采用分区hash存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;a href=&quot;#Redis的Key和Value的数据结构组织&quot; class=&quot;headerlink&quot; title=&quot;Redis的Key和Value的数据结构组织&quot;&gt;&lt;/a&gt;Redis的Key和Value的数据结构</summary>
      
    
    
    
    <category term="Redis" scheme="https://eizo01.github.io/categories/Redis/"/>
    
    
    <category term="Redis数据结构" scheme="https://eizo01.github.io/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
